<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>代码随想录-二叉树</title>
    <link href="/2023/06/01/Algo_and_DS/2023-06-01-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/06/01/Algo_and_DS/2023-06-01-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树">二叉树</h3><p>动态规划存在一个状态转移方程，当前的状态必然从过往的状态依据这个状态转移方程得来。</p><table><thead><tr class="header"><th>题目</th><th style="text-align: center;">230505</th></tr></thead><tbody><tr class="odd"><td>LC144. 二叉树的前序遍历</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC94. 二叉树的中序遍历</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC145. 二叉树的后序遍历</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC102.二叉树的层序遍历</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC107.二叉树的层次遍历 II</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC116. 填充每个节点的下一个右侧节点指针</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC117. 填充每个节点的下一个右侧节点指针II</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC104.二叉树的最大深度</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC111.二叉树的最小深度</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC226.翻转二叉树</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC101. 对称二叉树</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC222.完全二叉树的节点个数</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC110.平衡二叉树</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC 257. 二叉树的所有路径</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC404.左叶子之和</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC513.找树左下角的值</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC112. 路径总和</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC113. 路径总和ii</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC105. 从前序与中序遍历序列构造二叉树</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC106. 从中序与后序遍历序列构造二叉树</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC654. 最大二叉树</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC617. 合并二叉树</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC700. 二叉搜索树中的搜索</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC98. 验证二叉搜索树</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC530. 二叉搜索树的最小绝对差</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC501.二叉搜索树中的众数</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC236. 二叉树的最近公共祖先</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC235. 二叉搜索树的最近公共祖先</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC701. 二叉搜索树中的插入操作</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC669. 修剪二叉搜索树</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC108. 将有序数组转换为二叉搜索树</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC538.把二叉搜索树转换为累加树</td><td style="text-align: center;">[x]</td></tr></tbody></table><h3 id="定义">定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>, left = <span class="hljs-literal">None</span>, right = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.val = val<br>        self.left = left<br>        self.right = right<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pprint_binary_tree</span>(<span class="hljs-params">root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Print a binary tree in an aesthetically pleasing way.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param root: Root node of the binary tree.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_print_binary_tree</span>(<span class="hljs-params">root: <span class="hljs-type">Optional</span>[TreeNode], prefix: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span>, is_left: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Empty tree&quot;</span>)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">if</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            _print_binary_tree(root.right, prefix + (<span class="hljs-string">&quot;│   &quot;</span> <span class="hljs-keyword">if</span> is_left <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;    &quot;</span>), <span class="hljs-literal">False</span>)<br><br>        <span class="hljs-built_in">print</span>(prefix + (<span class="hljs-string">&quot;└── &quot;</span> <span class="hljs-keyword">if</span> is_left <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;┌── &quot;</span>) + <span class="hljs-built_in">str</span>(root.val))<br><br>        <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            _print_binary_tree(root.left, prefix + (<span class="hljs-string">&quot;    &quot;</span> <span class="hljs-keyword">if</span> is_left <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;│   &quot;</span>), <span class="hljs-literal">True</span>)<br><br>    _print_binary_tree(root)<br><br></code></pre></td></tr></table></figure><h4 id="各种遍历定义">各种遍历定义</h4><ul><li>前序遍历：当前节点访问在左右子节点访问之前</li><li>中序遍历：当前节点访问在左右子节点访问之间</li><li>后序遍历：当前节点访问在左右子节点访问之后</li></ul><h4 id="递归前序遍历">递归前序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recursive</span>(<span class="hljs-params">root: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>visit(root)<br>recursive(root.left)<br>    recursive(root.right)<br></code></pre></td></tr></table></figure><h4 id="递归中序遍历">递归中序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recursive</span>(<span class="hljs-params">root: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>recursive(root.left)<br>visit(root)<br>    recursive(root.right)<br></code></pre></td></tr></table></figure><h4 id="递归后序遍历">递归后序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recursive</span>(<span class="hljs-params">root: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>recursive(root.left)<br>    recursive(root.right)<br>    visit(root)<br></code></pre></td></tr></table></figure><h4 id="迭代前序遍历">迭代前序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">iterative</span>(<span class="hljs-params">self, root: TreeNode</span>):<br>    <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span><br>    stack = [root]<br>    <span class="hljs-keyword">while</span> stack:<br>        root = stack.pop()<br>        visit(root)<br>        <span class="hljs-comment"># push back to stack in reversed order</span><br>        <span class="hljs-keyword">if</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: stack.append(root.right)<br>        <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: stack.append(root.left)<br></code></pre></td></tr></table></figure><h4 id="迭代中序遍历">迭代中序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">iterative</span>(<span class="hljs-params">self, root: TreeNode</span>):<br>    stack = []<br>    <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            stack.append(root)<br>            root = root.left<br>        <span class="hljs-keyword">else</span>:<br>            root = stack.pop()<br>            visit(root)<br>            root = root.right<br></code></pre></td></tr></table></figure><h4 id="迭代后序遍历">迭代后序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">iterative</span>(<span class="hljs-params">self, root: TreeNode</span>):<br>    ret = []<br>    stack = []<br>    prev = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">or</span> root:<br>        <span class="hljs-keyword">while</span> root:<br>            stack.append(root)<br>            root = root.left<br>        root = stack.pop()<br>        <span class="hljs-keyword">if</span> prev == root.right <span class="hljs-keyword">or</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            ret.append(root.val)<br>            prev = root<br>            root = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            stack.append(root)<br>            root = root.right<br>            prev = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><p>另外地，后序遍历左-右-中，可以看作<strong><em>反向</em></strong>前序遍历中-右-左结果的<strong><em>倒序</em></strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">iterative</span>(<span class="hljs-params">self, root: TreeNode</span>):<br><span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span><br>    stack = [root]<br>    <span class="hljs-keyword">while</span> stack:<br>        root = stack.pop()<br>        visit(root)<br>        <span class="hljs-comment"># push back to stack in reversed order</span><br>        <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: stack.append(root.left)<br>        <span class="hljs-keyword">if</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>: stack.append(root.right)<br>    <span class="hljs-comment"># Note: visit() is called in reversed order</span><br></code></pre></td></tr></table></figure><h4 id="统一的迭代前中后序遍历">统一的迭代前中后序遍历</h4><p>上述的遍历实际模拟了前中后序遍历的访问顺序，逻辑不统一。</p><p>这里可以使用空指针标记一个节点的子节点是否已经被放入栈。已经放入栈的节点实行访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">iterative</span>(<span class="hljs-params">self, root: TreeNode</span>):<br>    stack = [root]<br>    <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> ret<br>    <span class="hljs-keyword">while</span> stack:<br>        root = stack.pop()<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            root = stack.pop()<br>            visit(root)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># pre-order</span><br>            <span class="hljs-keyword">if</span> root.right: stack.append(root.right)<br>            <span class="hljs-keyword">if</span> root.left: stack.append(root.left)<br>            stack.append(root)<br>            stack.append(<span class="hljs-literal">None</span>)<br>           <br>        <span class="hljs-comment"># in-order</span><br>            <span class="hljs-keyword">if</span> root.right: stack.append(root.right)<br>            stack.append(root)<br>            stack.append(<span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> root.left: stack.append(root.left)<br>            <br>            <span class="hljs-comment"># post-order</span><br>            stack.append(root)<br>            stack.append(<span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> root.right: stack.append(root.right)<br>            <span class="hljs-keyword">if</span> root.left: stack.append(root.left)<br></code></pre></td></tr></table></figure><h4 id="递归层序遍历">递归层序遍历</h4><p>可以使用层计数器+先序遍历的方法实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> []<br>ret = []<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">recursive</span>(<span class="hljs-params">root, depth</span>):<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> depth == <span class="hljs-built_in">len</span>(ret): ret.append([])<br>        ret[depth].append(root.val)<br>        recursive(root.left, depth+<span class="hljs-number">1</span>)<br>        recursive(root.right, depth+<span class="hljs-number">1</span>)<br>    recursive(root, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h4 id="迭代层序遍历">迭代层序遍历</h4><p>使用队列可以很快实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> []<br>ret = []<br>q = deque([root])<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q):<br>    ret.append([])<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(q)):<br>        root = q.popleft()<br>        ret[-<span class="hljs-number">1</span>].append(root.val)<br>        <span class="hljs-keyword">if</span> root.left: q.append(root.left)<br>        <span class="hljs-keyword">if</span> root.right: q.append(root.right)<br>    <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><h3 id="平衡二叉树">平衡二叉树</h3><blockquote><p><ahref="https://zhuanlan.zhihu.com/p/165939383">【数据结构】AVL树（平衡二叉树）画法速成教学 - 知乎 (zhihu.com)</a></p><p><ahref="https://blog.csdn.net/qq_43915356/article/details/106381560#LL_27">【数据结构】平衡二叉树的调整(RRLL LR RL）旋转详解讲解_平衡二叉树rr旋转_列队猫的博客-CSDN博客</a></p></blockquote><p>平衡因子：左子树深度-右子树</p><p>平衡二叉树：abs(平衡因子) &lt;= 1</p><h4 id="插入">插入</h4><p>失衡节点：离插入节点最近的一个平衡因子绝对值大于1的节点</p><p>根据失衡节点向插入节点方向访问的顺序数2个子节点（共3个节点），可以判断旋转方向：LL,LR, RL, RR</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AVL</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">balanceFactor</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            lb, ld = self.balanceFactor(root.left)<br>            rb, rd = self.balanceFactor(root.right)<br>            <span class="hljs-keyword">return</span> ld - rd, <span class="hljs-built_in">max</span>(ld, rd) + <span class="hljs-number">1</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insertAVL</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> TreeNode(val)<br>        ptr = root<br>        stack = []<br>        <span class="hljs-keyword">while</span> ptr <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            stack.append(ptr)<br>            <span class="hljs-keyword">if</span> val &lt; ptr.val:<br>                <span class="hljs-keyword">if</span> ptr.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    ptr.left = TreeNode(val)<br>                    stack.append(ptr.left)<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    ptr = ptr.left<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> ptr.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    ptr.right = TreeNode(val)<br>                    stack.append(ptr.right)<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    ptr = ptr.right<br>        ptr = <span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">3</span><br>        <span class="hljs-keyword">while</span> ptr &gt;= <span class="hljs-number">0</span>:<br>            factor, _ = self.balanceFactor(stack[ptr])<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(factor) &gt; <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> stack[ptr].left == stack[ptr+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> stack[ptr+<span class="hljs-number">1</span>].left == stack[ptr+<span class="hljs-number">2</span>]:<br>                    <span class="hljs-keyword">if</span> ptr == <span class="hljs-number">0</span>: root = self.rotateLL(stack[ptr])<br>                    <span class="hljs-keyword">else</span>: <br>                        <span class="hljs-keyword">if</span> stack[ptr-<span class="hljs-number">1</span>].left == stack[ptr]: stack[ptr-<span class="hljs-number">1</span>].left = self.rotateLL(stack[ptr])<br>                        <span class="hljs-keyword">else</span>: stack[ptr-<span class="hljs-number">1</span>].right = self.rotateLL(stack[ptr])<br>                <span class="hljs-keyword">elif</span> stack[ptr].left == stack[ptr+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> stack[ptr+<span class="hljs-number">1</span>].right == stack[ptr+<span class="hljs-number">2</span>]:<br>                    <span class="hljs-keyword">if</span> ptr == <span class="hljs-number">0</span>: root = self.rotateLR(stack[ptr])<br>                    <span class="hljs-keyword">else</span>: <br>                        <span class="hljs-keyword">if</span> stack[ptr-<span class="hljs-number">1</span>].left == stack[ptr]: stack[ptr-<span class="hljs-number">1</span>].left = self.rotateLR(stack[ptr])<br>                        <span class="hljs-keyword">else</span>: stack[ptr-<span class="hljs-number">1</span>].right = self.rotateLR(stack[ptr])<br>                <span class="hljs-keyword">elif</span> stack[ptr].right == stack[ptr+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> stack[ptr+<span class="hljs-number">1</span>].left == stack[ptr+<span class="hljs-number">2</span>]:<br>                    <span class="hljs-keyword">if</span> ptr == <span class="hljs-number">0</span>: root = self.rotateRL(stack[ptr])<br>                    <span class="hljs-keyword">else</span>: <br>                        <span class="hljs-keyword">if</span> stack[ptr-<span class="hljs-number">1</span>].left == stack[ptr]: stack[ptr-<span class="hljs-number">1</span>].left = self.rotateRL(stack[ptr])<br>                        <span class="hljs-keyword">else</span>: stack[ptr-<span class="hljs-number">1</span>].right = self.rotateRL(stack[ptr])<br>                <span class="hljs-keyword">elif</span> stack[ptr].right == stack[ptr+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> stack[ptr+<span class="hljs-number">1</span>].right == stack[ptr+<span class="hljs-number">2</span>]:<br>                    <span class="hljs-keyword">if</span> ptr == <span class="hljs-number">0</span>: root = self.rotateRR(stack[ptr])<br>                    <span class="hljs-keyword">else</span>: <br>                        <span class="hljs-keyword">if</span> stack[ptr-<span class="hljs-number">1</span>].left == stack[ptr]: stack[ptr-<span class="hljs-number">1</span>].left = self.rotateRR(stack[ptr])<br>                        <span class="hljs-keyword">else</span>: stack[ptr-<span class="hljs-number">1</span>].right = self.rotateRR(stack[ptr])<br>                <span class="hljs-keyword">break</span><br>            ptr -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> root<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotateLL</span>(<span class="hljs-params">self, ptr: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            a</span><br><span class="hljs-string">           / </span><br><span class="hljs-string">          b</span><br><span class="hljs-string">         /</span><br><span class="hljs-string">        c </span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        ptra, ptrb, ptrc = ptr, ptr.left, ptr.left.left<br>        ptra.left = ptrb.right<br>        ptrb.right = ptra<br>        <span class="hljs-keyword">return</span> ptrb<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotateLR</span>(<span class="hljs-params">self, ptr: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">          a</span><br><span class="hljs-string">         /</span><br><span class="hljs-string">        b</span><br><span class="hljs-string">         \</span><br><span class="hljs-string">          c </span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        ptra, ptrb, ptrc = ptr, ptr.left, ptr.left.right<br>        ptra.left = ptrc.right<br>        ptrb.right = ptrc.left<br>        ptrc.left = ptrb<br>        ptrc.right = ptra<br>        <span class="hljs-keyword">return</span> ptrc<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotateRL</span>(<span class="hljs-params">self, ptr: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        a</span><br><span class="hljs-string">         \</span><br><span class="hljs-string">          b</span><br><span class="hljs-string">         /</span><br><span class="hljs-string">        c</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        ptra, ptrb, ptrc = ptr, ptr.right, ptr.right.left<br>        ptra.right = ptrc.left<br>        ptrb.left = ptrc.right<br>        ptrc.left = ptra<br>        ptrc.right = ptrb<br>        <span class="hljs-keyword">return</span> ptrc<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotateRR</span>(<span class="hljs-params">self, ptr: <span class="hljs-type">Optional</span>[TreeNode]</span>) -&gt; <span class="hljs-type">Optional</span>[TreeNode]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        a</span><br><span class="hljs-string">         \</span><br><span class="hljs-string">          b</span><br><span class="hljs-string">           \</span><br><span class="hljs-string">            c</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        ptra, ptrb, ptrc = ptr, ptr.right, ptr.right.right<br>        ptra.right = ptrb.left<br>        ptrb.left = ptra<br>        <span class="hljs-keyword">return</span> ptrb<br>    <br></code></pre></td></tr></table></figure><p><font color=red>删除操作需要学习</font></p><h2 id="红黑树">红黑树</h2><blockquote><p><ahref="https://zhuanlan.zhihu.com/p/91960960">一文带你彻底读懂红黑树（附详细图解）- 知乎 (zhihu.com)</a></p></blockquote><p>红黑树的各个节点均满足如下的定义：</p><ol type="1"><li>一个节点的颜色是黑的或者是红的</li><li>红黑树的根节点是黑的</li><li>红黑树的叶子节点是黑的</li><li>红黑树的红色节点的子节点均是黑的</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Algo&amp;DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-图</title>
    <link href="/2023/05/31/Algo_and_DS/2023-05-24-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%9B%BE/"/>
    <url>/2023/05/31/Algo_and_DS/2023-05-24-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="图">图</h2><h3 id="dfs">DFS</h3><p>使用栈或递归进行深度优先搜索。</p><h3 id="bfs">BFS</h3><p>使用队列进行广度优先搜索。</p><h3 id="dijkstra">Dijkstra</h3><p>有向正权图单源最短路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">adjacencyMatrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], n: <span class="hljs-built_in">int</span>, start: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    dist = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    dist[k] = <span class="hljs-number">0</span><br>    q = collections.deque([start])<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q):<br>        i = q.pop()<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> adjacencyMatrix[i][j] != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> dist[j] &gt; dist[i] + adjacencyMatrix[i][j]:<br>                dist[j] = dist[i] + adjacencyMatrix[i][j]<br>                q.append(j)<br>    <span class="hljs-keyword">return</span> dist<br></code></pre></td></tr></table></figure><h3 id="floyd">Floyd</h3><p>有向正权图全体最短路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">floyd</span>(<span class="hljs-params">adjacencyMatrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> i != j <span class="hljs-keyword">and</span> i != k <span class="hljs-keyword">and</span> j != k:<br>                    adjacencyMatrix[i][j] = <span class="hljs-built_in">min</span>(adjacencyMatrix[i][j], adjacencyMatrix[i][k] + adjacencyMatrix[k][j])<br>    <span class="hljs-keyword">return</span> adjacencyMatrix<br></code></pre></td></tr></table></figure><h3 id="bellman-ford">Bellman-Ford</h3><p>有向负权图单源最短路径</p><p>本例未考虑存在负环的情况 # 需要进一步学习</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">BellmanFord</span>(<span class="hljs-params">adjacencyMatrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], n: <span class="hljs-built_in">int</span>, start: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    dist = [<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    dist[start] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> adjacencyMatrix[i][j] != <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>):<br>                    dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[i] + adjacencyMatrix[i][j])<br>    <span class="hljs-keyword">return</span> dist<br></code></pre></td></tr></table></figure><h3 id="拓扑排序">拓扑排序</h3><table><thead><tr class="header"><th>题目</th><th style="text-align: center;">230526</th></tr></thead><tbody><tr class="odd"><td>LC207. 课程表</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC210. 课程表 II</td><td style="text-align: center;">[x]</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">topologicalSort</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span>, prerequisites: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-comment"># prerequisites[0] requires prerequisites[1]</span><br>    inDegree = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num)]<br>    childs = [[] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num)]<br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> prerequisites:<br>        childs[j].append(i)<br>        inDegree[i] += <span class="hljs-number">1</span><br>    ret = []<br>    queue = collections.deque()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>        <span class="hljs-keyword">if</span> inDegree[i] == <span class="hljs-number">0</span>:<br>            queue.append(i)<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue):<br>        ptr = queue.popleft()<br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> childs[ptr]:<br>            inDegree[child] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> inDegree[child] == <span class="hljs-number">0</span>:<br>                queue.append(child)<br>        ret.append(ptr)<br>    <span class="hljs-keyword">return</span> ret <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ret) == num <span class="hljs-keyword">else</span> []<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Algo&amp;DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-单调栈</title>
    <link href="/2023/05/26/Algo_and_DS/2023-05-26-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2023/05/26/Algo_and_DS/2023-05-26-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="单调栈">单调栈</h3><p>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置。时间复杂度为O(n)。</p><p>重点是维护一个元素保持单调增或单调减的栈：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">monotonicStack</span>():<br>    elements= random()<br>    stack = [<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(elements)):<br>        <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> stack[-<span class="hljs-number">1</span>] &lt; elements[i]:<br>            <span class="hljs-comment"># visit the top elements in stack</span><br>            <span class="hljs-comment"># which are smaller(larger) than current element</span><br>            visit(stack.pop())<br>        stack.append(i)<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>题目</th><th style="text-align: center;">230524</th></tr></thead><tbody><tr class="odd"><td>LC739. 每日温度</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC496.下一个更大元素 I</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC503.下一个更大元素II</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC42. 接雨水</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC84. 柱状图中最大的矩形</td><td style="text-align: center;">[ ]</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Algo&amp;DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-排序算法</title>
    <link href="/2023/05/24/Algo_and_DS/2023-05-24-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/05/24/Algo_and_DS/2023-05-24-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="排序算法">排序算法</h3><h4 id="冒泡排序">冒泡排序</h4><p>时间复杂度O(n^2)</p><p>空间复杂度O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>, i, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[j] &lt; nums[j-<span class="hljs-number">1</span>]:<br>                nums[j], nums[j-<span class="hljs-number">1</span>] = nums[j-<span class="hljs-number">1</span>], nums[j]<br></code></pre></td></tr></table></figure><h3 id="插入排序">插入排序</h3><p>时间复杂度O(n^2)</p><p>空间复杂度O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>        j = i<br>        <span class="hljs-keyword">while</span> j &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[j] &lt; nums[j-<span class="hljs-number">1</span>]:<br>            nums[j], nums[j-<span class="hljs-number">1</span>] = nums[j-<span class="hljs-number">1</span>], nums[j]<br>            j -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="选择排序">选择排序</h3><p>时间复杂度O(n^2)</p><p>空间复杂度O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">selectionSort</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>        min_index = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[j] &lt; nums[min_index]:<br>                min_index = j<br>        nums[i], nums[min_index] = nums[min_index], nums[i]    <br></code></pre></td></tr></table></figure><h3 id="希尔排序">希尔排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">shellSort</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>    gap = <span class="hljs-built_in">len</span>(nums) // <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> gap:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(gap, <span class="hljs-built_in">len</span>(nums)):<br>            temp = nums[i]<br>            j = i<br>            <span class="hljs-keyword">while</span> j &gt;= gap <span class="hljs-keyword">and</span> temp &lt; nums[j - gap]:<br>                nums[j] = nums[j - gap]<br>                j -= gap<br>            nums[j] = temp<br>        gap //= <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="归并排序">归并排序</h3><p>平均时间复杂度：O(nlogn) 最佳时间复杂度：O(n)最差时间复杂度：O(nlogn) 空间复杂度：O(n) 排序方式：In-place稳定性：稳定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> nums<br>    mid = <span class="hljs-built_in">len</span>(nums) // <span class="hljs-number">2</span><br>    left, right = mergeSort(nums[:mid]), mergeSort(nums[mid:])<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left, right</span>):<br>        result = []<br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(left) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(right):<br>            <span class="hljs-keyword">if</span> left[i] &lt; right[j]:<br>                result.append(left[i])<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result.append(right[j])<br>                j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(left): result.extend(left[i:])<br>        <span class="hljs-keyword">if</span> j &lt; <span class="hljs-built_in">len</span>(right): result.extend(right[j:])<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> merge(left, right)<br></code></pre></td></tr></table></figure><h3 id="快速排序">快速排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], low: <span class="hljs-built_in">int</span>, high: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        pivot = nums[high]<br>        i = low - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(low, high):<br>            <span class="hljs-keyword">if</span> nums[j] &lt; pivot:<br>                i += <span class="hljs-number">1</span><br>                nums[i], nums[j] = nums[j], nums[i]<br>        nums[i+<span class="hljs-number">1</span>], nums[high] = nums[high], nums[i+<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sort</span>(<span class="hljs-params">nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], low: <span class="hljs-built_in">int</span>, high: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> low &lt; high:<br>            pi = partition(nums, low, high)<br>            sort(nums, low, pi-<span class="hljs-number">1</span>)<br>            sort(nums, pi+<span class="hljs-number">1</span>, high)<br><br>    sort(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="堆排序">堆排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Heap</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.heap = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getLeft</span>(<span class="hljs-params">self, i</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getRight</span>(<span class="hljs-params">self, i</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getParent</span>(<span class="hljs-params">self, i</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">self, heap</span>):<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> heap:<br>            self.heappush(item)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">heappush</span>(<span class="hljs-params">self, item</span>):<br>        self.heap.append(item)<br>        i = <span class="hljs-built_in">len</span>(self.heap) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span>:<br>            parent = self.getParent(i)<br>            <span class="hljs-keyword">if</span> self.cmp(self.heap[i], self.heap[parent]):<br>                self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i]<br>                i = parent<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">heappop</span>(<span class="hljs-params">self</span>):<br>        ret = self.heap[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.heap) &lt;= <span class="hljs-number">1</span>:<br>            self.heap.pop()<br>            <span class="hljs-keyword">return</span> ret<br>        self.heap[<span class="hljs-number">0</span>] = self.heap.pop()<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(self.heap):<br>            left = self.getLeft(i)<br>            right = self.getRight(i)<br>            <span class="hljs-keyword">if</span> left &lt; <span class="hljs-built_in">len</span>(self.heap) \<br>                <span class="hljs-keyword">and</span> right &lt; <span class="hljs-built_in">len</span>(self.heap) \<br>                <span class="hljs-keyword">and</span> self.cmp(self.heap[left], self.heap[i]) \<br>                <span class="hljs-keyword">and</span> self.cmp(self.heap[right], self.heap[i]):<br>                <span class="hljs-keyword">if</span> self.cmp(self.heap[left], self.heap[right]):<br>                    right = <span class="hljs-built_in">len</span>(self.heap)<br>                <span class="hljs-keyword">else</span>:<br>                    left = <span class="hljs-built_in">len</span>(self.heap)<br>            <span class="hljs-keyword">if</span> left &lt; <span class="hljs-built_in">len</span>(self.heap) <span class="hljs-keyword">and</span> self.cmp(self.heap[left], self.heap[i]):<br>                self.heap[left], self.heap[i] = self.heap[i], self.heap[left]<br>                i = left<br>            <span class="hljs-keyword">elif</span> right &lt; <span class="hljs-built_in">len</span>(self.heap) <span class="hljs-keyword">and</span> self.cmp(self.heap[right], self.heap[i]):<br>                self.heap[right], self.heap[i] = self.heap[i], self.heap[right]<br>                i = right<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Algo&amp;DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-堆与优先队列</title>
    <link href="/2023/05/24/Algo_and_DS/2023-05-24-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2023/05/24/Algo_and_DS/2023-05-24-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="堆">堆</h2><p>堆，或是优先队列是一种一直维护内部单调性的结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Element</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, priority, value</span>):<br>        self.priority = priority<br>        self.value = value<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-comment"># Customize the less-than comparison based on priority</span><br>        <span class="hljs-comment"># Large-root</span><br>        <span class="hljs-keyword">return</span> self.priority &gt; other.priority<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Priority:<span class="hljs-subst">&#123;self.priority&#125;</span> Value:<span class="hljs-subst">&#123;self.value&#125;</span>&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__str__()<br><br><span class="hljs-comment"># Create an empty heap</span><br>heap = [<br>    Element(priority=<span class="hljs-number">3</span>, value=<span class="hljs-number">1</span>),<br>    Element(priority=<span class="hljs-number">1</span>, value=<span class="hljs-number">3</span>),<br>    Element(priority=<span class="hljs-number">2</span>, value=<span class="hljs-number">5</span>),<br>    Element(priority=<span class="hljs-number">5</span>, value=<span class="hljs-number">7</span>),<br>]<br><br>heapq.heapify(heap)<br>heapq.heappush(heap, Element(priority=<span class="hljs-number">4</span>, value=<span class="hljs-number">9</span>))<br>heapq.heappop(heap)<br></code></pre></td></tr></table></figure><p>予以实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Heap</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.storage = []<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.storage)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_left_child</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>):<br>        idx = (x &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> idx <span class="hljs-keyword">if</span> idx &lt; <span class="hljs-built_in">len</span>(self.storage) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>            <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_right_child</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>):<br>        idx = (x &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> idx <span class="hljs-keyword">if</span> idx &lt; <span class="hljs-built_in">len</span>(self.storage) <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_parent</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>):<br>        <span class="hljs-keyword">if</span> x == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        idx = (x - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= idx &lt; <span class="hljs-built_in">len</span>(self.storage):<br>            <span class="hljs-keyword">return</span> idx<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_swap</span>(<span class="hljs-params">self, x, y</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-number">0</span> &lt;= x &lt; <span class="hljs-built_in">len</span>(self.storage): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-number">0</span> &lt;= y &lt; <span class="hljs-built_in">len</span>(self.storage): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        self.storage[x], self.storage[y] = self.storage[y], self.storage[x]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">heappop</span>(<span class="hljs-params">self</span>):<br>        val = self.storage[<span class="hljs-number">0</span>]<br>        last_idx = <span class="hljs-built_in">len</span>(self.storage) - <span class="hljs-number">1</span><br>        self._swap(<span class="hljs-number">0</span>, last_idx)<br>        self.storage.pop()<br><br>        idx = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> idx <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            left = self._left_child(idx)<br>            right = self._right_child(idx)<br><br>            <span class="hljs-keyword">if</span> left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                idx_next = left <span class="hljs-keyword">if</span> self.comp(left, right) <span class="hljs-keyword">else</span> right<br><br>            <span class="hljs-keyword">elif</span> left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                idx_next = left<br>            <span class="hljs-keyword">elif</span> right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                idx_next = right<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br><br>            <span class="hljs-keyword">if</span> self.comp(idx_next, idx):<br>                self._swap(idx, idx_next)<br>                idx = idx_next<br>            <span class="hljs-keyword">else</span>:<br>                idx = <span class="hljs-literal">None</span><br><br>        <span class="hljs-keyword">return</span> val<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">heappush</span>(<span class="hljs-params">self, item</span>):<br>        self.storage.append(item)<br>        idx = <span class="hljs-built_in">len</span>(self.storage) - <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">while</span> idx <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            parent = self._parent(idx)<br>            <span class="hljs-keyword">if</span> parent <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> self.comp(idx, parent):<br>                self._swap(parent, idx)<br>                idx = parent<br>            <span class="hljs-keyword">else</span>:<br>                idx = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">comp</span>(<span class="hljs-params">self, x, y</span>):<br>        <span class="hljs-keyword">return</span> self.storage[x] &lt; self.storage[y]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print</span>(<span class="hljs-params">self</span>):<br>        cache = self.storage[:]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;State: &quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-keyword">while</span> self:<br>            <span class="hljs-built_in">print</span>(self.heappop(), end=<span class="hljs-string">&quot;  &quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>)<br>        self.storage = cache<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Algo&amp;DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-并查集</title>
    <link href="/2023/05/24/Algo_and_DS/2023-05-24-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/05/24/Algo_and_DS/2023-05-24-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="并查集">并查集</h3><p>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置。时间复杂度为O(n)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>):<br>        self.parent = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(n))<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">self, p</span>):<br>        <span class="hljs-keyword">while</span> p != self.parent[p]:<br>            p = self.parent[p]<br>        <span class="hljs-keyword">return</span> p<br><br>    <span class="hljs-comment"># vanilla union</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">self, pa, pb</span>):<br>        pa = self.find(pa)<br>        pb = self.find(pb)<br>        <span class="hljs-keyword">if</span> pa == pb: <br>            <span class="hljs-comment"># they are of the same parent</span><br>            <span class="hljs-comment"># there might be a circle</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>       self.parent[pa] = pb<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th>题目</th><th style="text-align: center;">230526</th></tr></thead><tbody><tr class="odd"><td>LC684. 冗余连接</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC685.冗余连接II</td><td style="text-align: center;">[ ]</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Algo&amp;DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-动态规划</title>
    <link href="/2023/05/04/Algo_and_DS/2023-05-04-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/05/04/Algo_and_DS/2023-05-04-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h3 id="动态规划">动态规划</h3><p>动态规划存在一个状态转移方程，当前的状态必然从过往的状态依据这个状态转移方程得来。</p><table><thead><tr class="header"><th>题目</th><th style="text-align: center;">230401</th></tr></thead><tbody><tr class="odd"><td>LC509. 斐波那契数</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC70. 爬楼梯</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC746. 使用最小花费爬楼梯</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC62. 不同路径</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC63. 不同路径 II</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC343. 整数拆分</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td>LC96. 不同的二叉搜索树</td><td style="text-align: center;">[x]</td></tr></tbody></table><h3 id="背包问题">背包问题</h3><h4 id="背包问题-1">01背包问题</h4><table><thead><tr class="header"><th>题目</th><th style="text-align: center;">230407</th></tr></thead><tbody><tr class="odd"><td>LC416. 分割等和子集</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC1049. 最后一块石头的重量II</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC494. 目标和</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC474. 一和零</td><td style="text-align: center;">[x]</td></tr></tbody></table><p>每个背包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backpack_01_2dim</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, capacity: <span class="hljs-built_in">int</span>, cost: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], value: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># dp[capacity+1][n_cost+1]</span><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(capacity+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, capacity + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> cost[i-<span class="hljs-number">1</span>] &lt;= j:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-cost[i-<span class="hljs-number">1</span>]] + value[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backpack_01_1dim</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, capacity: <span class="hljs-built_in">int</span>, cost: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], value: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># dp[i][*] only depends on previous dp[i-1][*]</span><br>        <span class="hljs-comment"># write over itself</span><br>        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(capacity+<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(capacity, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> cost[i-<span class="hljs-number">1</span>] &lt;= j:<br>                    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-cost[i-<span class="hljs-number">1</span>]] + value[i-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backpack_01_1dim_minimal</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, capacity: <span class="hljs-built_in">int</span>, cost: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], value: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># if clause merges with for-clause</span><br>        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(capacity+<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(capacity, cost[i-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-cost[i-<span class="hljs-number">1</span>]] + value[i-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="完全背包">完全背包</h4><table><thead><tr class="header"><th>题目</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td>LC518. 零钱兑换II</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC377. 组合总和 Ⅳ</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC70. 爬楼梯</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC322. 零钱兑换</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC279. 完全平方数</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC39.单词拆分</td><td style="text-align: center;">[ ]</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backpack_all_2dim</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, capacity: <span class="hljs-built_in">int</span>, cost: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], value: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(capacity+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, capacity + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> j &gt;= cost[i-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-cost[i-<span class="hljs-number">1</span>]] + value[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backpack_all_1dim</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, capacity: <span class="hljs-built_in">int</span>, cost: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], value: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(capacity+<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-comment"># Note here</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, capacity + <span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> j &gt;= cost[i]:<br>                    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-cost[i]] + value[i])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backpack_all_1dim_minimal</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, capacity: <span class="hljs-built_in">int</span>, cost: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], value: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>):<br>        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(capacity+<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cost[i], capacity + <span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-cost[i]] + value[i])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="多重背包问题">多重背包问题</h4><p>每个物品可以使用的次数不同。将可以使用N次的物品变成N个使用1次的物品，转换为01背包问题。</p><h4 id="其他动态规划问题">其他动态规划问题</h4><table><thead><tr class="header"><th>题目</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td>LC198.打家劫舍</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td>LC213.打家劫舍II</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC337.打家劫舍 III</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC121. 买卖股票的最佳时机</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC122.买卖股票的最佳时机II</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC123.买卖股票的最佳时机III</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC188.买卖股票的最佳时机IV</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC309.最佳买卖股票时机含冷冻期</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC714.买卖股票的最佳时机含手续费</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC300.最长递增子序列</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC674. 最长连续递增序列</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC718. 最长重复子数组</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC1143.最长公共子序列</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC1035.不相交的线</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC53. 最大子序和</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC392.判断子序列</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC115.不同的子序列</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC583. 两个字符串的删除操作</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC72. 编辑距离</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td>LC647. 回文子串</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td>LC516.最长回文子序列</td><td style="text-align: center;">[ ]</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Algo&amp;DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-贪心</title>
    <link href="/2023/03/27/Algo_and_DS/2023-03-27-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E8%B4%AA%E5%BF%83/"/>
    <url>/2023/03/27/Algo_and_DS/2023-03-27-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E8%B4%AA%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h3 id="贪心算法">贪心算法</h3><p>贪心的精髓，在于局部最优解一定是全局最优解。存在某种策略，可以把局部最优解推导到全局最优解。</p><p>存在两个维度的时候，尽量一个一个维度考虑。如两个维度先排序一个维度，或者分别考虑两个维度的解后结合得到最后的解。</p><table><thead><tr class="header"><th style="text-align: left;">题目</th><th style="text-align: center;">230327</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">LC455. 分发饼干</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td style="text-align: left;">LC376. 摆动序列</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td style="text-align: left;">LC53. 最大子数组和</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td style="text-align: left;">LC122. 买卖股票的最佳时机 II</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td style="text-align: left;">LC55. 跳跃游戏</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td style="text-align: left;">LC45. 跳跃游戏II</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td style="text-align: left;">LC1005. K次取反后最大化的数组和</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td style="text-align: left;">LC134. 加油站</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td style="text-align: left;">LC135. 分发糖果</td><td style="text-align: center;">[ ]</td></tr><tr class="even"><td style="text-align: left;">LC860. 柠檬水找零</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td style="text-align: left;">LC406. 根据身高重建队列</td><td style="text-align: center;">[]</td></tr><tr class="even"><td style="text-align: left;">LC452. 用最少数量的箭引爆气球</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td style="text-align: left;">LC435. 无重叠区间</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td style="text-align: left;">LC763. 划分字母区间</td><td style="text-align: center;">[x]</td></tr><tr class="odd"><td style="text-align: left;">LC56. 合并区间</td><td style="text-align: center;">[x]</td></tr><tr class="even"><td style="text-align: left;">LC738. 单调递增的数字</td><td style="text-align: center;">[ ]</td></tr><tr class="odd"><td style="text-align: left;">LC968. 监控二叉树</td><td style="text-align: center;">[x]</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Algo&amp;DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录-数组</title>
    <link href="/2023/03/22/Algo_and_DS/2023-03-22-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%95%B0%E7%BB%84/"/>
    <url>/2023/03/22/Algo_and_DS/2023-03-22-%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找">二分查找</h2><h3 id="基础leetcode704.-二分查找">基础（Leetcode704. 二分查找）</h3><p>最基本的二分查找：找到值返回下标，没有找到返回-1</p><p>基本原则，已经验证过的m，不再在新的子问题区间中出现。搜索结束的区间条件是区间内不含有值，只可能因为i,j据m更新索引导致。</p><ul><li><p>左闭右开区间[i,j)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-comment"># [i, j) | [i, j-1]  </span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            m = (i + j) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[m] == target:<br>                <span class="hljs-keyword">return</span> m<br>            <span class="hljs-keyword">elif</span> nums[m] &gt;  target:<br>                j = m<br>            <span class="hljs-keyword">else</span>:<br>                i = m + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>闭区间[i,j]</p></li><li><p>开区间(i,j)</p></li></ul><h3id="查找插入值位置leetcode35.-搜索插入位置">查找插入值位置（Leetcode35.搜索插入位置）</h3><p>若存在该值，返回第一个出现的该值的索引；若不存在该值，则返回的是大于该值的第一个下标索引。</p><p>也就是返回有序数组中第一个大于等于改值的索引。</p><p>e.g.: searchInsert([5, 7, 7, 8, 8, 10], 8),以闭区间为例（下划线为区间索引，删除线为m）</p><p>[<u>5i</u>, 7, <del>7</del>, 8, 8, <u>10j</u>]取得位于中间的值，待搜索的值[3]在右半区间</p><p>[5, 7, 7, <u>8i</u>, <del>8</del>, <u>10j</u>]取得位于中间的值等于target，右半区间必然全大于等于target，搜索左半区间</p><p>[5, 7, 7, <u><del>8</del>ij</u>, 8, 10] 搜索区间下标重合于[3]</p><p>[5, 7, <u>7j</u>, <u>8i</u>, 8, 10] 搜索区间下标反序，退出循环</p><p><strong>循环不变量</strong>（闭区间为例）：</p><p>i-1==j指向的必然是小于target的最后一个值</p><p>j+1==i指向的必然是大于等于target的第一个值</p><ul><li><p>若是左闭右开区间</p><p>i-1==j-1指向的必然是小于target的最后一个值</p><p>j==i指向的必然是大于等于target的第一个值</p></li><li><p>若是开区间</p><p>i==j-1指向的必然是小于target的最后一个值</p><p>j==i+1指向的必然是大于等于target的第一个值</p></li></ul><p>循环不变量在不同区间定义下的关系与包含端点的情况有关：</p><ul><li>左闭右开区间和闭区间的左端点定义一致，i表示的循环不变量一致</li><li>左闭右开区间和开区间的右端点定义一致，j表示的循环不变量一致</li></ul><p>闭区间写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-comment"># [i, j]</span><br>        <span class="hljs-keyword">while</span> i &lt;= j:<br>            m = (i + j) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[m] &lt; target:<br>                i = m + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># first one must be on the left-half side</span><br>                <span class="hljs-comment"># move to left if it is equal to target</span><br>                j = m - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> i<br></code></pre></td></tr></table></figure><p>类似的，有左闭右开区间的写法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-comment"># [i, j)</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            m = (i + j) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[m] &lt; target:<br>                i = m + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                j = m<br>        <span class="hljs-keyword">return</span> j<br></code></pre></td></tr></table></figure><p>和开区间的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchInsert</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        i, j = -<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-comment"># (i, j)</span><br>        <span class="hljs-keyword">while</span> j - i &gt; <span class="hljs-number">1</span>:<br>            m = (i + j) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[m] &lt; target:<br>                i = m<br>            <span class="hljs-keyword">else</span>:<br>                j = m<br>        <span class="hljs-comment"># or return j </span><br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>本题是搜索<strong>大于等于</strong>target的情况，在整数范围内其他大小关系可以相互转换：</p><p>大于target == 大于等于target+1</p><p>小于target == （大于等于target）-1 结果左侧的数</p><p>小于等于target == （大于等于target+1）-1</p><p>类似地，如果遇到相同值搜索右半区间，则可以检索最后一个出现的位置。</p><p>Leetcode. {34, 69}</p><h3 id="快慢指针-leetcode27.-移除元素">快慢指针 (Leetcode27.移除元素)</h3><p>在一个数组中原地将不等于val的元素移到数组头，返回长度。</p><p>快指针判断是否需要移除，不移除的元素复制到慢指针处。</p><p>Leetcode. {26, 283, <u>844</u>, 977, 80}</p><h3 id="双指针法leetcode977.-有序数组的平方">双指针法（Leetcode977.有序数组的平方）</h3><p>快慢指针是一种双指针法</p><h3 id="滑动窗口leetcode209.-长度最小的子数组">滑动窗口（Leetcode209.长度最小的子数组）</h3><p>滑动窗口可以视作一种双指针法</p><p>Leetcode. {904, 76}</p><h3 id="模拟leetcode59.-螺旋矩阵ii">模拟（Leetcode59. 螺旋矩阵II）</h3><p>Leetcode. {54}</p>]]></content>
    
    
    
    <tags>
      
      <tag>Algo&amp;DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制子集枚举</title>
    <link href="/2023/03/04/Algo_and_DS/2023-03-04-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E9%9B%86%E5%90%88%E6%9E%9A%E4%B8%BE/"/>
    <url>/2023/03/04/Algo_and_DS/2023-03-04-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E9%9B%86%E5%90%88%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<p>二进制子集枚举指的是对于一个给定的二进制串，枚举出其对于1比特位的子集。其子集内的二进制串，在为1的二进制位上，对应原二进制串也必须为1.</p><p>例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>b0011_1101_0001<br><span class="hljs-attribute">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>b0011_1001_0000<br><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>b0000_0101_0001<br><span class="hljs-attribute">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>b0000_0000_0000<br><span class="hljs-attribute">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>b0111_1101_0001<br></code></pre></td></tr></table></figure><p>此处，b、c、d均符合定义，属于子集。而e不符合，不属于。</p><p>使用以下算法实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>ret = []<br>    sub = num<br>    <span class="hljs-keyword">while</span> sub != <span class="hljs-number">0</span>:<br>        sub = (sub - <span class="hljs-number">1</span>) &amp; num<br>        ret.append(sub)<br>   <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Algo&amp;DS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Optuna - An automatic hyperparameter optimiser</title>
    <link href="/2023/02/27/2023-02-27-Optuna%20-%20An%20automatic%20hyperparameter%20optimiser/"/>
    <url>/2023/02/27/2023-02-27-Optuna%20-%20An%20automatic%20hyperparameter%20optimiser/</url>
    
    <content type="html"><![CDATA[<p>This is an introduction to python library optuna.</p><p>Optuna is an automatic hyperparameter optimiser. It can automaticallysearch for a set of hyperparameters that optimise the given evaluation,including maximising accuracy, minimising loss, et cetera.</p><h2 id="create-study">1. Create study</h2><p>First, optuna creates a study, which consists of multiple trials, todo optimisation. Each trial returns a value of the customisedevaluation. Optuna uses a sqlite database to store trialsinformation.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">study = optuna.create_study(direction=<span class="hljs-string">&quot;maximize&quot;</span>, storage=<span class="hljs-string">&#x27;sqlite:///optuna.db&#x27;</span>)<br>study.optimize(objective, n_trials=n_trials, timeout=timeout)<br></code></pre></td></tr></table></figure><h2 id="define-objective">2. Define objective</h2><p>Objective function is a function that takes parameters suggested byoptuna and returns evaluations per step. In this functions,hyperparameters are set in accordance with optuna's suggestions viavarious suggesting functions, which return hyperparameters suggestionunder different random distributions.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">objective</span>(<span class="hljs-params">trial:optuna.trial.Trial</span>):<br>    trial.set_user_attr(<span class="hljs-string">&#x27;seed&#x27;</span>, seed)<br>    lr = trial.suggest_float(<span class="hljs-string">&quot;lr&quot;</span>, <span class="hljs-number">1e-5</span>, <span class="hljs-number">1e-1</span>, log=<span class="hljs-literal">True</span>)<br>    para_0 = trial.suggest_float(<span class="hljs-string">&#x27;para_0&#x27;</span>, low=<span class="hljs-number">0.05</span>, high=<span class="hljs-number">0.95</span>, step=<span class="hljs-number">0.05</span>)<br>    para_1 = trial.suggest_int(<span class="hljs-string">&#x27;para_1&#x27;</span>, low=<span class="hljs-number">1</span>, high=<span class="hljs-number">16</span>)<br>    <span class="hljs-comment"># Do some training</span><br>    trial.report(evalutaion_metric, epoch_step)<br>    <span class="hljs-comment"># Handle pruning based on the intermediate value.</span><br>    <span class="hljs-keyword">if</span> trial.should_prune():<br>        <span class="hljs-keyword">raise</span> optuna.exceptions.TrialPruned()<br></code></pre></td></tr></table></figure><h2 id="get-study-result">3. Get study result</h2><p>Here, study is completed by optuna, and a final report, includingbest trial information and other info, is generated.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">pruned_trials = study.get_trials(deepcopy=<span class="hljs-literal">False</span>, states=[TrialState.PRUNED])<br>complete_trials = study.get_trials(deepcopy=<span class="hljs-literal">False</span>, states=[TrialState.COMPLETE])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Study statistics: &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Number of finished trials: &quot;</span>, <span class="hljs-built_in">len</span>(study.trials))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Number of pruned trials: &quot;</span>, <span class="hljs-built_in">len</span>(pruned_trials))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Number of complete trials: &quot;</span>, <span class="hljs-built_in">len</span>(complete_trials))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Best trial:&quot;</span>)<br>trial = study.best_trial<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Value: &quot;</span>, trial.value)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  Params: &quot;</span>)<br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> trial.params.items():<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;    &#123;&#125;: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(key, value))<br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> trial.user_attrs.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;    &#123;&#125;: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(key, value))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Introduction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wandb - A deep learning logging monitor</title>
    <link href="/2023/02/27/2023-02-27-Wandb%20-%20A%20deep%20learning%20logging%20monitor/"/>
    <url>/2023/02/27/2023-02-27-Wandb%20-%20A%20deep%20learning%20logging%20monitor/</url>
    
    <content type="html"><![CDATA[<p>Wandb is a logging monitor that can be used to track all deeplearning experiment performance.</p><h2 id="create-runtime">1. Create runtime</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">wandb.init(<br>    <span class="hljs-comment"># set the wandb project where this run will be logged</span><br>    project=<span class="hljs-string">&quot;project_name&quot;</span>,<br>    name=<span class="hljs-string">&quot;run_name&quot;</span>,<br>    config=&#123;<br>        <span class="hljs-comment"># hyper_parameter dict and run metadata</span><br>        <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">0.02</span>,<br>        <span class="hljs-string">&quot;architecture&quot;</span>: <span class="hljs-string">&quot;CNN&quot;</span>,<br>        <span class="hljs-string">&quot;dataset&quot;</span>: <span class="hljs-string">&quot;CIFAR-100&quot;</span>,<br>        <span class="hljs-string">&quot;epochs&quot;</span>: <span class="hljs-number">10</span>,<br>    &#125;,<br>    <span class="hljs-comment"># save main script</span><br>    save_code=<span class="hljs-literal">True</span>,<br>    tags=[<span class="hljs-string">&quot;tag0&quot;</span>, <span class="hljs-string">&quot;tag1&quot;</span>],<br>    notes=<span class="hljs-string">&quot;note&quot;</span>,<br>    <span class="hljs-comment"># others seen in source code comment</span><br>)<br></code></pre></td></tr></table></figure><h2 id="tracking">2. Tracking</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">wandb.log(<br>    data=&#123;<br>    <span class="hljs-string">&quot;metric0&quot;</span>: metric0,<br>    <span class="hljs-string">&quot;metric1&quot;</span>: metric1,<br>&#125;,<br>    step=epoch_step,<br>)<br><br>wandb.alert(<br>    title=<span class="hljs-string">f&quot;My alert<span class="hljs-subst">&#123;epoch&#125;</span>&quot;</span>, <br>    text=<span class="hljs-string">f&quot;Haha<span class="hljs-subst">&#123;epoch&#125;</span>&quot;</span>, <br>    level=<span class="hljs-type">Optional</span>[<br>        wandb.AlertLevel.INFO, <br>        wandb.AlertLevel.WARN, <br>        wandb.AlertLevel.ERROR<br>    ],<br>    wait_duration=cooldown_sec_for_same_title<br>)<br></code></pre></td></tr></table></figure><h2 id="finish-a-runtime">3. Finish a runtime</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">wandb.finish()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Introduction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH and Git Authentication Configuration</title>
    <link href="/2022/11/22/2022-11-22-SSH%20and%20Git%20Authentication%20Configuration/"/>
    <url>/2022/11/22/2022-11-22-SSH%20and%20Git%20Authentication%20Configuration/</url>
    
    <content type="html"><![CDATA[<p>This is a guide to set up SSH and Git (especially Github) access.</p><h2 id="generate-ssh-key-pair">1. Generate SSH key pair</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Or with an optional flag -C &quot;email_address&quot;</span><br>ssh-keygen<br></code></pre></td></tr></table></figure><p>This will generate a pair of keys (private and public) to given filename. Usually <code>id_rsa</code> and <code>id_rsa.pub</code>, but youcan choose your own file name.</p><h2 id="ssh-with-identity-file">2. SSH with Identity File</h2><p>Put the public key <code>id_rsa.pub</code> into <code>~/.ssh</code>and add it into <code>authorized_keys</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> id_rsa.pub &gt; authorized_keys<br></code></pre></td></tr></table></figure><p>And the client should be able to use the private key to get SSHaccess.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh user@host -p port -i identity_file<br></code></pre></td></tr></table></figure><p>Or further configure the SSH config file in <code>~/.ssh</code> onclient side to make it default.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host A-Label-To-Identify-Host<br>  HostName Host-Name-Or-IP<br>  User User-Name<br>  Port Port-Number<br>  IdentityFile Path-To-Identity-File<br></code></pre></td></tr></table></figure><p>Now you can gain access without password, or with a shorter commandas follow:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh A-Label-To-Identify-Host<br></code></pre></td></tr></table></figure><h2 id="github-with-identity-file">3. Github with Identity File</h2><p>Copy the public key to Github Setting &gt; SSH and GPG Keys &gt; SSHkeys &gt; New SSH Key</p><p>And test your key pair use following command</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># if you didn&#x27;t chaneg identity file name and path during generation </span><br><span class="hljs-comment"># -i will not be needed</span><br>ssh -T git@github.com -i identity_file<br></code></pre></td></tr></table></figure><p>If you want to add multiple SSH key pairs on identical Git site, thenedit <code>~/.ssh/config</code> as follow:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host Another-Identifier<br>  HostName Git-Site-Name-Like-github.com<br>  User git<br>  IdentityFile Path-To-Identity-File<br></code></pre></td></tr></table></figure><p>This key will be used when a local git Repo gets a remote addresswith a prefix like <code>git@Another-Identifier:</code></p><h2 id="github-with-token">4. Github with Token</h2><p>It is a rather dangerous and unsafe way to gain access.</p><p>Generate a token from Github Setting &gt; Developer settings &gt;Personal Access Tokens &gt; Tokens (classic).</p><p>Now you should gain Github access with remote as<code>https://oauth2:Your_Token_Here@github.com/User_Name/Repo_Name</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>Guide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dislocker - A Bitlock solution on Linux</title>
    <link href="/2022/11/21/2022-11-21-Dislocker%20-%20A%20Bitlock%20solution%20on%20Linux/"/>
    <url>/2022/11/21/2022-11-21-Dislocker%20-%20A%20Bitlock%20solution%20on%20Linux/</url>
    
    <content type="html"><![CDATA[<p>Dislocker is an command-line application on Linux platform to unlockany Bitlock drivers with password or recovery key.</p><p><a href="%5Bhttps://github.com/Aorimn/dislocker">Github Repo</a></p><h3 id="install">1. Install</h3><ol type="1"><li>Change working directory on your choice</li><li>Download Dislocker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/Aorimn/dislocker/archive/master.zip<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>Extract here</li><li>Install dependency</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install libfuse-dev<br>aptitude install gcc cmake make libfuse-dev libmbedtls-dev ruby-dev<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>Compile and install</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> dislocker<br>cmake .<br>make<br>sudo make install<br></code></pre></td></tr></table></figure><h3 id="decrypt-and-mount-unmount">2. Decrypt and Mount Unmount</h3><ol type="1"><li>Create folders</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> /media/bitlocker /media/mount<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>Determine which partition to use</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo fdisk -l<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>Launch Dislocker</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Using Bitlock password</span><br>sudo dislocker -r -V /dev/sdaX -uPASSWORD -- /media/bitlocker<br><span class="hljs-comment"># Using Bitlock recovery key</span><br>sudo dislocker -r -V /dev/sdaX –pYour-Bitlock-Recovery-Key -- /media/bitlocker<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>Mount the partition</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo -i<br><span class="hljs-built_in">cd</span> /media/bitlocker<br>mount -r -o loop dislocker-file /media/mount<br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><h3 id="unmount">3. Unmount</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br>sudo umount /media/mount<br>sudo fusermount -u /media/bitlocker -z<br><span class="hljs-comment"># Remove folder before check</span><br>sudo <span class="hljs-built_in">rm</span> /media/bitlocker /media/mount -r<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Guide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Multi-gate Mixture-of-Experts (MMoE)</title>
    <link href="/2022/10/07/2022-10-07-Multi-gate%20Mixture-of-Experts%20(MMoE)/"/>
    <url>/2022/10/07/2022-10-07-Multi-gate%20Mixture-of-Experts%20(MMoE)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Paper title: <ahref="https://dl.acm.org/doi/10.1145/3219819.3220007">Modeling TaskRelationships in Multi-task Learning with Multi-gateMixture-of-Experts</a></p></blockquote><h2 id="method">Method</h2><p>In contrast to normal MoE models, Multi-gate MoE(MMoE) uses severalgates to differentiate inter-task difference.</p><p>In traditional one-gate MoE models, all tasks use an identical gateto balance the output of each expert. <span class="math display">\[y=\sum_{i=1}^{n} g(x)_{i} f_{i}(x)\]</span> <span class="math inline">\(g(x)\)</span> is the output of thegate where x is the task input and <spanclass="math inline">\(g(x)_i\)</span> is a softmax-ed weight for expert<span class="math inline">\(i\)</span> and <spanclass="math inline">\(f_i(x)\)</span> is the output of one expert.</p><p>MMoE uses several gates, each of which specialise on one task.</p><p><imgsrc="/images/2022-10-07-Multi-gate%20Mixture-of-Experts%20(MMoE)/MMoE.png" /><span class="math display">\[\begin{align}&amp;y_{k}=h^{k}\left(f^{k}(x)\right)\\&amp;f^{k}(x)=\sum_{i=1} g^{k}(x)_{i} f_{i}(x)\\&amp;g^{k}(x)=\operatorname{softmax}\left(W_{g k} x\right)\end{align}\]</span> where <span class="math inline">\(W_{g k}x \in\mathbb{R}^{n\times d}\)</span> is a trainable matrix. <spanclass="math inline">\(n\)</span> is the number of experts and <spanclass="math inline">\(d\)</span> is the feature dimension.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Deep-Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Routing Networks for Multi-task Learning</title>
    <link href="/2022/10/04/2022-10-04-Routing%20Networks%20for%20Multi-task%20Learning/"/>
    <url>/2022/10/04/2022-10-04-Routing%20Networks%20for%20Multi-task%20Learning/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Paper title: <a href="https://arxiv.org/abs/1711.01239">RoutingNetworks: Adaptive Selection of Non-linear Functions for Multi-taskLearning</a></p></blockquote><h2 id="method">Method</h2><p>This paper adopt Reinforcement Learning (RL) to train routers to makeright decisions in routing tasks. The whole model is constituted offunction block sets and a router.</p><p><imgsrc="/images/2022-10-04-Routing%20Networks%20for%20Multi-task%20Learning/Routing.png" /></p><p>In the iteration of one training step, the input goes into routerfirst (perhaps with some task labels) to pick a function in function setfor this round.</p><p><imgsrc="/images/2022-10-04-Routing%20Networks%20for%20Multi-task%20Learning/Routing%20Algorithm.png" /></p><p>When the input passes the chosen function block, it goes back torouter to pick another function block again. This time router would pickanother function from another set.</p><p>Once all function set are visited, that is one step is fullycompleted, the backward propaganda toward functions and rewards towardrouter start. First, a loss function is applied on predicted value andground truth. The error is back propagated in a traditional way throughall selected function blocks and all learn-able parameters includingweights and biases in these blocks are updated. Then, for decision madeby router, a reinforcement learning training strategy is applied. Ifprediction is correct, action reward is set to +1, otherwise reward is-1.</p><p><imgsrc="/images/2022-10-04-Routing%20Networks%20for%20Multi-task%20Learning/Forward%20and%20Backward.png" /></p><p><imgsrc="/images/2022-10-04-Routing%20Networks%20for%20Multi-task%20Learning/Router%20Trainer.png" /></p><p>Multiple routing strategies have been tried out.</p><p><imgsrc="/images/2022-10-04-Routing%20Networks%20for%20Multi-task%20Learning/Task-based%20Routing.png" /></p><ul><li><p>Single RL agent strategy</p><p>Only one routing agent is trained and used. The router takes valueand task pair to make a routing decision.</p></li><li><p>Per-Task RL strategy</p><p>There exist several RL agents. And a non-trainable choice of routeris made upon task label token.</p></li><li><p>Dispatcher agent strategy</p><p>There is a specialised agent called Dispatcher, which only makedecision on which router this incoming pair should be re-directed to.It's like a secondary layer of routing network on original routing agentlayer.</p></li></ul><h2 id="rl-training-strategy">RL Training Strategy</h2><p>Skipped</p><blockquote><p>Will be updated soon (maybe...)</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Deep-Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Many Task Learning</title>
    <link href="/2022/10/02/2022-10-02-Many%20Task%20Learning/"/>
    <url>/2022/10/02/2022-10-02-Many%20Task%20Learning/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Paper title: <a href="https://arxiv.org/abs/1903.12117"><em>Many TaskLearning with Task Routing</em></a></p></blockquote><h2 id="introduction">Introduction</h2><p>Multi-Task Learning (MLT) is an approach to achieve several targetsin one model.</p><p>Many Task Learning is a special case on MTL where more than 20 tasksare learnt.</p><ul><li><p>Asymmetric MTL</p><p>There exists a main target task and several auxiliary tasks, whichare trained <strong>simultaneously</strong> to assist the main task withtheir learnt knowledge. It shares similarity with transferring learningthat is leveraging several trained models on other task to help onespecific task.</p></li><li><p>Symmetric MTL</p><p>All tasks have equivalent status in final evaluation.</p></li></ul><h2 id="task-routing">Task Routing</h2><h3 id="unit-role">Unit Role</h3><p>MaTL defines every unit in its model to be either task-specific orshared. It is determined by a pre-defined hyper-parameter <spanclass="math inline">\(\sigma\)</span>. <spanclass="math inline">\(\sigma=0\)</span> means that all units aretask-specific and all tasks will be performed with zero shard knowledge,while <span class="math inline">\(\sigma=1\)</span> means all units arefully shared. The role of each unit would be consistent throughouttraining and testing progress.</p><p><imgsrc="/images/2022-10-02-Many%20Task%20Learning/Unit%20Role.png" /></p><h3 id="task-routing-mask">Task Routing Mask</h3><p>Task routing is performed via feature-wise transformation inconvolutional layer. These non-learnable binary masks would be randomlygenerated and kept permanent during training and testing procedure. Toavoid influence upon running means and variances in normalisation, thetask routing mask is inserted after normalisation operation and beforeactivation function.</p><p><imgsrc="/images/2022-10-02-Many%20Task%20Learning/Task%20Mask.png" /> <spanclass="math display">\[TRL_{A}(X)=m_{A} \odot X\]</span> <imgsrc="/images/2022-10-02-Many%20Task%20Learning/Task%20Routing%20Layer.png" /></p><h2 id="training-procedure">Training Procedure</h2><p><imgsrc="/images/2022-10-02-Many%20Task%20Learning/Training%20Epoch.png" /></p><p><imgsrc="/images/2022-10-02-Many%20Task%20Learning/Forward%20Pass.png" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Deep-Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Switch Transformer</title>
    <link href="/2022/09/28/2022-09-28-Switch%20Transformer/"/>
    <url>/2022/09/28/2022-09-28-Switch%20Transformer/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Paper title: <a href="https://arxiv.org/abs/2101.03961"><em>SwitchTransformers: Scaling to Trillion Parameter Models with Simple andEfficient Sparsity</em></a></p><p>Video explanation: <ahref="https://www.youtube.com/watch?v=iAR8LkkMMIM">Switch Transformers:Scaling to Trillion Parameter Models with Simple and EfficientSparsity</a></p></blockquote><h2 id="abstract">0. Abstract</h2><p>Switch Transformer is a kind of sparse Transformer architectureinspired by MoE(Mixture of Experts). It is built with much larger amountof parameters (Trillion), while remain in the same time complexitylevel.</p><h2 id="introduction">1. Introduction</h2><p>It is a shallow intuition that, in current status, a larger modelalways comes with a better performance. Yet, a larger model intraditional way would inevitably brings larger computational cost, sinceparameters need to be calculated with input. In Switch Transformer, themodel has larger scale but remain the computational cost unchanged.</p><h2 id="architecture">2. Architecture</h2><p>Regular Transformer blocks constitute of Self-Attention layer,Add-Norm, Feed-Forward, Add-Norm in this very order. A view tounderstand this is that Self-Attention layer exploits inter-relationshipamong tokens (words) and Feed-Forward layer translates tokenrepresentation form one layer's to another's. The main problem here isthat despite word property vary, like nouns and verbs, whilerepresentation translating matrix, a.k.a Feed-Forward matrix remainsidentical. Switch Transformer introduces a MoE-like component, SwitchingFeed-Forward Layer.</p><p><imgsrc="/images/2022-09-28-Switch%20Transformer/Switching-Feed-Forward.png" /></p><p>A Switching Feed-Forward Layer consists of a Router and severaltraditional Feed-Forward blocks acting as experts in MoE. The routergives a probability distribution of which expert the incoming tokenshall be re-directed to.</p><p>Ideally, every token shall be re-directed to its the most favouredexperts. Yet, due to overflows, some experts get way more incomingtokens that others. Switch Transformer adopts No-Token-Left-BehindRouting Strategy to balance load across experts. Those un-re-directedtokens would be reviewed for a second time to be re-directed to thesecond most favoured expert.</p><p>No computer except super computer can hold this sort of super largemodule on one device. This paper also offer a plan to deploy with adistributed system.</p><p><imgsrc="/images/2022-09-28-Switch%20Transformer/Data-and-weight-partitioning-strategies.png" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Deep-Learning</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematic behind Diffusion Model</title>
    <link href="/2022/09/27/2022-09-27-Mathematic%20behind%20Diffusion%20Model/"/>
    <url>/2022/09/27/2022-09-27-Mathematic%20behind%20Diffusion%20Model/</url>
    
    <content type="html"><![CDATA[<p>This is a note for Diffusion Model Explanation Video by youtuber <ahref="https://www.youtube.com/channel/UCwA8PYIymQEXh7jwcrIUDHg"><em>Outlier</em></a>(09:33-24:21)</p><blockquote><p><strong><em>Reference</em></strong>:</p><p><a href="https://www.youtube.com/watch?v=HoKDTa5jHvg">DiffusionModels | Paper Explanation | Math Explained</a></p><p><a href="https://www.bilibili.com/video/BV1Et4y177w4">DiffusionModels 模型的数学解释</a></p></blockquote><h2 id="basic-intuition">1. Basic Intuition</h2><p>The diffusion model gradually add noise to a given image and try torecover that image in a reversed progress through a neural network.</p><p>In general the model could simply take a completely noised image togenerate original image by single step, but practice has proved it to beineffective. Step-by-step strategy has been proved to be a morerealistic and effective approach.</p><p>Here step-by-step strategy means the identical model takes a noisedimage and outputs a slightly de-noised image. Approaches to recoverimage from a noised one can be categorised into 3 classes:</p><ol type="1"><li><p>recover the whole image in one step</p></li><li><p>recover a slightly de-noised image step by step</p></li><li><p>predict the noise component in image step by step</p></li></ol><p>Substantially, approach 2 and approach 3 have the same effect, foronce noise component is calculated, one can recover a de-noised image bysubtract noise component from input.</p><h2 id="basic-notation">2. Basic Notation</h2><ul><li>Image</li></ul><p>Let <span class="math inline">\(x_t\)</span> be the image that beingperturbed for <span class="math inline">\(t\)</span> times. So <spanclass="math inline">\(x_0\)</span> is the original image and <spanclass="math inline">\(x_T\)</span> is the image when all perturbingprocedure is done, which follows a isotropic Gaussian distribution.<span class="math inline">\(T\)</span> is different across differentpapers. Initially it is set to <spanclass="math inline">\(1000\)</span>.</p><ul><li>Forward Process</li></ul><p>Let <span class="math inline">\(q\)</span> be a function thatdescribe the perturbing procedure step. It takes an image <spanclass="math inline">\(x_t\)</span> as input and output an image <spanclass="math inline">\(x_{t+1}\)</span> with more noise.</p><p><span class="math display">\[q(x_t|x_{t-1})\]</span></p><ul><li>Backward Process</li></ul><p>Similarly, Let <span class="math inline">\(p\)</span> be a de-nosingfunction, which outputs a de-noised image <spanclass="math inline">\(x_{t-1}\)</span> based on image <spanclass="math inline">\(x_{t}\)</span>. This part will be done throughdeep learning models.</p><p><span class="math display">\[p(x_{t-1}|x_t)\]</span></p><h2 id="forward-and-backward-process-deduction">3. Forward and BackwardProcess Deduction</h2><p>By assuming that noise is subjected to Gaussian distribution, wehave:</p><p><span class="math display">\[q(x_t|x_{t-1})=\mathcal{N}(x_t; \sqrt{1-\beta_t} x_{t-1}, \beta_tI)\tag{1}\]</span></p><p>where <span class="math inline">\(\mathcal{N}\)</span> denotes asnormal distribution. Output is denoted as <spanclass="math inline">\(x_{t-1}\)</span>. <spanclass="math inline">\(\beta_t\)</span> is a coefficient that controlsmean and variance of the distribution in each step. It is pre-set inaccordance with step <span class="math inline">\(t\)</span>.</p><p>In favour of formula deduction, we define two new coefficients <spanclass="math inline">\(\alpha_t\)</span> and <spanclass="math inline">\(\overline{\alpha_t}\)</span> as follow:</p><p><span class="math display">\[\alpha_t=1-\beta_t\\\overline{\alpha_t}=\prod_{i=1}^t{\alpha_i}\]</span></p><p>We use <span class="math inline">\((1)\)</span> to expand <spanclass="math inline">\(x_{t-1}\)</span> term in equation <spanclass="math inline">\((1)\)</span>:</p><p><span class="math display">\[\begin{aligned}q(x_t|x_{t-1})&amp;=\mathcal{N}(x_t; \sqrt{1-\beta_t} x_{t-1},\beta_tI)\\&amp;= \sqrt{1-\beta_t}x_{t-1}+\sqrt{\beta_t}\epsilon\\&amp;=\sqrt{1-\beta_t}(\sqrt{1-\beta_{t-1}}x_{t-2}+\sqrt{\beta_{t-1}}\epsilon)+\sqrt{\beta_t}\epsilon\\&amp;=\sqrt{\alpha_{t}}(\sqrt{\alpha_{t-1}}x_{t-2}+\sqrt{1-\alpha_{t-1}}\epsilon)+\sqrt{1-\alpha_{t}}\epsilon\\&amp;=\sqrt{\alpha_{t-1}\alpha_t}x_{t-2}+(\sqrt{\alpha_t-\alpha_{t-1}\alpha_t}+\sqrt{1-\alpha_t})\epsilon\end{aligned}\tag{2}\]</span></p><p>Here, we notice that two normal distribution is added. For normaldistribution addition, we have:</p><p><span class="math display">\[\mathcal{N}(\mu_0, \delta_0^2)+\mathcal{N}(\mu_1,\delta_1^2)=\mathcal{N}(\mu_0+\mu_1, \delta_0^2,+\delta_1^2)\]</span></p><p>So <span class="math inline">\((2)\)</span> equals:</p><p><span class="math display">\[\begin{aligned}x_t=q(x_t|x_{t-1})&amp;=\sqrt{\alpha_{t-1}\alpha_t}x_{t-2}+(\sqrt{\alpha_t-\alpha_{t-1}\alpha_t}+\sqrt{1-\alpha_t})\epsilon\\&amp;=\sqrt{\alpha_{t-1}\alpha_t}x_{t-2}+\sqrt{1-\alpha_{t-1}\alpha_t}\epsilon\\&amp; \text{recursive substitution}\\&amp;=\sqrt{\prod_{i=1}^t\alpha_i}x_0+\sqrt{1-\prod_{i=1}^t\alpha_i}\epsilon\\&amp;=\sqrt{\overline{\alpha_t}}x_0+\sqrt{1-\overline{\alpha_t}}\epsilon\end{aligned}\tag{2}\]</span></p><p>Likewise, <span class="math inline">\(p\)</span> can be definedas:</p><p><span class="math display">\[p(x_{t-1}|x_t)=\mathcal{N}(x_{x-1};\mu_\theta(x_t,t),\Sigma_\theta(x_t,t))\]</span></p><p>where <span class="math inline">\(\mu_{\theta}\)</span> is a neuralnetwork that predict mean, <spanclass="math inline">\(\Sigma_\theta\)</span> can be seen as a fixedparameter according to training schedule.</p><h2 id="loss-function">4. Loss Function</h2><p>Bear in mind that our final goal is to predict the noise component ineach step.</p><p>We use negative log likelihood as loss function to maximise theprobability to generate real image. <span class="math display">\[\text{Loss Function} = -log(p_{\theta}(x_0))\]</span> The probability of <spanclass="math inline">\(p_\theta(x_0)\)</span> is hard to calculate, sinceit is related with <span class="math inline">\(x_0, x_1, \cdots,x_T\)</span>. We have the following inequation instead. <spanclass="math display">\[\text{Loss Function} = -log(p_\theta(x_0)) \leq -log(p_\theta(x_0)) +D_{KL}(q(x_{1:T}|x_0)||p_\theta(x_{1:T}|x_0))\]</span></p><p>It is our goal to minimise the KL diversion between <spanclass="math inline">\(q\)</span> and <spanclass="math inline">\(p_\theta\)</span> since this diversion depict thedistance between results of two progresses. Once the goal is reached,the KL diversion is <span class="math inline">\(0\)</span>.</p><p>We expand KL diversion into <span class="math inline">\(log\)</span>form. <span class="math display">\[\begin{aligned}D_{KL}(q(x_{1: T}|x_{0}) || p_{\theta}(x_{1: T}|x_{0}))&amp;=log\frac{q(x_{1: T}|x_{0})}{p_{\theta}(x_{1: T} | x_{0})}\\&amp;=log\frac{q(x_{1: T}|x_{0})}{\frac{p_{\theta}(x_{0} x_{1: T})p_{\theta}(x_{1: T})}{p_{\theta}(x_{0})}}\\&amp;=log\frac{q(x_{1:T}|x_{0})}{\frac{p_\theta(x_0,x_{1:T})}{p_{\theta}(x_{0})}}\\&amp;=log\frac{q(x_{1:T}|x_{0})}{\frac{p_\theta(x_{0:T})}{p_{\theta}(x_{0})}}\\&amp;=log\frac{q(x_{1: T}|x_{0})}{p_{\theta}(x_{0: T})}+log(p_{\theta}(x_{0}))\end{aligned}\]</span> By expanding KL diversion term, the uncalculatable term isgone. The loss function remains as follow. <span class="math display">\[\text{Loss Function} \leq log\frac{q(x_{1: T}|x_{0})}{p_{\theta}(x_{0:T})}\tag{3}\]</span> The conditional probability can be expanded into serialproduct term as follow. <span class="math display">\[\begin{aligned}log\frac{q(x_{1: T}|x_{0})}{p_{\theta}(x_{0:T})}&amp;=log\frac{\prod_{i=1}^T{q(x_{i}|x_{i-1})}}{p_\theta(x_T)\prod_{i=1}^T{p_\theta(x_{i-1}|x_{i})}}\\&amp;=log\frac{\prod_{i=1}^T{q(x_{i}|x_{i-1})}}{\prod_{i=1}^T{p_\theta(x_{i-1}|x_{i})}}-log(p_\theta(x_T))\\&amp;=\sum_{i=1}^T(log(\frac{q(x_{i}|x_{i-1})}{p_\theta(x_{i-1}|x_{i})}))-log(p_\theta(x_T))\\&amp;=\sum_{i=2}^T(log(\frac{q(x_{i}|x_{i-1})}{p_\theta(x_{i-1}|x_{i})}))+\frac{q(x_{1}|x_{0})}{p_\theta(x_{0}|x_{1})}-log(p_\theta(x_T))\\&amp;=\sum_{i=2}^T(log(\frac{\frac{q(x_{t-1}|x_t)q(x_t)}{q(x_{t-1})}}{p_\theta(x_{i-1}|x_{i})}))+\frac{q(x_{1}|x_{0})}{p_\theta(x_{0}|x_{1})}-log(p_\theta(x_T))\\\end{aligned}\tag{4}\]</span> Focus on the first term in this equation, those probabilitywith <span class="math inline">\(q(x_{t-1}|x_{t})\)</span> is with highvariance, since its real meaning is that to generate <spanclass="math inline">\(t-1\)</span> from <spanclass="math inline">\(t\)</span> and when t is large, the image isnearly completely noised. It is highly impossible to recover imagecorrectly. A better way to deal with this issue is let it also conditionon <span class="math inline">\(x_0\)</span>. <spanclass="math display">\[\begin{aligned}log\frac{q(x_{1: T}|x_{0})}{p_{\theta}(x_{0:T})}&amp;=\sum_{i=2}^T(log(\frac{\frac{q(x_{t-1}|x_t)q(x_t)}{q(x_{t-1})}}{p_\theta(x_{i-1}|x_{i})}))+\frac{q(x_{1}|x_{0})}{p_\theta(x_{0}|x_{1})}-log(p_\theta(x_T))\\&amp;\Rightarrow\sum_{i=2}^T(log(\frac{\frac{q(x_{t-1}|x_t,x_0)q(x_t|x_0)}{q(x_{t-1}|x_0)}}{p_\theta(x_{i-1}|x_{i})}))+\frac{q(x_{1}|x_{0})}{p_\theta(x_{0}|x_{1})}-log(p_\theta(x_T))\\&amp;=\sum_{i=2}^T(log(\frac{q(x_{t-1}|x_t,x_0)q(x_t|x_0)}{q(x_{t-1}|x_0)p_\theta(x_{i-1}|x_{i})}))+\frac{q(x_{1}|x_{0})}{p_\theta(x_{0}|x_{1})}-log(p_\theta(x_T))\\&amp;=\sum_{i=2}^T(log(\frac{q(x_{t-1}|x_t,x_0)}{p_\theta(x_{i-1}|x_{i})}))+\sum_{i=2}^T{log(\frac{q(x_t|x_0)}{q(x_{t-1}|x_0)}})+\frac{q(x_{1}|x_{0})}{p_\theta(x_{0}|x_{1})}-log(p_\theta(x_T))\\&amp; \text{expand term 2 would cancel many term}\\&amp;=\sum_{i=2}^T(log(\frac{q(x_{t-1}|x_t,x_0)}{p_\theta(x_{i-1}|x_{i})}))+log(\frac{q(x_T|x_0)}{q(x_1|x_0)})+log(\frac{q(x_{1}|x_{0})}{p_\theta(x_{0}|x_{1})})-log(p_\theta(x_T))\\&amp;=\sum_{i=2}^T(log(\frac{q(x_{t-1}|x_t,x_0)}{p_\theta(x_{i-1}|x_{i})}))+log(\frac{q(x_T|x_0)}{p_\theta(x_{0}|x_{1})})-log(p_\theta(x_T))\\&amp;=\sum_{i=2}^T(log(\frac{q(x_{t-1}|x_t,x_0)}{p_\theta(x_{i-1}|x_{i})}))+log(q(x_T|x_0))-log(p_\theta(x_{0}|x_{1}))-log(p_\theta(x_T))\\&amp;=\sum_{i=2}^T(log(\frac{q(x_{t-1}|x_t,x_0)}{p_\theta(x_{i-1}|x_{i})}))+log(\frac{q(x_T|x_0)}{p_\theta(x_T)})-log(p_\theta(x_{0}|x_{1}))\\&amp;=\sum_{i=2}^T(log(\frac{q(x_{t-1}|x_t,x_0)}{p_\theta(x_{i-1}|x_{i})}))+D_{KL}(q(x_T|x_0)||p_\theta(x_T))-log(p_\theta(x_{0}|x_{1}))\\&amp;=\sum_{i=2}^T(D_{KL}(q(x_{t-1}|x_t,x_0)||p_\theta(x_{i-1}|x_{i})))+D_{KL}(q(x_T|x_0)||p_\theta(x_T))-log(p_\theta(x_{0}|x_{1}))\\\end{aligned}\]</span> The second term would approach to <spanclass="math inline">\(0\)</span> since it is the final goal to make<span class="math inline">\(q\)</span> fully recover the originalimage.</p><p>We then closely exam the first term: <span class="math display">\[\sum_{i=2}^T(D_{KL}(q(x_{t-1}|x_t,x_0)||p_\theta(x_{i-1}|x_{i})))\]</span> It depict distance between <spanclass="math inline">\(p_\theta\)</span> and <spanclass="math inline">\(q\)</span>.</p><p><span class="math inline">\(p_\theta\)</span> can be re-written intonormal distribution form. Since we have the variance fixed in accordancewith training schedule, we do not have to use model <spanclass="math inline">\(\theta\)</span> to predict it. <spanclass="math display">\[p_\theta(x_{i-1}|x_{i})=\mathcal{N}(x_{i-1};\mu_\theta(x_t, t),\delta)=\mathcal{N}(x_{i-1};\mu_\theta(x_t, t), \beta I)\]</span> <span class="math inline">\(q\)</span> can also be re-writteninto normal distribution form. <span class="math display">\[q(x_{t-1}|x_t,x_0)=\mathcal{N}(x_{t-1};\tilde{\mu}(x_t,x_0),\tilde{\beta}I)\]</span> Here, the coefficients <spanclass="math inline">\(\tilde{\mu}(x_t,x_0), \tilde{\beta}\)</span> arescheduled as follow. Similarly, <spanclass="math inline">\(\beta\)</span> is fixed. <spanclass="math display">\[\begin{aligned}\tilde{\mu}(x_t,x_0)&amp;=\frac{\sqrt{\alpha_{t}}(1-\overline{\alpha}_{t-1})}{1-\overline{\alpha}_{t}}x_{t}+\frac{\sqrt{\overline{\alpha}_{t-1}}\beta_{t}}{1-\overline{\alpha}_{t}} x_{0}\\\tilde{\beta}_{t}&amp;=\frac{1-\overline{\alpha}_{t-1}}{1-\overline{\alpha}_{t}}\cdot \beta_{t}\end{aligned}\]</span> For <span class="math inline">\(\tilde{\mu}\)</span>, wesubstitute <span class="math inline">\(x_0\)</span> with <spanclass="math inline">\((2)\)</span> in <spanclass="math inline">\(x_0\)</span>, then we have: <spanclass="math display">\[\begin{aligned}x_t&amp;=\sqrt{\overline{\alpha_t}}x_0+\sqrt{1-\overline{\alpha_t}}\epsilon\\\Rightarrowx_0&amp;=\frac{1}{\sqrt{\overline{\alpha_t}}}(x_t-\sqrt{1-\overline{\alpha_t}}\epsilon)\\\tilde{\mu}(x_t,x_0)&amp;=\frac{\sqrt{\alpha_{t}}(1-\overline{\alpha}_{t-1})}{1-\overline{\alpha}_{t}}x_{t}+\frac{\sqrt{\overline{\alpha}_{t-1}}\beta_{t}}{1-\overline{\alpha}_{t}} x_{0}\\&amp;=\frac{\sqrt{\alpha_{t}}(1-\overline{\alpha}_{t-1})}{1-\overline{\alpha}_{t}}x_{t}+\frac{\sqrt{\overline{\alpha}_{t-1}}\beta_{t}}{1-\overline{\alpha}_{t}}\frac{1}{\sqrt{\overline{\alpha_t}}}(x_t-\sqrt{1-\overline{\alpha_t}}\epsilon)\\&amp;=\frac{\sqrt{\alpha_{t}}(1-\overline{\alpha}_{t-1})}{1-\overline{\alpha}_{t}}x_{t}+\frac{\sqrt{\overline{\alpha}_{t-1}}\beta_{t}}{1-\overline{\alpha}_{t}}\frac{1}{\sqrt{\overline{\alpha_t}}}x_t-\frac{1}{\sqrt{\overline{\alpha_t}}}\frac{\sqrt{\overline{\alpha}_{t-1}}\beta_{t}}{1-\overline{\alpha}_{t}}\sqrt{1-\overline{\alpha_t}}\epsilon\\&amp;=\frac{\sqrt{\alpha_{t}}(1-\overline{\alpha}_{t-1})}{1-\overline{\alpha}_{t}}x_{t}+\frac{\beta_{t}}{1-\overline{\alpha}_{t}}\frac{1}{\sqrt{\alpha_t}}x_t-\frac{\sqrt{\overline{\alpha}_{t-1}}\beta_{t}}{\sqrt{\overline{\alpha_t}}\sqrt{1-\overline{\alpha}_{t}}}\epsilon\\&amp;=\frac{1}{1-\overline{\alpha}_{t}}(\sqrt{\alpha_{t}}(1-\overline{\alpha}_{t-1})+\frac{\beta_{t}}{\sqrt{\alpha_t}})x_t-\frac{\beta_{t}}{\sqrt{\alpha_t}\sqrt{1-\overline{\alpha}_{t}}}\epsilon\\&amp;=\frac{1}{1-\overline{\alpha}_{t}}(\sqrt{\alpha_{t}}-\sqrt{\alpha_{t}}\overline{\alpha}_{t-1}+\frac{1-\alpha_{t}}{\sqrt{\alpha_t}})x_t-\frac{\beta_{t}}{\sqrt{\alpha_t}\sqrt{1-\overline{\alpha}_{t}}}\epsilon\\&amp;=\frac{1}{\sqrt{\alpha_{t}}(1-\overline{\alpha}_{t})}(\alpha_{t}-\overline{\alpha}_{t}+1-\alpha_{t})x_t-\frac{\beta_{t}}{\sqrt{\alpha_t}\sqrt{1-\overline{\alpha}_{t}}}\epsilon\\&amp;=\frac{1}{\sqrt{\alpha_{t}}(1-\overline{\alpha}_{t})}(1-\overline{\alpha}_{t})x_t-\frac{\beta_{t}}{\sqrt{\alpha_t}\sqrt{1-\overline{\alpha}_{t}}}\epsilon\\&amp;=\frac{1}{\sqrt{\alpha_{t}}}x_t-\frac{\beta_{t}}{\sqrt{\alpha_t}\sqrt{1-\overline{\alpha}_{t}}}\epsilon\\&amp;=\frac{1}{\sqrt{\alpha_{t}}}(x_t-\frac{\beta_{t}}{\sqrt{1-\overline{\alpha}_{t}}})\epsilon\end{aligned}\]</span> We use a MSE Loss to measure and minimise the distance ofpredict <span class="math inline">\(\mu_\theta\)</span> and actual <spanclass="math inline">\(\tilde\mu\)</span> <span class="math display">\[L_{t}=\frac{1}{2 \sigma_{t}^{2}}\left\|\tilde{\mu}_{t}\left(x_{t},x_{0}\right)-\mu_{\theta}\left(x_{t}, t\right)\right\|^{2}=\frac{1}{2\sigma_{t}^{2}}\left\|\frac{1}{\sqrt{\alpha_{t}}}\left(x_{t}-\frac{\beta_{t}}{\sqrt{1-\overline{\alpha}_{t}}}\epsilon\right)-\mu_{\theta}\left(x_{t}, t\right)\right\|^{2}\]</span> In <span class="math inline">\(\mu\)</span> there are twovariable except for coefficients, in which <spanclass="math inline">\(x_t\)</span> is input and <spanclass="math inline">\(\epsilon\)</span> is noise component. We r]-write<span class="math inline">\(\mu_\theta\)</span> in similar form so thatwe can focus more on predicting noise. <span class="math display">\[\begin{aligned}L_t&amp;=\frac{1}{2\sigma_{t}^{2}}\left\|\frac{1}{\sqrt{\alpha_{t}}}\left(x_{t}-\frac{\beta_{t}}{\sqrt{1-\overline{\alpha}_{t}}}\epsilon\right)-\frac{1}{\sqrt{\alpha_{t}}}\left(x_{t}-\frac{\beta_{t}}{\sqrt{1-\overline{\alpha}_{t}}}\epsilon_{\theta}\left(x_{t}, t\right)\right)\right\|^{2}\\&amp;=\frac{\beta_{t}^{2}}{2 \sigma_{t}^{2}\alpha_{t}\left(1-\hat{\alpha}_{t}\right)} \|\epsilon-\epsilon_{\theta}\left(x_{t}, t\right) \|^{2}\end{aligned}\]</span> The coefficient before <span class="math inline">\(L2\)</span>distance can be simply neglected since it would not affect training.</p><p>Get back to real loss function we were talking about. Now it isequivalent to <span class="math display">\[L_{VLB}=\sum_{t=2}^{T} D_{K L}(q(x_{t-1} | x_{t}, x_{0}) ||p_{\theta}(x_{t-1} | x_{t}))-\log (p_{\theta}(x_{0} |x_{1}))\sim\|\epsilon-\epsilon_{\theta}(x_{t}, t)\|^{2}-\log(p_{\theta}(x_{0} | x_{1}))\]</span> The last term can also be neglected and use a network topredict. Reason behind it won't be detailed in this article. The readeris refereed to origin video and paper to find more information.</p><p>The final loss is <span class="math display">\[L=\|\epsilon-\epsilon_{\theta}(x_{t}, t)\|^{2}\]</span></p><h2 id="algorithm-description">5. Algorithm Description</h2><p><imgsrc="/images/2022-09-27-Mathematic%20behind%20Diffusion%20Model/training-algorithm.png" /></p><p><imgsrc="/images/2022-09-27-Mathematic%20behind%20Diffusion%20Model/sampling-algorithm.png" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Deep-Learning</tag>
      
      <tag>Mathematics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo初步部署指南</title>
    <link href="/2022/09/22/2022-09-22-Hexo%E5%88%9D%E6%AD%A5%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/"/>
    <url>/2022/09/22/2022-09-22-Hexo%E5%88%9D%E6%AD%A5%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>这是一份Hexo框架初步部署快速指南。</p><p>Hexo是一种基于Nodejs开发的快速、简单易用的博客框架。一般地，Hexo接受以Markdon格式编写的博文，并按照配置和主题文件，生成对应的html网页，可以托管在GithubPage上使用。</p><h2 id="nodejs-安装">0. Nodejs 安装</h2><p>Ubuntu:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install nodejs<br>sudo apt-get install npm<br></code></pre></td></tr></table></figure><p>Windows在官网下载可执行安装文件安装。</p><p>安装完成执行下面的命令以确认安装正确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></td></tr></table></figure><h2 id="hexo安装">1. Hexo安装</h2><p>Hexo是发布在npm上的一个包，执行以下命令在全局范围内安装Hexo。<code>-g</code>标志在全局范围内保存该包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>执行以下测试是否正确安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo -v<br></code></pre></td></tr></table></figure><h2 id="初始化一个博客">2. 初始化一个博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;folder_name&gt;<br></code></pre></td></tr></table></figure><p>其中，<code>source</code>目录存放和博文相关的资源，包括<code>md</code>文件和图片。在md文件中的引用的根目录<code>/</code>是该目录。<code>themes</code>文件夹存放主题，需要手动下载放入并在全站配置文件<code>_config.yml</code>中设置，主题的配置文件在对应的主题目录内。</p><p>这里不赘述具体的配置，请查阅Hexo和所使用的主题的帮助文档。</p><h2 id="运行博客">3. 运行博客</h2><p>清除当前生成的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br></code></pre></td></tr></table></figure><p>重新生成静态文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br><span class="hljs-comment"># or hexo g</span><br></code></pre></td></tr></table></figure><p>启动博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo serve<br><span class="hljs-comment"># or hexo s</span><br></code></pre></td></tr></table></figure><h2 id="有趣的插件">4. 有趣的插件</h2><p>在当前路径下使用npm安装对应的包并进行必要配置就可以使用海量插件。<code>--save</code>将下载的包列入<code>package.json</code>中方便重新安装部署。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save &lt;package_name&gt;<br></code></pre></td></tr></table></figure><p>以下是一些比较有趣的插件：</p><ul><li><p>hexo-admin</p><p>使用后台管理博客</p></li><li><p>hexo-deployer-git</p><p>运行通过git在执行<code>hexo deploy</code>或<code>hexo d</code>时将生成的网页推送至托管的Git仓库上</p></li><li><p>hexo-blog-encrypt</p><p>加密博文</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Guide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust基础入门</title>
    <link href="/2022/03/05/2022-03-05-Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2022/03/05/2022-03-05-Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>@ 2022.03.05 20:36 UTC+0800 v1</p></blockquote><p>这是一篇面向有一定编程基础者的Rust基础入门指南，涵盖Rust的控制流，所有权，枚举，结构体，<code>Trait</code>，面向对象，并发等知识。</p><blockquote><p>我从2022.02.04日正式开始学习Rust，经过半个寒假的拖拖拉拉的入门，终于在新学期开学后下定决心攻下这个难关。然而还是大大低估了Rust的难度，这一周多整天盯着电脑看教程才将剩下的一大半入门教学视频大致看完。希望以后的我还能依靠本文快速重新入门。</p></blockquote><!--TODO：动态大小与Sized Trait, ?Sized Trait约束--><!--TODO：宏--><!--TODO：Cargo和Crates.io--><h2 id="cargo">0. Cargo</h2><p>Cargo是Rust的构建系统与包管理系统。</p><h3 id="创建项目">0.1 创建项目</h3><p>cargo默认使用git管理版本，使用<code>--vcs</code>开关进行设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new project_name<br></code></pre></td></tr></table></figure><p>建立目录如下，其中源代码存储于<code>src</code>文件夹中，<code>.git/</code>和<code>.gitignore</code>为版本控制的配置文件，<code>Cargo.toml</code>为项目配置文件。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">project_name<br>├── Cargo<span class="hljs-selector-class">.toml</span><br>├── <span class="hljs-selector-class">.git</span><br>├── <span class="hljs-selector-class">.gitignore</span><br>└── <span class="hljs-attribute">src</span><br>    └── <span class="hljs-selector-tag">main</span>.rs<br></code></pre></td></tr></table></figure><h3 id="构建项目">0.2 构建项目</h3><p>根据rust源代码生成可执行文件，默认以debug模式。生成的可执行文件位于<code>target/debug/</code>。</p><p>也可以使用<code>--release</code>开关，以release模式构建，编译速度变慢但运行速度提升，生成的可执行文件位于<code>target/release/</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build<br></code></pre></td></tr></table></figure><h3 id="运行项目">0.3 运行项目</h3><p>编译源代码并运行，若代码没有修改则直接运行已经存在的可执行文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo run<br></code></pre></td></tr></table></figure><h3 id="项目编译检查">0.4 项目编译检查</h3><p>检查源代码是否能够通过编译，不生成可执行文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo check<br></code></pre></td></tr></table></figure><h3 id="cargo.toml">0.5 Cargo.toml</h3><p>用于配置项目，在第一次项目编译的时候会生成<code>Cargo.lock</code>。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;project_name&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br></code></pre></td></tr></table></figure><h2 id="常量变量可变性和原生类型">1. 常量、变量、可变性和原生类型</h2><h3 id="常量">1.1 常量</h3><p>Rust的常量声明使用<code>const</code>关键字，需要显式声明常量的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> CONST_NUM: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="不可变变量">1.2 不可变变量</h3><p>定义一个不可变变量的过程称为绑定。不可变变量一经绑定不能重新赋值修改，但可以重新绑定，绑定前后的类型不需要一致。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">variable</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>一般编译器会推断出所绑定的变量类型，而不需要显式声明，若给定的信息不足以推断出变量类型，则需要手动声明变量类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">variable</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">variable</span>: <span class="hljs-type">i32</span> = <span class="hljs-string">&quot;42&quot;</span>.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Not a Num&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="可变变量">1.3 可变变量</h3><p>可变变量是可以被赋值、被修改的变量，但被修改前后的类型必须一致。定义一个可变变量的方法如下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">variable</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">variable</span>: <span class="hljs-type">i32</span> = <span class="hljs-string">&quot;42&quot;</span>.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Not a Num&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="let解构">1.4 <code>let</code>解构</h3><p>可以在一个<code>let</code>语句中绑定多个变量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (a, <span class="hljs-keyword">mut</span> b): (<span class="hljs-type">bool</span>,<span class="hljs-type">bool</span>) = (<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h3 id="原生类型">1.5 原生类型</h3><p>原生类型不支持自动的类型转换，需要强制转换时使用<code>variable as type</code></p><ul><li>整数类型<ul><li>有符号：<code>i8</code>、<code>i16</code>、<code>i32</code>（默认）<code>i64</code>、<code>i128</code>、<code>isize</code></li><li>无符号：<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code>、<code>usize</code></li><li>字面值：支持下划线分割（<code>12_34</code>）、支持<code>0x</code>、<code>0o</code>、<code>0b</code>头、支持以类型名作为后缀指定类型(<code>42u8</code>)、字符(只有<code>u8</code>:<code>b'A'</code>)</li></ul></li><li>浮点数类型<ul><li>单精度： <code>f32</code></li><li>双精度：<code>f64</code>（默认）</li></ul></li><li>布尔类型<ul><li><code>bool</code>：<code>true</code> / <code>false</code></li></ul></li><li>字符类型（4字节Unicode）<ul><li><code>char</code></li></ul></li></ul><h2 id="元组-tuple">2. 元组 Tuple</h2><h3 id="元组的声明">2.1 元组的声明</h3><p>元组是一种将多个不同类型的值组合在一起的类型，元组的长度与各位置的类型一经确定不能更改，但可变元组变量的成员元素能够修改。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tuple</span> :(<span class="hljs-type">i32</span>, <span class="hljs-type">u32</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tuple</span> = (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span>);<br></code></pre></td></tr></table></figure><h3 id="元组的访问">2.2 元组的访问</h3><p>使用<code>tuple.index</code>对元组的各个成员进行访问。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">tuple.<span class="hljs-number">0</span> = <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure><h3 id="元组的解构">2.3 元组的解构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (x, y, z) = tuple;<br></code></pre></td></tr></table></figure><h2 id="数组-array">3. 数组 Array</h2><h3 id="数组的声明">3.1 数组的声明</h3><p>数组是一种将多个同样类型的值组合在一起的类型，数组的长度与成员类型一经确定不能更改，但可变数组变量的成员元素能够修改。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">array</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">array</span> = [value; CONST_LENGTH];<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">array</span> = [<span class="hljs-number">0</span>; <span class="hljs-number">5</span>]; <span class="hljs-comment">// 长度为5填充0</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">array</span>: [<span class="hljs-type">i32</span>: <span class="hljs-number">3</span>] = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><h3 id="数组的访问">3.2 数组的访问</h3><p>使用<code>array[index]</code>对数组的各个成员进行访问。下标越界时可能能够通过编译但运行时<code>panic</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">array[<span class="hljs-number">0</span>] = <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure><h2 id="函数">4. 函数</h2><h3 id="函数的声明">4.1 函数的声明</h3><p>函数体以一系列语句组成，可以选择使用<code>return</code>语句返回值，或在函数体最后以一行表达式结尾作为返回。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function_name</span>(parameter: para_type)<span class="hljs-punctuation">-&gt;</span>return_type&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="语句与表达式">4.2 语句与表达式</h3><ul><li>语句: 执行一系列操作并返回空的元组，以<code>;</code>结尾</li><li>表达式: 计算并返回值，没有<code>;</code>结尾</li></ul><h3 id="函数的传参">4.3 函数的传参</h3><p>函数的传参涉及到所有权的转移，在没有使用借用的情况下，形参重新绑定变量获得所有权。默认的形参不可变，需要加<code>mut</code>可变。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>(<span class="hljs-keyword">mut</span> parameter: para_type)&#123;<br>    <span class="hljs-comment">// change or re-assign parameter here</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if-else表达式">5. if-else表达式</h2><p><code>if-else</code>中的条件部分只支持布尔条件表达式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> condition_expression&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition_expression&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>if-else</code>是一种表达式，可以有返回值，并且所有分支都必须返回相同的类型。可以利用该特点构造赋值时的<code>if-else</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">if</span> condition &#123;variable0&#125; <span class="hljs-keyword">else</span> &#123;variable1&#125;;<br></code></pre></td></tr></table></figure><h2 id="loop循环">6. loop循环</h2><p><code>loop</code>循环是一种无限循环，可以使用<code>break</code>退出本层循环，也可以使用<code>continue</code>跳过本轮循环的余下部分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">loop</span>&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><p>存在多层循环时，可以使用<code>break</code>+<code>'label</code>跳出多层循环。该特性也可以用于其他循环语句。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-symbol">&#x27;outer</span>:<br><span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-symbol">&#x27;inner</span>:<br>    <span class="hljs-keyword">loop</span>&#123;<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 跳出一层</span><br>        <span class="hljs-keyword">break</span> <span class="hljs-symbol">&#x27;outer</span>; <span class="hljs-comment">//跳出两层</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>break</code>后可以接一个表达式，这样该表达式就会作为<code>loop</code>循环表达式的返回值返回。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">loop</span> &#123;<br>    counter += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="while循环">7. while循环</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> condition_expression&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="for循环">8. for循环</h2><p><code>for</code>循环用于对迭代器进行遍历。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">Iterator</span>&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一些常见的迭代器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust">start..end <span class="hljs-comment">// 左闭右开</span><br>start..=end <span class="hljs-comment">// 闭区间</span><br>(start..end).<span class="hljs-title function_ invoke__">rev</span>() <span class="hljs-comment">// 反向</span><br>(start..end).<span class="hljs-title function_ invoke__">step_by</span>(step) <span class="hljs-comment">// 设置步长</span><br>[].<span class="hljs-title function_ invoke__">iter</span>() <span class="hljs-comment">// 借用转为迭代器</span><br>[].<span class="hljs-title function_ invoke__">into_iter</span>() <span class="hljs-comment">// 移动转为迭代器</span><br>[].<span class="hljs-title function_ invoke__">iter_mut</span>() <span class="hljs-comment">// 可变借用转为迭代器</span><br></code></pre></td></tr></table></figure><h2 id="所有权">9. 所有权</h2><h3 id="栈内存stack与堆内存heap">9.1 栈内存（Stack）与堆内存（Heap)</h3><ul><li><p>栈内存：</p><p>在栈内存上的数据必须拥有已知固定大小，快。</p></li><li><p>堆内存：</p><p>在栈内存上的数据不必拥有已知固定大小，需要通过指针访问，慢。</p></li></ul><h3 id="所有权规则">9.2 所有权规则</h3><ul><li>每一个值都有一个变量，该变量称为值的所有者</li><li>每一个值同时只能有一个所有者</li><li>当值的所有者超出作用域（scope）<code>&#123;&#125;</code> 时，这个值被删除</li></ul><h3 id="移动move">9.3 移动（Move）</h3><p>对于没有实现<code>Copy</code>trait的类型，在进行赋值（<code>let x = y</code>）或通过值来传递函数参数（<code>func(x)</code>）的时候，资源的所有权（ownership）会发生转移，也就是移动。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var0</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>); <span class="hljs-comment">// String is on Heap</span><br>    <span class="hljs-comment">// var0 -&gt; HeapMem(&quot;String(&quot;Hello, World&quot;)&quot;)</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var1</span>: <span class="hljs-type">String</span>;<br>    <span class="hljs-comment">// var0 -&gt; HeapMem(&quot;String(&quot;Hello, World&quot;)&quot;)</span><br>    <span class="hljs-comment">// var1 -&gt; </span><br>    var1 = var0;<br>    <span class="hljs-comment">// var0 -&gt; </span><br>    <span class="hljs-comment">// var1 -&gt; HeapMem(&quot;String(&quot;Hello, World&quot;)&quot;)</span><br>    <span class="hljs-comment">// invalid visit to var0</span><br>&#125;<br><span class="hljs-comment">// Out of the scope, HeapMem free by owner: var1</span><br></code></pre></td></tr></table></figure><p>如果需要保持原变量的所有权，可以实现并使用<code>Clone</code>trait，创建副本。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var0</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>); <span class="hljs-comment">// String is on Heap</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var1</span> = var0.<span class="hljs-title function_ invoke__">clone</span>();<br>&#125;<br><span class="hljs-comment">// Out of the scope, HeapMem free by owner: var1</span><br></code></pre></td></tr></table></figure><p>对于实现了<code>Copy</code>trait的类型，Rust在赋值的时候会自动拷贝内存，生成副本，此时两个副本的所有权相互独立互不影响。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var0</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var1</span>: <span class="hljs-type">i32</span> = var0;<br>    <span class="hljs-comment">// both var0 and var1 are valid</span><br>&#125;<br></code></pre></td></tr></table></figure><p>常见的实现了<code>Copy</code> trait的基本类型：</p><ul><li>整数，浮点数，布尔类型，字符类型，所有元素类型均实现了<code>Copy</code>trait的元组</li><li>任何简单标量的组合类型都可以是</li><li>任何需要分配内存或某种资源的均不是</li></ul><h3 id="引用与借用">9.4 引用与借用</h3><p>允许使用某些值但不获取其所有权的方法称为引用。引用<code>&amp;</code>默认是不可变的，对于引用一个可变变量时，可以使用<code>mut</code>标记为可变的。引用不具有值的所有权，所以不负责释放值。</p><p>引用的作用域是声明开始到最后一次使用为止。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">var0</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">var1</span> = &amp;var0;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">var2</span> = &amp;<span class="hljs-keyword">mut</span> var0;<br></code></pre></td></tr></table></figure><p>也可以使用<code>ref</code>关键字创建引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">ref</span> var1 = var0;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">ref</span> <span class="hljs-keyword">mut</span> var2 = var0;<br></code></pre></td></tr></table></figure><p>在函数传参时发生的引用称为借用。借用默认是不可变的，对于借用一个可变变量时，可以使用<code>mut</code>标记为可变的。同样地，借用也不负责释放值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">addSuffix</span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>)&#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">var0</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>    <span class="hljs-title function_ invoke__">addSuffix</span>(&amp;<span class="hljs-keyword">mut</span> var0);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, var0);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><em>在特定的作用域内，对于同一块数据存在以下的限制</em></strong>：</p><ul><li>不能存在多个可变引用</li><li>存在可变引用时，不能存在不可变引用</li></ul><p>或者说，<strong><em>对于同一块数据的引用，在特定的作用域内只能同时满足以下中的一个</em></strong>：</p><ul><li>存在一个可变引用</li><li>存在多个不可变引用</li></ul><p>另外地，Rust不支持悬空引用(DangleRefernece)，即当引用的变量因离开作用域等原因被销毁后还存在引用时，Rust报错。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">addSuffix</span>(<span class="hljs-keyword">mut</span> s: <span class="hljs-type">String</span>)&#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;!&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var0</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>    <span class="hljs-title function_ invoke__">addSuffix</span>(var0);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;var0); <span class="hljs-comment">// moved out of scope</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-keyword">return</span> &amp;s;<br>&#125; <span class="hljs-comment">// moved out</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="切片">10. 切片</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;s1[..];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">array</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = &amp;array[<span class="hljs-number">1</span>..<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><h2 id="结构体">11. 结构体</h2><h3 id="结构体的定义">11.1 结构体的定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    field_name0: field_type0,<br>    field_name1: field_type1,<br>    field_name2: field_type2,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体的实例化">11.2 结构体的实例化</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">struct_name&#123;<br>    field_name0: field_value0,<br>    field_name1: field_value1,<br>    field_name2: field_value2,<br>&#125;<br></code></pre></td></tr></table></figure><p>当字段名和字段所赋值的变量同名时，可以省去一个</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">struct_name&#123;<br>    name0,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体字段的访问">11.3 结构体字段的访问</h3><p>若结构体实例是可变的则其各个字段均可变，不能对字段单独设置可变性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">struct_variable.field_name<br></code></pre></td></tr></table></figure><h3 id="结构体的更新">11.4 结构体的更新</h3><p>根据一个已经存在的结构体实例生成新的实例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">struct_name&#123;<br>    field_name0: field_value0,<br>    ..old_one <span class="hljs-comment">// 余下字段与old相同</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="元组结构体">11.5 元组结构体</h3><p>不给定字段名称的结构体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>(field_type0, field_type1);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">struct_name</span>(value0, value1);<br></code></pre></td></tr></table></figure><p>需要注意的是，完全具有相同字段类型的两个<code>Tuple Struct</code>不算同类型的结构体。对<code>Tuple Struct</code>的访问与解构均与<code>Tuple</code>类似。</p><h3 id="结构体方法">11.6 结构体方法</h3><p>结构体的方法定义在一个<code>impl</code>块中，一个结构体可以有多个<code>impl</code>块。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    field_name0: field_type0,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name0</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-comment">// pass</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name1</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-comment">// pass</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name2</span>(<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-comment">// pass</span><br>    &#125;<br>&#125;<br>struct_var.<span class="hljs-title function_ invoke__">method_name0</span>();<br></code></pre></td></tr></table></figure><h3 id="结构体关联函数">11.7 结构体关联函数</h3><p>定义在<code>impl</code>块内，但不把<code>self</code>作为第一个参数的函数。常用于构造器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    field_name0: field_type0,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name0</span>()&#123;<br>        <span class="hljs-comment">// pass</span><br>    &#125;<br>&#125;<br>struct_name::<span class="hljs-title function_ invoke__">method_name0</span>();<br></code></pre></td></tr></table></figure><h2 id="枚举">12. 枚举</h2><p>通过列举所有可能的取值来定义一个类型。</p><h3 id="枚举的定义">12.1 枚举的定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">enum_name</span>&#123;<br>    possible_option0,<br>    possible_option1,<br>    <span class="hljs-title function_ invoke__">possible_option2</span>(type0), <span class="hljs-comment">// 关联附加数据</span><br>    <span class="hljs-title function_ invoke__">possible_option3</span>(type1, type2, type3),<br>    possible_option4 &#123;x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>&#125;, <span class="hljs-comment">//匿名结构体</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="枚举的实例化">12.2 枚举的实例化</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = enum_name::possible_option0;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = enum_name::<span class="hljs-title function_ invoke__">possible_option3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = enum_name::possible_option4&#123;x: <span class="hljs-number">4</span>, y: <span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="枚举方法">12.3 枚举方法</h3><p>与结构体一样，枚举的方法定义在一个<code>impl</code>块中，一个枚举可以有多个<code>impl</code>块。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">enum_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-comment">// pass</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="枚举关联函数">12.4 枚举关联函数</h3><p>与结构体一样，枚举也有关联函数。</p><h3 id="option枚举">12.5 <code>Option</code>枚举</h3><p>位于预导入模块中的描述一个值可能存在，可能不存在的情况。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// definition of enum Option</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt;&#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的<code>None</code>用于表示某种类型的空值，需要使用<code>Option::Some(T)</code>中的时，可以使用<code>unwrap()</code>枚举方法取出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Option</span>::<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">d</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Option</span>::&lt;<span class="hljs-type">i32</span>&gt;::<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">e</span> = <span class="hljs-type">Option</span>::&lt;<span class="hljs-type">i32</span>&gt;::<span class="hljs-literal">None</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br></code></pre></td></tr></table></figure><h2 id="match表达式与if-let">13. match表达式与if-let</h2><p><code>match</code>需要穷尽所有可能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> variable&#123;<br>    pattern0 =&gt; arm0,<br>    pattern1 =&gt; &#123;<br>        arm1,<br>    &#125;,<br>    pattern2 | pattern3 =&gt; arm,<br>    <span class="hljs-title function_ invoke__">pattern4</span>(x, y) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, x, y), <span class="hljs-comment">//解构</span><br>    _ =&gt; (), <span class="hljs-comment">// default arm</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>if-let</code>放弃了穷举，只关心一种匹配。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> variable&#123;<br>    pattern =&gt; arm0,<br>    _ =&gt; (),<br>&#125;<br><br><span class="hljs-comment">// if-let等效</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">pattern</span> = variable&#123;<br>    arm0;<br>&#125;<br><br><span class="hljs-keyword">match</span> variable&#123;<br>    pattern =&gt; arm0,<br>    _ =&gt; arm1,<br>&#125;<br><br><span class="hljs-comment">// if-let等效</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">pattern</span> = variable&#123;<br>    arm0;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    arm1;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="package-crate-module">14. <code>Package</code>,<code>crate</code>, <code>module</code></h2><h3 id="package">14.1 Package</h3><p>Cargo 的一个功能，它允许你构建、测试和分享 crate。</p><p>包含一个<code>Cargo.toml</code>文件，描述了如何构建<code>package</code>中的<code>crate</code></p><p>只能包含0-1个<code>library crate</code>，可以包含任意多数量的<code>binary crate</code>，但至少包含一个人以种类的<code>crate</code>。</p><h3 id="crate">14.2 Crate</h3><p>一个模块树，可以产生一个<code>library</code>或可执行文件。</p><ul><li><code>binary crate</code></li><li><code>library crate</code></li></ul><p><code>crate root</code>是一个源代码文件，指示Rust编译器从此开始组成<code>crate</code>的根<code>module</code>。</p><ul><li><code>src/main.rs</code>默认是<code>binary crate</code>的<code>crate root</code>，其<code>crate</code>名与<code>package</code>名相同</li><li><code>src/lib.rs</code>默认是<code>library crate</code>的<code>crate root</code>，其<code>crate</code>名与<code>package</code>名相同</li><li><code>src/bin/</code>下的文件均为单独的<code>binary crate</code></li></ul><h3 id="module">14.3 Module</h3><p>控制代码的组织、作用于与私有路径。</p><p><code>module</code>可以嵌套，可以包含其他项的定义。</p><p><code>module</code>与其内部所定义的项均默认为私有的：</p><ul><li>父模块无法访问子模块内的私有项</li><li>子模块中可以访问父模块中的项</li></ul><p>可以使用<code>pub</code>关键字声明为公有的项。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> module_name&#123;<br>    <span class="hljs-keyword">mod</span> inner_module_name&#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function_name</span>()&#123;<br>        &#125;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">structure_name</span>&#123;<br>        &#125;<br>        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">enum_name</span>&#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">crate<br>└── <span class="hljs-keyword">module</span><span class="hljs-number">_n</span>ame<br>   └── inner<span class="hljs-number">_m</span>odule<span class="hljs-number">_n</span>ame<br>       ├── enum<span class="hljs-number">_n</span>ame<br>       ├── <span class="hljs-keyword">function</span><span class="hljs-number">_n</span>ame<br>       └── structure<span class="hljs-number">_n</span>ame<br></code></pre></td></tr></table></figure><h3 id="路径">14.4 路径</h3><p>Rust为了在模块中找到特定的项，需要使用路径。路径由一个或者多个标识符构成，不同标识符之间使用<code>::</code>分割。</p><ul><li>绝对路径</li></ul><p>从<code>crate root</code>开始描述路径，使用<code>crate</code>关键字表示当前<code>crate</code>的<code>crate root</code>或者使用<code>crate</code>名指定其他<code>crate</code>的<code>crate root</code>。</p><ul><li>相对路径</li></ul><p>从当前<code>module</code>开始，依靠<code>self</code>，<code>super</code>等关键字指定路径</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// package_name: package</span><br><span class="hljs-comment">// file: src/lib.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> outer_scope0&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">say_hello</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> outer_scope1&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> inner_scope&#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_again</span>()&#123;<br>            self::super::super::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>            crate::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_triple</span>()&#123;<br>        super::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>        self::inner_scope::<span class="hljs-title function_ invoke__">hello_again</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// file: src/main.rs</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    package::outer_scope1::<span class="hljs-title function_ invoke__">hello_triple</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="use关键字">14.5 <code>use</code>关键字</h3><p>将路径或者项导入到作用域中，遵守私有性规则，导入后默认为私有，不能被外部代码访问，可用<code>pub</code>关键字转为公有，可以使用<code>as</code>关键字指定本地别名。</p><p>若需要导入的项有重名的，可以分别导入它们的父模块，使用时从父模块指明项避免冲突。</p><p>一般地，导入函数时导入其父模块，导入其他类型的项时导入其本身。</p><p>导入时可以使用嵌套路径<code>相同::&#123;不同&#125;</code>省略重复部分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// file: src/main.rs</span><br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, Write&#125;;<br><span class="hljs-keyword">use</span> std::collections::*;<br><span class="hljs-keyword">use</span> package::outer_scope1;<br><span class="hljs-keyword">use</span> package::outer_scope1::hello_triple <span class="hljs-keyword">as</span> three_times_of_hello;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>outer_scope1::<span class="hljs-title function_ invoke__">hello_triple</span>();<br>    <span class="hljs-title function_ invoke__">three_times_of_hello</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模块签名">7.6 模块签名</h3><p>模块体内可以不直接给出而以<code>;</code>结束，此时为模块签名。Rust会根据<code>crate</code>路径搜索与<code>crate</code>路径同名路径下的与模块同名的<code>.rs</code>文件寻找具体定义，或者与<code>crate</code>路径同名路径下的与模块同名文件夹内的<code>mod.rs</code>文件寻找具体定义。以上代码分离不会导致<code>crate</code>树改变。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">── <span class="hljs-attribute">src</span><br>   ├── lib<span class="hljs-selector-class">.rs</span><br>   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.rs</span><br>   ├── outer_scope0<span class="hljs-selector-class">.rs</span><br>   └── outer_scope1<br>       ├── inner_scope<span class="hljs-selector-class">.rs</span><br>       └── mod.rs<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// file: src/lib.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> outer_scope0;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> outer_scope1;<br><br><span class="hljs-comment">// file: src/outer_scope0.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">say_hello</span>()&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// file: src/outer_scope1/mod.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> inner_scope;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_triple</span>()&#123;<br>    super::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>    self::inner_scope::<span class="hljs-title function_ invoke__">hello_again</span>();<br>&#125;<br><br><span class="hljs-comment">// file: src/outer_scope1/inner_scope.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_again</span>()&#123;<br>    self::super::super::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>    crate::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>&#125;<br><br><span class="hljs-comment">// file: src/main.rs</span><br><span class="hljs-keyword">use</span> package::outer_scope1;<br><span class="hljs-keyword">use</span> package::outer_scope1::hello_triple <span class="hljs-keyword">as</span> three_times_of_hello;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>outer_scope1::<span class="hljs-title function_ invoke__">hello_triple</span>();<br>    <span class="hljs-title function_ invoke__">three_times_of_hello</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误处理">15. 错误处理</h2><p>错误分为：</p><ul><li>可恢复错误：依靠<code>Result&lt;T, E&gt;</code>枚举实现</li><li>不可恢复错误：<code>panic!()</code></li></ul><h3 id="不可恢复错误与panic">15.1不可恢复错误与<code>panic!</code></h3><p>执行<code>panic!()</code>宏时，Rust：</p><ul><li>打印提供的错误信息</li><li>默认展开并清理调用栈，工作量大，使得发布程序大，或设置<code>Cargo.toml</code>立即中止调用栈交操作系统清理</li><li>退出程序</li></ul><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[profile.release]</span><br><span class="hljs-attr">panic</span> = <span class="hljs-string">&quot;abort&quot;</span><br></code></pre></td></tr></table></figure><h3 id="可恢复错误与resultt-e">15.2可恢复错误与<code>Result&lt;T, E&gt;</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用match处理可恢复错误">15.2.1使用<code>match</code>处理可恢复错误</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error)<br>        &#125;,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="错误类型匹配与嵌套错误处理">15.2.2错误类型匹配与嵌套错误处理</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::ErrorKind;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">match</span> error.<span class="hljs-title function_ invoke__">kind</span>() &#123;<br>            ErrorKind::NotFound =&gt; <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>) &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(fc) =&gt; fc,<br>                <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),<br>            &#125;,<br>            other_error =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),<br>        &#125;,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="闭包的错误处理方法">15.2.3 闭包的错误处理方法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::ErrorKind;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|error| &#123;<br>        <span class="hljs-keyword">if</span> error.<span class="hljs-title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;<br>            File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|error| &#123;<br>                <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, error);<br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="unwrap方法">15.2.4 <code>unwrap</code>方法</h4><p><code>unwrap</code>方法支持直接将<code>Ok</code>内的值提取出来，如果是<code>Err</code>则直接触发<code>panic!</code>，但不能设置<code>panic</code>信息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="expect方法">15.2.5 <code>expect</code>方法</h4><p><code>expect</code>方法支持直接将<code>Ok</code>内的值提取出来，如果是<code>Err</code>则直接触发<code>panic!</code>，返回的设置<code>panic</code>信息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to open hello.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="传播错误">15.2.6 传播错误</h4><p>在一个<strong><em>函数内部</em></strong>发生可恢复错误时，可以选择不加处理而将错误返回给调用者，让调用者决定处理方式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(e),<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br>    <span class="hljs-keyword">match</span> f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(s),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-title function_ invoke__">Err</span>(e),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运算符">15.2.7 <code>?</code>运算符</h4><p>简化错误传播，有值时直接提取，是错误时直接返回错误。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file_</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br>    File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>main</code>函数中使用<code>?</code>运算符需要修改<code>main</code>函数的返回类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt;&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常用collections">16. 常用<code>collections</code></h2><h3 id="vec">16.1 <code>Vec</code></h3><p><code>Vec</code>是由<code>std</code>标准库提供的。<code>Vec</code>中的值为同类型的元素，在内存中连续存放。</p><h4 id="vec的创建">16.1.1 <code>Vec</code>的创建</h4><ul><li>创建空的<code>Vec</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;type_name&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure><ul><li>使用<code>vec!</code>创建带初始值的<code>Vec</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><h4 id="vec添加元素">16.1.2 <code>Vec</code>添加元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><h4 id="vec访问元素">16.1.3 <code>Vec</code>访问元素</h4><ul><li>索引访问，越界时直接<code>panic</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 直接索引，需要实现`copy` trait</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = v[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// 引用索引</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = &amp;v[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><ul><li><code>get</code>方法访问，返回<code>Option&lt;&amp;type_name&gt;</code>枚举，其中有效部分为引用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: &amp;<span class="hljs-type">i32</span> = v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><h4 id="vec遍历元素">16.1.4<code>Vec</code>遍历元素</h4><ul><li>移动遍历</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> v&#123;<br>    <span class="hljs-comment">// v.into_iter()</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>不可变引用遍历</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;v&#123;<br>    <span class="hljs-comment">// v.iter()</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可变引用遍历</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v&#123;<br>    <span class="hljs-comment">// v.iter_mut()</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="借助enum枚举实现不同类型vec元素">16.1.5借助<code>enum</code>枚举实现不同类型<code>Vec</code>元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Item</span>&#123;<br>    <span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-type">i32</span>),<br>    <span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<br>        Item::<span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-number">1</span>),<br>        Item::<span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-number">2.0</span>),<br>        Item::<span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;3&quot;</span>)),<br>    ];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="string">16.2 <code>String</code></h3><p>使用<code>UTF-8</code>编码，对<code>Vec&lt;u8&gt;</code>的包装。</p><h4 id="string创建">16.2.1 <code>String</code>创建</h4><ul><li>创建空<code>String</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure><ul><li>创建带初始值的<code>String</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;World&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br></code></pre></td></tr></table></figure><h4 id="string更新">16.2.2 <code>String</code>更新</h4><ul><li>添加字符串切片</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;!&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>添加字符</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&#x27;!&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>连接字符串</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s0</span> = <span class="hljs-string">&quot;Hello &quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-string">&quot;World!&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-comment">// String + &amp;str</span><br><span class="hljs-comment">// 解引用强制转换&amp;String -&gt; &amp;str</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s0 + &amp;s1;<br><span class="hljs-comment">// s0 moved out</span><br><span class="hljs-comment">// s1 valid</span><br></code></pre></td></tr></table></figure><h4 id="format">16.2.3 <code>format!</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;-&#123;&#125;&quot;</span>, s0, s1);<br></code></pre></td></tr></table></figure><h4 id="string的索引切割与遍历">16.2.4<code>String</code>的索引、切割与遍历</h4><p><code>String</code>不允许索引，只允许沿<code>u8</code>表示<code>unicode</code>的边界切割。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 按u8遍历</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>&#125;<br><br><span class="hljs-comment">// 按unicode编码遍历</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">chars</span>()&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hashmapk-v">16.3 <code>HashMap&lt;K, V&gt;</code></h3><h4 id="hashmap创建">16.3.1 <code>HashMap</code>创建</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">dict</span>:HashMap&lt;<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure><ul><li>由<code>Vec&lt;(K, V)&gt;</code>创建</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">dict</span>: HashMap&lt;_, _&gt; = <span class="hljs-built_in">vec!</span>[(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">50</span>, <span class="hljs-number">100</span>)].<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-comment">// HashMap&lt;_, &gt;不可省略</span><br></code></pre></td></tr></table></figure><ul><li>由两个<code>Vec</code>创建</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">keys</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">values</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">dict</span>: HashMap&lt;_, _&gt; = keys.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>(values.<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure><h4 id="hashmap的插入">16.3.2 <code>HashMap</code>的插入</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">dict.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="hashmap的遍历">16.3.3 <code>HashMap</code>的遍历</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-title function_ invoke__">for</span> (i, j) <span class="hljs-keyword">in</span> dict&#123;<br>    <span class="hljs-comment">// </span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="hashmap的访问">16.3.4 <code>HashMap</code>的访问</h4><ul><li>索引访问，接受<code>&amp;key</code>，不存在时直接<code>panic</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">dict[&amp;<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><ul><li><code>get</code>方法，接受<code>&amp;key</code>，返回<code>Option</code>枚举</li></ul><h4 id="hashmap的更新">16.3.5 <code>HashMap</code>的更新</h4><ul><li><code>entry</code>方法与<code>Entry</code>枚举</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">dict.<span class="hljs-title function_ invoke__">entry</span>(key_type);<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// std::collections::hash_map::Entry</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Entry</span>&lt;<span class="hljs-symbol">&#x27;a</span>, K: <span class="hljs-symbol">&#x27;a</span>, V: <span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Occupied</span>(OccupiedEntry&lt;<span class="hljs-symbol">&#x27;a</span>, K, V&gt;),<br>    <span class="hljs-title function_ invoke__">Vacant</span>(VacantEntry&lt;<span class="hljs-symbol">&#x27;a</span>, K, V&gt;),<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>覆盖更新</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">dict.<span class="hljs-title function_ invoke__">insert</span>(key, value);<br></code></pre></td></tr></table></figure><ul><li>不存在时添加</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">dict.<span class="hljs-title function_ invoke__">entry</span>(key).<span class="hljs-title function_ invoke__">or_insert</span>(value);<br><span class="hljs-comment">// 若存在则返回可变引用</span><br><span class="hljs-comment">// 若不存在则插入新值并返回其可变引用</span><br></code></pre></td></tr></table></figure><ul><li>存在时更新</li></ul><p>即对可变引用的修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">count</span> = dict.<span class="hljs-title function_ invoke__">entry</span>(key).<span class="hljs-title function_ invoke__">or_insert</span>(value);<br>*count += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="泛型">17. 泛型</h2><p>放在函数名、结构体名、枚举名或<code>Trait</code>名后的尖括号内的类型或其他属性的抽象占位符的形式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function_name</span>&lt;T&gt; <span class="hljs-punctuation">-&gt;</span> T&#123;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">structure_name</span>&lt;T, U&gt;&#123;<br>    field0:T, <br>    field1:U,<br>&#125;<br><br><span class="hljs-comment">// 对任意类型的泛形方法定义在impl后要加&lt;&gt;</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; structure_name&lt;T&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对指定类型的方法定义在impl后不要加&lt;&gt;</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">structure_name</span>&lt;<span class="hljs-type">i32</span>&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="trait">18. <code>Trait</code></h2><p>某个特定类型拥有可能与其他类型共享的功能。实现了该<code>Trait</code>的类型必须提供其中所有的方法。</p><h3 id="trait的定义">18.1 <code>Trait</code>的定义</h3><p>将方法前面放在一起，以定义实现某种目的的一系列行为。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name0</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> type_name;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name1</span>(&amp;<span class="hljs-keyword">self</span>);<br>    <span class="hljs-comment">// 给出函数签名</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="trait的实现">18.2 <code>Trait</code>的实现</h3><p>孤儿规则：<code>Trait</code>或类型中的一个必须在本<code>crate</code>中定义，不能为一个外部类型实现一个外部<code>Trait</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">item_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name0</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> type_name&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">item_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name1</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="trait方法的默认实现">18.3 <code>Trait</code>方法的默认实现</h3><p>可以在<code>Trait</code>定义时给出方法的方法体作为默认实现，定义时可以使用<code>Trait</code>中签名的其他方法。</p><h3 id="trait作为参数">18.4 <code>Trait</code>作为参数</h3><ul><li><code>impl trait</code>语法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>(parameter: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span>)&#123;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>(parameter: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name0</span> + trait_name1)&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Trait bound</code>语法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>&lt;T: trait_name&gt;(parameter: T)&#123;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>&lt;T: trait_name0 + trait_name1&gt;(parameter: T)&#123;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>&lt;T, U&gt;(parameter0: T, parameter1: U)<br><span class="hljs-keyword">where</span> <br>T: trait_name0 + trait_name1, <br>U: trait_name3 + trait_name4 &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="trait作为返回">18.5 <code>Trait</code>作为返回</h3><p>返回的具体类型必须在任何情况下均一致。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="trait有条件地实现泛型方法">18.6<code>Trait</code>有条件地实现泛型方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; struct_name&lt;T&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method0</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: trait_name&gt; struct_name&lt;T&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method1</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 任何类型struct_name实例均有method0方法</span><br><span class="hljs-comment">// 只有实现了trait_name的struct_name实例有method1方法</span><br></code></pre></td></tr></table></figure><h3 id="覆盖实现">18.7 覆盖实现</h3><p>对于任意已经实现了指定<code>Trait</code>的类型，定义实现某另个<code>Trait</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: trait_name0&gt; trait_name1 <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span>&#123;<br>    <span class="hljs-comment">// 对于任意实现了trait_name0的类型 定义实现trait_name1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型trait">18.8 泛型<code>Trait</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name0</span>&#123;<br>    field: type_name,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name1</span>&lt;T&gt;&#123;<br>    field: T,<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span>&lt;<span class="hljs-type">i32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">struct_name0</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;type_name &#123;<br>        &amp;(<span class="hljs-keyword">self</span>.field)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; trait_name&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">struct_name1</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;(<span class="hljs-keyword">self</span>.field)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生命周期">19. 生命周期</h2><p>Rust中的每一个引用都有其生命周期，也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，但当编译器无法自动推断出引用的生命周期时，需要手动标注生命周期。</p><h3 id="生命周期标注语法">19.1 生命周期标注语法</h3><p>Rust使用泛型生命周期的语法进行标注。其中用<code>&lt;'a&gt;</code>泛型声明生存周期，在引用号<code>&amp;</code>后紧跟生存周期进行标注，如<code>&amp;'a i32</code>、<code>&amp;'a mut i32</code>。生命周期的标注仅描述多个引用的生命周期之间的关系，但不影响具体的生命周期。</p><ul><li>函数的生命周期</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longer</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>&#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 声明存在一个生命周期 &#x27;a</span><br><span class="hljs-comment">// 参数x y 与返回值 return_value 的生命周期均不短于&#x27;a</span><br><span class="hljs-comment">// 这里在调用函数的时候，&#x27;a获得的是 x y生命周期重叠的部分</span><br></code></pre></td></tr></table></figure><ul><li>结构体的生命周期</li></ul><p>结构体以引用作为字段类型时，必须标注生命周期，因为需要保证当结构体实例有效时，其引用也应当有效。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;&#123;<br>    field: &amp;<span class="hljs-symbol">&#x27;a</span> type_name,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生命周期的省略">19.2 生命周期的省略</h3><p>Rust编译器使用以下三个规则依次检查<code>fn</code>定义或<code>impl</code>块，若不能判断生命周期，则编译报错需要手动标注生命周期。</p><ul><li>输入参数的每个引用类型参数都有自己的生命周期</li><li>如果只有一个输入生命周期参数，则将该生命周期赋给所有输出生命周期参数</li><li>如果有多个输入生命周期参数，但其中有<code>&amp;self</code>或<code>&amp;mut self</code>是方法，则将该生命周期赋给所有输出生命周期参数</li></ul><h3 id="方法的生命周期标注">19.3 方法的生命周期标注</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;&#123;<br>    field: &amp;<span class="hljs-symbol">&#x27;a</span> type_name,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; struct_name&lt;<span class="hljs-symbol">&#x27;a</span>&gt;&#123;<br>    <span class="hljs-comment">// impl块的&lt;&#x27;a&gt;不能省略</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>, s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>        <span class="hljs-keyword">self</span>.field<br>    &#125;<br>    <span class="hljs-comment">// 根据规则省略生命周期标注</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态生命周期">19.4 静态生命周期</h3><p><code>'static</code>生命周期指整个程序的持续时间，保证不被移除作用域。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_hello_str</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>&#123;<br>    <span class="hljs-string">&quot;Hello&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包">20. 闭包</h2><p>闭包是可以保存进变量或作为参数传递给其他函数的匿名函数。不同于函数，闭包允许捕获调用者作用域中的值。</p><h3 id="闭包的定义">20.1 闭包的定义</h3><p>匿名函数一般不需要指定函数参数与返回值类型。且可以访问上文中声明的变量，也就是从所在环境中捕获值。编译器自动判断以何种方式捕获，（获得所有权、可变或不可变引用），或以<code>move</code>关键字强制获得所有权移动。该技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = |x, y|&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = |x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = x + y;<br>    a * <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-comment">// 没有返回类型标注并且只有一行代码时可以省略花括号</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = |x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>| x + y;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = |x, y| x + y;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = || s;<br><span class="hljs-title function_ invoke__">lambda</span>(); <span class="hljs-comment">// ok, return s with ownership</span><br><span class="hljs-title function_ invoke__">lambda</span>(); <span class="hljs-comment">// failed, moved out</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = |ss: S| s;<br><span class="hljs-title function_ invoke__">lambda</span>(); <span class="hljs-comment">// ok, return s with ownership</span><br><span class="hljs-title function_ invoke__">lambda</span>(); <span class="hljs-comment">// failed, moved out</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">equal_to_x</span> = <span class="hljs-keyword">move</span> |z| z == x; <span class="hljs-comment">// ownership moved into closure</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, x); <span class="hljs-comment">// invalid visit to x</span><br><span class="hljs-built_in">assert!</span>(<span class="hljs-title function_ invoke__">equal_to_x</span>(y)); <span class="hljs-comment">// ok</span><br><span class="hljs-built_in">assert!</span>(<span class="hljs-title function_ invoke__">equal_to_x</span>(y)); <span class="hljs-comment">// invalid because x in closure has been dropped after previous call</span><br></code></pre></td></tr></table></figure><h3 id="fn-trait与结构体">20.2 <code>Fn Trait</code>与结构体</h3><p>即使两个闭包有完全相同的签名也属于不同的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lambda</span> = |x, y| x + y;<br>lambda = |x, y| x + y; <span class="hljs-comment">// failed</span><br></code></pre></td></tr></table></figure><p>由于闭包能从所在环境中捕获值，而获得值的方法存在获得所有权、可变借用、不可变借用的区别，所以闭包之间存在区别。</p><p>所有的闭包都实现了以下<code>Trait</code>中的一个：</p><ul><li>取得捕获值的所有权：所有闭包都能实现<code>FnOnce</code></li><li>可变借用：没有移动捕获值的实现了<code>FnMut</code></li><li>不可变借用：无需可变访问捕获值的实现了<code>Fn</code></li></ul><p>结构体持有闭包时因为不能指定类型所以需要使用<code>Trait bound</code>实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cacher</span>&lt;T&gt;<br><span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span><br>&#123;<br>    calc: T,<br>    key: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;,<br>    value: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculation</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Calculating...&quot;</span>);<br>    x.<span class="hljs-title function_ invoke__">pow</span>(<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt; <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(func: T) <span class="hljs-punctuation">-&gt;</span> Cacher&lt;T&gt;&#123;<br>        <span class="hljs-keyword">return</span> Cacher&#123;<br>            calc: func,<br>            key: <span class="hljs-type">Option</span>::<span class="hljs-literal">None</span>,<br>            value: <span class="hljs-type">Option</span>::<span class="hljs-literal">None</span><br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">visit</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.key &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(key) =&gt; &#123;<br>                <span class="hljs-keyword">if</span> key == x&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.value.<span class="hljs-title function_ invoke__">unwrap</span>();<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = (<span class="hljs-keyword">self</span>.calc)(x);<br>                    <span class="hljs-keyword">self</span>.key = <span class="hljs-title function_ invoke__">Some</span>(x);<br>                    <span class="hljs-keyword">self</span>.value = <span class="hljs-title function_ invoke__">Some</span>(c);<br>                    <span class="hljs-keyword">return</span> c;<br>                &#125;<br>            &#125;,<br>            <span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = (<span class="hljs-keyword">self</span>.calc)(x);<br>                <span class="hljs-keyword">self</span>.key = <span class="hljs-title function_ invoke__">Some</span>(x);<br>                <span class="hljs-keyword">self</span>.value = <span class="hljs-title function_ invoke__">Some</span>(c);<br>                <span class="hljs-keyword">return</span> c;<br>            &#125;,<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cacher</span> = Cacher::<span class="hljs-title function_ invoke__">new</span>(calculation);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Returns: &#123;&#125;&quot;</span>, cacher.<span class="hljs-title function_ invoke__">visit</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// calculating... 4</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Returns: &#123;&#125;&quot;</span>, cacher.<span class="hljs-title function_ invoke__">visit</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 4</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Returns: &#123;&#125;&quot;</span>, cacher.<span class="hljs-title function_ invoke__">visit</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// calculating... 16</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Returns: &#123;&#125;&quot;</span>, cacher.<span class="hljs-title function_ invoke__">visit</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// calculating... 25</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="迭代器">21. 迭代器</h2><h3 id="iterator-trait">21.1 <code>Iterator Trait</code></h3><p><code>Iterator Trait</code>要求实现<code>next</code>方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>    <span class="hljs-comment">// 此处省略了方法的默认实现</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代器的创建">21.2 迭代器的创建</h3><p>Rust迭代器属于惰性迭代器，在创建但不访问时不会有任何效果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">iter</span> = v.<span class="hljs-title function_ invoke__">iter</span>(); <span class="hljs-comment">// 引用</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">iter_mut</span> = v.<span class="hljs-title function_ invoke__">iter_mut</span>(); <span class="hljs-comment">// 可变引用</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">into_iter</span> = v.<span class="hljs-title function_ invoke__">into_iter</span>(); <span class="hljs-comment">// 获得所有权</span><br></code></pre></td></tr></table></figure><h3 id="迭代器的使用">21.3 迭代器的使用</h3><h4 id="next方法">21.3.1 <code>next</code>方法</h4><p><code>next</code>方法实现的是对迭代器获得下一个项目，需要迭代器本身是可变的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">iter</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_ invoke__">iter</span>();<br><span class="hljs-built_in">assert_eq!</span>(iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-number">1</span>);<br><span class="hljs-built_in">assert_eq!</span>(iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-number">2</span>);<br><span class="hljs-built_in">assert_eq!</span>(iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-number">3</span>);<br><span class="hljs-built_in">assert_eq!</span>(iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p><code>next</code>返回包裹元素类型的<code>Option&lt;type_name&gt;</code>枚举，在返回所有元素后返回<code>None</code>。</p><h4 id="for语句">21.3.2 <code>for</code>语句</h4><p><code>for</code>语句可以自动将可迭代对象转换为可变的迭代器对象，并对返回的<code>Option</code>解包。</p><h3 id="迭代器的转换">21.4 迭代器的转换</h3><ul><li><code>map</code>方法接收一个闭包将一个迭代器转化为另一个，可以使用<code>collect</code>转化为其他的类型。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x|&#123;x + <span class="hljs-number">1</span>&#125;);<br><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x + <span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure><ul><li><code>filter</code>方法接收一个返回值为<code>bool</code>的闭包，将为<code>true</code>的元素组成一个新的迭代器。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = (<span class="hljs-number">0</span>..<span class="hljs-number">100</span>).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">clone</span>().<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|x|&#123;x % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>&#125;).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure><ul><li><code>zip</code>方法接收另一个同等长度的迭代器，将两个迭代器的元素组成一对对<code>Tuple</code>作为元素返回迭代器。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">iter</span> = v1.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">zip</span>(v2.<span class="hljs-title function_ invoke__">into_iter</span>());<br></code></pre></td></tr></table></figure><h3 id="实现-iterator-trait-来创建自定义迭代器">21.5 实现<code>Iterator trait</code> 来创建自定义迭代器</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span>&lt;T&gt; &#123;<br>    storage: <span class="hljs-type">Vec</span>&lt;T&gt;,<br>    counter: <span class="hljs-type">usize</span>,<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; Counter&lt;T&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(v: <span class="hljs-type">Vec</span>&lt;T&gt;) <span class="hljs-punctuation">-&gt;</span> Counter&lt;T&gt; &#123;<br>        Counter &#123; storage: v, counter: <span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>&#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&lt;T&gt; <br><span class="hljs-keyword">where</span> T: <span class="hljs-built_in">Clone</span><br>&#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = T;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;&#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.counter &gt;= <span class="hljs-keyword">self</span>.storage.<span class="hljs-title function_ invoke__">len</span>()&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Option</span>::&lt;<span class="hljs-keyword">Self</span>::Item&gt;::<span class="hljs-literal">None</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">self</span>.counter += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Option</span>::&lt;<span class="hljs-keyword">Self</span>::Item&gt;::<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>.storage[<span class="hljs-keyword">self</span>.counter-<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">clone</span>())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="智能指针">22. 智能指针</h2><p>智能指针是一类数据结构，它们的表现类似指针，但是也拥有额外的元数据和功能。普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针拥有它们指向的数据。</p><p>智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了<code>Deref trait</code> 和 <code>Drop trait</code>。</p><p><code>Deref trait</code>允许智能指针结构体实例表现的像引用一样。</p><p><code>Drop trait</code>允许我们自定义当智能指针离开作用域时运行的代码。</p><h3 id="boxt">22.1 <code>Box&lt;T&gt;</code></h3><p>在stack上存有一个指向一块heap内存的指针。大多应用于：</p><ul><li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li><li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li><li>当希望拥有一个值并只关心它的类型是否实现了特定 trait而不是其具体类型的时候</li></ul><h4 id="boxt的创建">22.1.1<code>Box&lt;T&gt;</code>的创建</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_box</span>&lt;T&gt;(b: <span class="hljs-type">Box</span>&lt;T&gt;) <span class="hljs-keyword">where</span> T: Display&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b);<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br><span class="hljs-title function_ invoke__">print_box</span>(x); <span class="hljs-comment">// ok</span><br><span class="hljs-title function_ invoke__">print_box</span>(x); <span class="hljs-comment">// failed moved out</span><br></code></pre></td></tr></table></figure><h3 id="递归类型">22.2 递归类型</h3><p>当一个结构体或枚举的一个字段的类型涉及到它本身，称为递归类型。因为不能在编译的时候确定递归何时会结束，不能确定具体的内存大小，所以Rust不能编译通过这样的代码。可以使用<code>Box&lt;T&gt;</code>解决。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">enum_name</span>&#123;<br>    <span class="hljs-title function_ invoke__">Node</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">Box</span>&lt;enum_name&gt;),<br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = enum_name::<span class="hljs-title function_ invoke__">Node</span>(<br>        <span class="hljs-number">1</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<br>            enum_name::<span class="hljs-title function_ invoke__">Node</span>(<br>                <span class="hljs-number">2</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<br>                    enum_name::Nil<br>                )<br>            )<br>        )<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="deref-trait">22.3 <code>Deref Trait</code></h3><p>自定义解引用运算符，返回一个引用，使得能够使用<code>*</code>运算符。<code>*x -&gt; *x.deref())</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt;(T);<br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>        <span class="hljs-title function_ invoke__">MyBox</span>(x)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(x);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(x);<br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x); <span class="hljs-comment">// ok</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y); <span class="hljs-comment">// ok</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *z); <span class="hljs-comment">// ok since MyBox impl Deref: *z -&gt; (*(z.deref()))</span><br></code></pre></td></tr></table></figure><h3 id="derefmut-trait">22.4 <code>DerefMut Trait</code></h3><p>Rust 提供了 <code>DerefMut Trait</code> 用于重载可变引用的<code>*</code> 运算符。</p><h3 id="解引用强制转换">22.5 解引用强制转换</h3><p>解引用强制转换<code>Defer Coercion</code>发生在实现了<code>Defer Trait</code>的类型需要解引用的时候。解引用强制转换可以将一个类型的表达式<code>*T</code>通过隐式调用<code>deref</code>方式转换成<code>*(T.deref())</code>，但Rust编译器只会如此操作一次，不会无限递归转换。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(x);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(MyBox::<span class="hljs-title function_ invoke__">new</span>(x));<br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x); <span class="hljs-comment">// ok</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, y); <span class="hljs-comment">// failed due to inconsistent type</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y); <span class="hljs-comment">// ok: *y -&gt; *(y.deref()) -&gt; *(&amp;int)</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *z); <span class="hljs-comment">// failed since deref coercion happens only once</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *(*z.<span class="hljs-title function_ invoke__">deref</span>())); <span class="hljs-comment">// ok: *(*z.deref()) -&gt; *(*&amp;MyBox) -&gt; *MyBox -&gt; deref coercion</span><br></code></pre></td></tr></table></figure><p>在这种以下这些情况，Rust执行<code>Deref Coercion</code>：</p><ul><li>实现了<code>T: Deref&lt;Target=U&gt;</code>的，允许<code>&amp;T</code>转换为<code>&amp;U</code></li><li>实现了<code>T: DerefMut&lt;Target=U&gt;</code>的，允许<code>&amp;mut T</code>转换为<code>&amp;mut U</code></li><li>实现了<code>T: Deref&lt;Target=U&gt;</code>的，允许<code>&amp;mut T</code>转换为<code>&amp;U</code></li></ul><h3 id="自动解引用">22.6 自动解引用</h3><p>自动解引用也是与<code>Deref Trait</code>有关。Rust编译器会不断给<code>&amp;type</code>（<code>type</code>也可以是引用）添加<code>*</code>成为<code>&amp;*type</code>、<code>&amp;**type</code>、<code>&amp;***type</code>等，使得得到一个符合函数签名所需要的引用类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_equal</span>(a: &amp;<span class="hljs-type">i32</span>, b: &amp;<span class="hljs-type">i32</span>)&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a==b);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(MyBox::<span class="hljs-title function_ invoke__">new</span>(x));<br>    <span class="hljs-title function_ invoke__">is_equal</span>(&amp;<span class="hljs-number">5</span>, &amp;y); <span class="hljs-comment">// ok</span><br>    <span class="hljs-title function_ invoke__">is_equal</span>(&amp;&amp;<span class="hljs-number">5</span>, &amp;&amp;&amp;&amp;y); <span class="hljs-comment">// ok</span><br>    <span class="hljs-title function_ invoke__">is_equal</span>(&amp;<span class="hljs-number">5</span>, &amp;(*y)); <span class="hljs-comment">// ok</span><br>    <span class="hljs-title function_ invoke__">is_equal</span>(&amp;<span class="hljs-number">5</span>, &amp;(**y)); <span class="hljs-comment">// ok</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="drop-trait">22.7 <code>Drop Trait</code></h3><p>实现<code>Drop Trait</code>可以定义值将要离开作用域时发生的作用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Rust不允许手动调用<code>drop</code>方法，但可以使用<code>drop()</code>函数提前释放值。</p><h3 id="rct">22.8 <code>Rc&lt;T&gt;</code></h3><p><code>Rc&lt;T&gt;</code>结构体指引用计数，可以实现一块值的多重所有权。通过不可变引用，<code>Rc&lt;T&gt;</code>允许在程序的多个部分之间只读地共享数据。<code>Rc&lt;T&gt;</code>实例不可变引用这个块的值，并记录不可变引用的次数。<code>Rc&lt;T&gt;</code>只能用于单线程。</p><h4 id="rct的创建">22.8.1 <code>Rc&lt;T&gt;</code>的创建</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)); <span class="hljs-comment">// new value here</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a); <span class="hljs-comment">// reference here counter++</span><br></code></pre></td></tr></table></figure><h4 id="rct的销毁">22.8.2 <code>Rc&lt;T&gt;</code>的销毁</h4><p>每个<code>Rc&lt;T&gt;</code>实例离开作用域时，对引用次数减一。当没有引用时，值也离开作用域。</p><h3 id="refcellt">22.8 <code>RefCell&lt;T&gt;</code></h3><p>实现不可变对象但能够修改内部值的效果，可以在“违背”借用规则的情况下通过编译。但注意，仍需要保证对内存的借用规则，否则会在运行时<code>panic</code>。</p><p><code>RefCell&lt;T&gt;</code>记录存在多少个活跃的<code>Ref&lt;T&gt;</code>与<code>RefMut&lt;T&gt;</code>智能指针：</p><ul><li>调用<code>borrow</code>方法不可变借用计数加1，返回<code>Ref&lt;T&gt;</code></li><li>调用<code>borrow_mut</code>方法可变借用计数加1，返回<code>RefMut&lt;T&gt;</code></li><li><code>Ref&lt;T&gt;</code>离开作用域，不可变借用计数减1</li><li><code>RefMut&lt;T&gt;</code>离开作用域，可变借用计数减1</li></ul><p>需要根据可变借用与不可变借用计数器保证，在运行时对同块内存符合借用规则，否则会报错。</p><h4 id="refcellt的创建">22.8.1 <code>RefCell&lt;T&gt;</code>的创建</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><h4 id="refcellt的使用">22.8.2 <code>RefCell&lt;T&gt;</code>的使用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v_borrow</span> = v.<span class="hljs-title function_ invoke__">borrow</span>(); <span class="hljs-comment">// Ref&lt;type_name&gt;</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v_borrow_mut</span> = v.<span class="hljs-title function_ invoke__">borrow_mut</span>(); <span class="hljs-comment">// RefMut&lt;type_name&gt;</span><br><span class="hljs-title function_ invoke__">drop</span>(v_borrow); <span class="hljs-comment">// move out immutable borrow, otherwise violate borrow rule and panic during runtime</span><br>*v_borrow_mut += <span class="hljs-number">1</span>; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><h4 id="结合rc和refcell来拥有多个可变数据所有者">22.8.3结合<code>Rc</code>和<code>RefCell</code>来拥有多个可变数据所有者</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="hljs-type">i32</span>&gt;&gt;, Rc&lt;List&gt;),<br>    Nil,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;value), Rc::<span class="hljs-title function_ invoke__">new</span>(Nil)));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-title function_ invoke__">Cons</span>(Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>)), Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-title function_ invoke__">Cons</span>(Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">4</span>)), Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br><br>    *value.<span class="hljs-title function_ invoke__">borrow_mut</span>() += <span class="hljs-number">10</span>;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a after = &#123;:?&#125;&quot;</span>, a);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;b after = &#123;:?&#125;&quot;</span>, b);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;c after = &#123;:?&#125;&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="boxrcrefcell比较">22.9 <code>Box/Rc/RefCell</code>比较</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><code>Box&lt;T&gt;</code></th><th style="text-align: center;"><code>Rc&lt;T&gt;</code></th><th style="text-align: center;"><code>RefCell&lt;T&gt;</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">同一块数据的所有者</td><td style="text-align: center;">一个</td><td style="text-align: center;">多个</td><td style="text-align: center;">一个</td></tr><tr class="even"><td style="text-align: center;">可变性</td><td style="text-align: center;">可变、不可变借用</td><td style="text-align: center;">不可变借用</td><td style="text-align: center;">可变、不可变借用</td></tr><tr class="odd"><td style="text-align: center;">借用检查</td><td style="text-align: center;">编译时</td><td style="text-align: center;">编译时</td><td style="text-align: center;">运行时</td></tr></tbody></table><h3 id="引用循环">22.10 引用循环</h3><p><code>Rc&lt;T&gt;</code>的<code>clone</code>方法增加强引用计数器<code>Rc::strong_count</code>的方法保存分享所有权的个数，当强引用为0的时候可以将它安全释放。但如果<code>Rc&lt;T&gt;</code>的强引用涉及循环，则不能安全地将强引用减到0，则这部分空间不能释放。</p><p>使用<code>Weak&lt;T&gt;</code>避免这个问题。<code>Rc::downgrade(&amp;Rc&lt;T&gt;)</code>方法获得一个<code>Weak&lt;T&gt;</code>，并增加<code>Rc::weak_count</code>，它不为0不会阻止释放空间。使用<code>Weak&lt;T&gt;</code>前需要调用<code>upgrade()</code>方法返回<code>Option&lt;Rc&lt;T&gt;&gt;</code>以确保存在。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;42&quot;</span>));<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Rc::<span class="hljs-title function_ invoke__">downgrade</span>(&amp;a);<br><span class="hljs-title function_ invoke__">drop</span>(a);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b.<span class="hljs-title function_ invoke__">upgrade</span>().<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// failed due to moved-out a</span><br></code></pre></td></tr></table></figure><h2 id="高级rust特性">23. 高级Rust特性</h2><h3 id="unsafe-rust">23.1 Unsafe Rust</h3><p>不安全的Rust不提供强制的内存安全保障。但没有停用借用检查，或其他的安全检查。在<code>unsafe</code>环境中可以：</p><ul><li><p>解引用原始指针</p><p>允许多个可变不可变指针同时指向同一内存，忽略借用规则，无法保证指向合理内存，可能为<code>null</code>并且不能自动清理内存。</p><ul><li>可变的：<code>*mut T</code></li><li>不可变的：<code>*const T</code>解引用后不能直接赋值</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">ptr0</span> = &amp;num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">ptr1</span> = &amp;<span class="hljs-keyword">mut</span> num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">address</span> = <span class="hljs-number">0x12345usize</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">ptr2</span> = address <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>;<br><span class="hljs-keyword">unsafe</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, *ptr0); <span class="hljs-comment">// ok</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, *ptr1); <span class="hljs-comment">// ok</span><br>    *ptr1 += <span class="hljs-number">1</span>; <span class="hljs-comment">// ok but not allowed by borrow rule in safe code</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, *ptr2); <span class="hljs-comment">// pass compilation but maybe runtime error</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用<code>unsafe</code>函数或方法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function_name0</span>()&#123;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function_name1</span>()&#123;<br>    <span class="hljs-keyword">unsafe</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">unsafe</span>&#123;<br>        <span class="hljs-title function_ invoke__">function_name0</span>();<br>    &#125;<br>    <span class="hljs-title function_ invoke__">function_name1</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>访问或修改可变的静态变量</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNTER: <span class="hljs-type">u32</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_count</span>(inc: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        COUNTER += inc;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">add_to_count</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现<code>unsafe trait</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name</span>&#123;<br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>();<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>(<span class="hljs-type">i32</span>);<br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>() &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有些时候我们能够确认一些代码是内存安全的，但Rust编译器不能分析出其中的内存借用关系而直接拒绝通过编译，这时候可以使用<code>unsafe</code>绕过，但我们必须手动保证内存的安全性。</p><p>例子：将一个切片的可变引用在某处切开返回</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">split_at_mut</span>(slice: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], mid: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> (&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>]) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = slice.<span class="hljs-title function_ invoke__">len</span>();<br>    <span class="hljs-built_in">assert!</span>(mid &lt;= len);<br>    (&amp;<span class="hljs-keyword">mut</span> slice[..mid], &amp;<span class="hljs-keyword">mut</span> slice[mid..]) <span class="hljs-comment">// failed: slice mutable borrow twice</span><br>&#125;<br><br><br><span class="hljs-comment">// ok</span><br><span class="hljs-keyword">use</span> std::slice;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">split_at_mut</span>(slice: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], mid: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> (&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>]) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = slice.<span class="hljs-title function_ invoke__">len</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ptr</span> = slice.<span class="hljs-title function_ invoke__">as_mut_ptr</span>();<br>    <span class="hljs-built_in">assert!</span>(mid &lt;= len);<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        (slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(ptr, mid),<br>         slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="hljs-title function_ invoke__">add</span>(mid), len - mid))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高级trait">23.2 高级<code>Trait</code></h3><h4 id="关联类型">23.2.1 关联类型</h4><p>关联类型是<code>Trait</code>中的类型占位符，可以用于<code>Trait</code>方法的签名中。</p><p>与泛型的区别：</p><ul><li>泛型在实现<code>Trait</code>时需要标注类型，关联类型不需要</li><li>泛型可以为一个类型指定不同的泛型参数来多次实现某个<code>Trait</code>，关联参数不能</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span>&#123;&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator0</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>; <span class="hljs-comment">// Item: 类型占位符</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator1</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt;;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator0</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = type_name;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// failed</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator0</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = another_type_name;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator1</span>&lt;type_name&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;type_name&gt;&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator1</span>&lt;another_type_name&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;another_type_name&gt;&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运算符重载与默认泛型参数">23.2.2 运算符重载与默认泛型参数</h4><p>Rust不允许自定义运算符，但可以通过实现<code>std::ops</code>中的<code>Trait</code>来定义一部分运算符的行为。</p><p>这里涉及到默认泛型参数<code>&lt;PlaceholderType=ConcreteType&gt;</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Add</span>&lt;RHS=<span class="hljs-keyword">Self</span>&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, rhs: RHS) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>::Output;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Point;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Point) <span class="hljs-punctuation">-&gt;</span> Point &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x + other.x,<br>            y: <span class="hljs-keyword">self</span>.y + other.y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">0</span> &#125; + Point &#123; x: <span class="hljs-number">2</span>, y: <span class="hljs-number">3</span> &#125;,<br>               Point &#123; x: <span class="hljs-number">3</span>, y: <span class="hljs-number">3</span> &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Add;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Millimeters</span>(<span class="hljs-type">u32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Meters</span>(<span class="hljs-type">u32</span>);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span>&lt;Meters&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Millimeters</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Millimeters;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Meters) <span class="hljs-punctuation">-&gt;</span> Millimeters &#123;<br>        <span class="hljs-title function_ invoke__">Millimeters</span>(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> + (other.<span class="hljs-number">0</span> * <span class="hljs-number">1000</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完全限定语法与同名函数与方法">23.2.3完全限定语法与同名函数与方法</h4><p>完全限定语法（Fully QualifiedSyntax）：<code>&lt;type_name as trait_name&gt;::function(receiver_if_method, arg)</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name0</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>();<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name1</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>();<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">strcut_name</span>&#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name0</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">strcut_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;trait_name0::method&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;trait_name0::function&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name1</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">strcut_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;trait_name1::method&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;trait_name1::function&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">strcut_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;strcut_name::method&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;strcut_name::function&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = strcut_name&#123;&#125;;<br>    v.<span class="hljs-title function_ invoke__">method</span>(); <span class="hljs-comment">// strcut_name::method</span><br>    trait_name0::<span class="hljs-title function_ invoke__">method</span>(&amp;v); <span class="hljs-comment">// trait_name0::method</span><br>    trait_name1::<span class="hljs-title function_ invoke__">method</span>(&amp;v); <span class="hljs-comment">// trait_name1::method</span><br>    <br>    strcut_name::<span class="hljs-title function_ invoke__">function</span>(); <span class="hljs-comment">// strcut_name::function</span><br>    &lt;strcut_name <span class="hljs-keyword">as</span> trait_name0&gt;::<span class="hljs-title function_ invoke__">function</span>(); <span class="hljs-comment">// trait_name0::method 完全限定语法</span><br>    &lt;strcut_name <span class="hljs-keyword">as</span> trait_name1&gt;::<span class="hljs-title function_ invoke__">function</span>(); <span class="hljs-comment">// trait_name1::method 完全限定语法</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="supertrait">23.2.4 Supertrait</h4><p>有时我们可能会需要某个<code>Trait</code>使用另一个<code>Trait</code>的功能。在这种情况下，需要能够依赖相关的<code>Trait</code>也被实现。该<code>Trait</code>为当前<code>Trait</code>的<code>Super Trait</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name</span>: supertrait_name&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-comment">// visit method of self as supertrait</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用newtype绕过孤儿规则">23.2.5 使用newtype绕过孤儿规则</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> outer_trait;<br><span class="hljs-keyword">use</span> outer_struct;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span>(outer_struct); <span class="hljs-comment">// newtype</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">outer_trait</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">outer_struct</span>&#123;<br>    <span class="hljs-comment">// pass </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高级类型">23.3 高级类型</h3><h4 id="类型别名">23.3.1 类型别名</h4><p>为一个已经存在的类型生成一个别名同义词，而不是定义一个新的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">my_type</span> = something;<br></code></pre></td></tr></table></figure><h4 id="never类型">23.3.2 Never类型</h4><p>Never类型（<code>!</code>类型）没有任何值，是空类型，在不返回值的函数中充当返回类型，注意与<code>()</code>返回类型区别。</p><p>不返回值的函数，也就是返回<code>!</code>的函数称为发散函数。返回的<code>!</code>可以强制转换为其他类型以通过编译。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// ok</span><br><span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-comment">// return type of each arm shall be same</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>: <span class="hljs-type">u32</span> = <span class="hljs-keyword">match</span> guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>() &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>        <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">continue</span>, <span class="hljs-comment">// return ! and coerced into needed type to pass compilation</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// ok</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">match</span> <span class="hljs-number">1</span> &#123;<br>    <span class="hljs-number">1</span>|<span class="hljs-number">2</span>|<span class="hljs-number">3</span>|<span class="hljs-number">4</span> =&gt; <span class="hljs-number">42</span>,<br>    _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Error&quot;</span>), <span class="hljs-comment">// return !</span><br>&#125;;<br></code></pre></td></tr></table></figure><!--TODO：动态大小与Sized Trait, ?Sized Trait约束--><h4 id="高级函数与闭包">23.3.3 高级函数与闭包</h4><p>函数可以作为函数指针传入接收<code>fn</code>类型参数的函数。函数在传递过程中会被强制转换成<code>fn</code>类型。</p><p>函数指针实现了所有三个闭包的<code>Trait</code>（<code>Fn</code>、<code>FnMut</code>和<code>FnOnce</code>），可以向需要闭包的函数参数传递函数指针。</p><p>闭包在没有捕获环境变量的情况下可以传给需要函数指针参数的函数，但若闭包捕获了环境变量则不能这么做。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_one</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    x + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">wrapper</span>(func: <span class="hljs-title function_ invoke__">fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>, arg: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    <span class="hljs-title function_ invoke__">func</span>(arg)<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-title function_ invoke__">wrapper</span>(add_one, <span class="hljs-number">41</span>);<br></code></pre></td></tr></table></figure><p>闭包由于不具有具体的编译时大小所以不能在不使用泛型或<code>Trait</code>的前提下作为参数传入或返回。可以使用<code>Box&lt;T&gt;</code>解决。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">returns_closure</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&gt; &#123;<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(|x| x + <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="宏">23.4 宏</h4><p>宏编程与一般的Rust编程有较大差别，本文暂不涉及。</p><blockquote><p><a href="https://danielkeep.github.io/tlborm/book/index.html"><em>TheLittle Book of Rust Macros</em></a></p></blockquote><h2 id="自动化测试">24. 自动化测试</h2><h3 id="编写与运行测试">24.1 编写与运行测试</h3><p>Rust的测试通过函数来实现，测试函数体通常执行三个操作：</p><ul><li>准备测试数据或测试状态</li><li>运行被测试的代码</li><li>断言结果</li></ul><p>通过对函数添加<code>#[test]</code>属性将一个函数标记为测试函数。执行<code>cargo test</code>命令构建一个<code>Test Runner</code>创建线程调用标注了<code>#[test]</code>的函数并报告是否通过了测试。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_one</span>(x: <span class="hljs-type">i32</span>)<span class="hljs-punctuation">-&gt;</span><span class="hljs-type">i32</span>&#123;<br>    x + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span> <span class="hljs-comment">// 标记该模块只在测试时编译</span><br><span class="hljs-keyword">mod</span> test&#123;<br>    <span class="hljs-meta">#[test]</span> <span class="hljs-comment">// 标记为测试函数</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_add_one</span>()&#123;<br>        <span class="hljs-built_in">assert_eq!</span>(super::<span class="hljs-title function_ invoke__">add_one</span>(<span class="hljs-number">41</span>), <span class="hljs-number">42</span>); <span class="hljs-comment">// panic即为测试失败</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="断言">24.2 断言</h3><ul><li><p><code>assert!()</code></p><p>接受一个<code>bool</code>值，为<code>true</code>时通过，为<code>false</code>时调用<code>panic!</code>，测试失败。</p></li><li><p><code>assert_eq!()</code></p><p>接受两个值，断言相等，自动打印两个值，需要实现<code>PartialEq Trait</code>与<code>Debug Trait</code></p></li><li><p><code>asser_ne!()</code></p><p>接受两个值，断言不相等，自动打印两个值，需要实现<code>PartialEq Trait</code>与<code>Debug Trait</code></p></li></ul><h3 id="自定义信息">24.3 自定义信息</h3><p>可以对上述三个断言宏再添加一个自定义信息作为错误信息打印。自定义信息会被传给<code>format!</code>宏，所以可以使用占位符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ###rust">#[test]<br>fn test_add_one()&#123;<br>    let num = super::add_one(40);<br>    assert!(num==41, &quot;Oh no!!!&quot;);<br>    assert!(num==42, &quot;Oh no, it is &#123;&#125;&quot;, num);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试需要panic的情况">24.4 测试需要<code>panic</code>的情况</h3><p>一般地，测试代码一旦<code>panic</code>即被判定测试失败，但有时需要测试代码应当在非法的情况下<code>panic</code>，可以对测试函数添加<code>#[should_panic]</code>属性，此时测试代码未<code>panic</code>则未能通过，触发<code>panic</code>才能通过测试。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">visit</span>(v: &amp;[<span class="hljs-type">i32</span>], i:<span class="hljs-type">i32</span>)<span class="hljs-punctuation">-&gt;</span><span class="hljs-type">i32</span>&#123;<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Index UnderFlow&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i &gt;= v.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Index Overflow&quot;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        v[i <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">mod</span> test&#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test</span>()&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = &amp;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>        super::<span class="hljs-title function_ invoke__">visit</span>(v, -<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要区别<code>panic</code>的类型，可在<code>#[should_panic]</code>属性后添加<code>expected</code>字段：<code>#[should_panic(expected="panic_message")]</code>，若<code>panic</code>消息中包含<code>panic_message</code>才能通过测试。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[should_panic(expected=<span class="hljs-string">&quot;Overflow&quot;</span>)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test</span>()&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用resultt-e枚举测试">24.5使用<code>Result&lt;T, E&gt;</code>枚举测试</h3><p>当测试函数用<code>Result&lt;T,E&gt;</code>枚举进行测试时，可以不出发<code>panic</code>完成测试目的，当返回<code>Result::Ok</code>时测试通过，返回<code>Result::Err</code>测试失败。此时<code>#[should_panic]</code>标签不能使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span> == <span class="hljs-number">4</span> &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;two plus two does not equal four&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="控制测试运行">24.6 控制测试运行</h3><p>默认地，<code>cargo test</code>：</p><ul><li>多线程并行运行各个测试</li><li>测试所有测试函数</li><li>在测试通过时，不显示标准输出<code>println!</code>等</li></ul><p>运行<code>cargo test --help</code>获取可以直接跟在<code>cargo test</code>后的开关，一般针对<code>cargo test</code>。</p><p>运行<code>cargo test -- --help</code>获取可以跟在<code>cargo test --</code>后的开关，一般针对测试用二进制文件。</p><p>以下为几个常见的开关：</p><ul><li><p><code>--test-threads</code></p><p>控制测试进程个数：<code>cargo test -- --test-threads=1</code></p></li><li><p><code>--show-output</code></p><p>在测试通过时也显示标准输出：<code>cargo test -- --show-output</code></p></li></ul><h3 id="按名称运行测试">24.7 按名称运行测试</h3><p>可以通过指定需要运行的测试函数名（或其一部分）或需要运行的测试模块名（或其一部分）或需要运行的集成测试<code>crate</code>名（或其一部分）运行部分测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo <span class="hljs-built_in">test</span> test_mod_name<br>cargo <span class="hljs-built_in">test</span> test_func_name<br>cargo <span class="hljs-built_in">test</span> half_test_mod_name<br>cargo <span class="hljs-built_in">test</span> half_test_func_name<br></code></pre></td></tr></table></figure><h3 id="忽略测试">24.8 忽略测试</h3><p>可为某些测试函数添加<code>#[ignore]</code>属性忽略该测试，而完成余下的测试。</p><p>执行<code>cargo test -- --ignored</code>运行被忽略的测试，过滤未忽略的测试。</p><h3 id="单元测试与集成测试">24.9 单元测试与集成测试</h3><p>单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，通常测试代码放在<code>./src/</code>文件夹下，并为专门用于测试的模块添加属性<code>#[test]</code>。</p><p>集成测试的目的是将各个模块组合起来测试，完全独立于被测试库之外，需要手动导入。集成测试代码文件均存放于<code>./tests/</code>下，每个测试文件都是一个单独的测试用<code>crate</code>，不需要标记<code>#[cfg(test)]</code>。</p><p>如果项目是没有<code>./src/lib.rs</code>，只有<code>./src/main.rs</code>的<code>binary crate</code>，则不能使用<code>./tests/</code>创建集成测试。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// file: ./tests/common.rs</span><br><span class="hljs-comment">// would be run in test, not recommanded</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">setup</span>&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br><br><span class="hljs-comment">// file: ./tests/common/mod.rs</span><br><span class="hljs-comment">// better one</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">setup</span>&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br><br><span class="hljs-comment">// file: ./tests/test_crate0.rs</span><br><span class="hljs-keyword">use</span> package_name::*;<br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_function0</span>&#123;<br>    common::<span class="hljs-title function_ invoke__">setup</span>()<br>    <span class="hljs-comment">// pass</span><br>&#125;<br><br><span class="hljs-comment">// file: ./tests/test_crate1.rs</span><br><span class="hljs-keyword">use</span> package_name::*;<br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_function1</span>&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并发与并行">25. 并发与并行</h2><ul><li>并发（<em>Concurrent</em>）：程序的不同部分独立执行</li><li>并行（<em>Parallel</em>）：程序的不同部分同时执行</li></ul><p>Rust可以在没有细微bug的情况下无畏并发，Rust的并发泛指并发与并行。Rust的标准库支持的是一个Rust语言进程对于一个操作系统进程。</p><h3 id="线程的创建与阻塞">25.1 线程的创建与阻塞</h3><p><code>thread::spawn()</code>接受一个需要执行的闭包。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust">thread::<span class="hljs-title function_ invoke__">spawn</span>(||&#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello World: No.&#123;&#125;&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>上述代码单独运行可能不会输出任何结果，因为主线程先于子线程结束，此时需要阻塞主线程至子线程结束。</p><p><code>thread::spawn()</code>返回的是<code>JoinHandle&lt;&gt;</code>类型，调用其<code>join().unwrap()</code>方法，可以阻塞本线程至调用的线程运行结束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(||&#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello World: No.&#123;&#125;&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;);<br>handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><p>当子线程需要借用用其他线程的值时，值可能先于子线程使用时被移出作用域。所以需要在闭包中使用<code>move</code>关键字强制将所有权转移给子线程的闭包。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">4</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;This is a vec &#123;:?&#125;&quot;</span>, v);<br>&#125;)<br><span class="hljs-title function_ invoke__">drop</span>(v); <span class="hljs-comment">// failed bacause ownership has been moved into closure of thread</span><br>handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure><h3 id="使用消息实现进程间通信">25.2 使用消息实现进程间通信</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (sender, receiver) = mpsc::channel::&lt;type_name&gt;(); <span class="hljs-comment">// 默认有缓冲</span><br>sender.<span class="hljs-title function_ invoke__">send</span>(value); <span class="hljs-comment">// 返回 Result</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">sender_clone</span> = sender.<span class="hljs-title function_ invoke__">clone</span>(); <span class="hljs-comment">// 实现多个发送者</span><br>receiver.<span class="hljs-title function_ invoke__">recv</span>() <span class="hljs-comment">// 返回 Result, 阻塞至有消息</span><br>receiver.<span class="hljs-title function_ invoke__">try_recv</span>() <span class="hljs-comment">// 返回 Result, 不阻塞</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">received_msg</span> <span class="hljs-keyword">in</span> receiver&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用共享实现进程间通信">25.3 使用共享实现进程间通信</h3><p>Rust可以使用互斥锁（与<code>RefCell</code>类似，提供内部可变性）与多线程安全的<code>Arc&lt;T&gt;</code>实现对共享数据的并发同步。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">lock</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 互斥锁 但不能实现多个进程间的共享所有权</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">lock</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(lock); <span class="hljs-comment">// Arc是多线程安全的Rc API一样</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lock</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;lock);<br>    handles.<span class="hljs-title function_ invoke__">push</span>(<br>        thread::<span class="hljs-title function_ invoke__">spawn</span>(||&#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            *num += <span class="hljs-number">1</span>;<br>        &#125;)<br>    );<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles&#123;<br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br></code></pre></td></tr></table></figure><h3 id="send-trait和sync-trait">25.4<code>Send Trait</code>和<code>Sync Trait</code></h3><p><code>Send Trait</code>允许在线程之间转移所有权，如<code>Rc&lt;T&gt;</code>和原始指针没有实现就不能转移给子线程，其他类型几乎都可以。</p><p><code>Sync Trait</code>允许安全地被多个线程引用，<code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code>、<code>Cell&lt;T&gt;</code>家族不是<code>Sync</code>的。</p><p>手动实现<code>Send Trait</code>和<code>Sync Trait</code>是极其有可能不安全的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Language</tag>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang快速入门</title>
    <link href="/2022/01/24/2022-01-24-Golang%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2022/01/24/2022-01-24-Golang%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>@ 2022.01.24 14:31 UTC+0800 v1</p></blockquote><p>这是一篇面向有一定编程基础者的Golang快速入门指南，涵盖Golang的基本语法，面向过程，面向对象，并发等基础知识。</p><blockquote><p>推荐：<ahref="https://www.liwenzhou.com/posts/Go/golang-menu/">Golang语言教程 by李文周</a></p></blockquote><h3 id="变量常量与iota">1. 变量、常量与iota</h3><h4 id="变量">1.1 变量</h4><p>Golang的变量需要先声明后使用，具体地有，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个类型为typeName的变量variableName</span><br><span class="hljs-keyword">var</span> variableName typeName<br><br><span class="hljs-comment">// 声明一个类型为int的变量num并赋初值为1</span><br><span class="hljs-keyword">var</span> num <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// 声明两个类型为int的变量m, n并赋初值</span><br><span class="hljs-keyword">var</span> m, n <span class="hljs-type">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><br><span class="hljs-comment">// 声明两个变量并赋初值</span><br><span class="hljs-keyword">var</span> name, age = <span class="hljs-string">&quot;ZhangSan&quot;</span>, <span class="hljs-number">20</span><br><br><span class="hljs-comment">// 批量声明变量</span><br><span class="hljs-keyword">var</span> (<br>    a <span class="hljs-type">string</span><br>    b <span class="hljs-type">int</span><br>)<br><br><span class="hljs-comment">// Golang在给定初值时支持省略变量类型由编译器自动推导</span><br><span class="hljs-keyword">var</span> n = <span class="hljs-number">10</span><br><br><span class="hljs-comment">// 在函数体内可以使用象牙运算符对变量进行短声明</span><br><span class="hljs-comment">// 注意不可用于全局变量的声明</span><br>n := <span class="hljs-number">10</span><br><br><span class="hljs-comment">// 匿名变量仅用于给不需要的数据占位，不存在重复声明，不占用命名空间，不会分配内存</span><br><span class="hljs-comment">// 匿名变量为下划线: _</span><br></code></pre></td></tr></table></figure><h4 id="常量与iota">1.2 常量与iota</h4><p>常量不能更改，在声明的时候必须赋常量计算得到的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 常量声明</span><br><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14</span><br><br><span class="hljs-comment">// 声明多个常量</span><br><span class="hljs-comment">// 省略处表示与上行的计算式相同</span><br><span class="hljs-keyword">const</span> (<br>    pi = <span class="hljs-number">3.14</span><br>    e = <span class="hljs-number">2.718</span><br>    s<br>)<br><br><span class="hljs-comment">// iota是行计数器，只能在const声明时使用</span><br><span class="hljs-comment">// 每次出现const的时候重置为0，每声明一个常量+1</span><br><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//0</span><br>n2 = <span class="hljs-number">100</span>  <span class="hljs-comment">//100</span><br>n3 = <span class="hljs-literal">iota</span> <span class="hljs-comment">//2</span><br>n4        <span class="hljs-comment">//3</span><br>)<br><span class="hljs-keyword">const</span> n5 = <span class="hljs-literal">iota</span><span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><h3 id="基本数据类型">2. 基本数据类型</h3><h4 id="整型">2.1 整型</h4><table><thead><tr class="header"><th>类型</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>uint8</td><td>无符号8位整型: 0~2^8-1</td></tr><tr class="even"><td>uint16</td><td>无符号8位整型: 0~2^16-1</td></tr><tr class="odd"><td>uint32</td><td>无符号8位整型: 0~2^32-1</td></tr><tr class="even"><td>uint64</td><td>无符号8位整型: 0~2^64-1</td></tr><tr class="odd"><td>uint</td><td>按系统位数决定32/64</td></tr><tr class="even"><td>int8</td><td>有符号8位整型: -2<sup>7~2</sup>7-1</td></tr><tr class="odd"><td>int16</td><td>有符号16位整型: -2<sup>15~2</sup>15-1</td></tr><tr class="even"><td>int32</td><td>有符号32位整型: -2<sup>31~2</sup>31-1</td></tr><tr class="odd"><td>int64</td><td>有符号64位整型: -2<sup>63~2</sup>63-1</td></tr><tr class="even"><td>int</td><td>按系统位数决定32/64</td></tr><tr class="odd"><td>uintptr</td><td>用于存放指针的无符号整型</td></tr></tbody></table><h4 id="数字字面量语法">2.2 数字字面量语法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 字面量二进制</span><br><span class="hljs-keyword">var</span> n := <span class="hljs-number">0</span>b110<br><br><span class="hljs-comment">// 字面量八进制</span><br><span class="hljs-keyword">var</span> n := <span class="hljs-number">032</span><br><span class="hljs-keyword">var</span> n := <span class="hljs-number">0</span>o32<br><br><span class="hljs-comment">// 字面量十六进制</span><br><span class="hljs-keyword">var</span> n := <span class="hljs-number">0x32</span><br><br><span class="hljs-comment">// 字面量十六进制带次方</span><br><span class="hljs-keyword">var</span> n := <span class="hljs-number">0x1</span>p<span class="hljs-number">-2</span><span class="hljs-comment">// 1/2^2 = 0.25</span><br><br><span class="hljs-comment">// 字面量下划线分隔</span><br><span class="hljs-keyword">var</span> n := <span class="hljs-number">123</span>_456<br><br><span class="hljs-comment">// 整型量的格式化输出</span><br><span class="hljs-comment">// 十进制格式化输出</span><br>fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>, n)<br><br><span class="hljs-comment">// 二进制格式化输出</span><br>fmt.Printf(<span class="hljs-string">&quot;%b&quot;</span>, n)<br><br><span class="hljs-comment">// 八进制格式化输出</span><br>fmt.Printf(<span class="hljs-string">&quot;%o&quot;</span>, n)<br> <br><span class="hljs-comment">// 十六进制格式化输出</span><br>fmt.Printf(<span class="hljs-string">&quot;%x&quot;</span>, n)<span class="hljs-comment">// 小写十六进制</span><br>fmt.Printf(<span class="hljs-string">&quot;%X&quot;</span>, n)<span class="hljs-comment">// 大写十六进制</span><br></code></pre></td></tr></table></figure><h4 id="复数">2.3 复数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c1 <span class="hljs-type">complex64</span> = <span class="hljs-number">1</span> + <span class="hljs-number">1i</span><br><span class="hljs-keyword">var</span> c2 <span class="hljs-type">complex128</span><br></code></pre></td></tr></table></figure><h4 id="布尔值">2.4 布尔值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b1 <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> b2 <span class="hljs-type">bool</span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h4 id="浮点数">2.5 浮点数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f1 <span class="hljs-type">float32</span> = <span class="hljs-number">3e2</span><br><span class="hljs-keyword">var</span> f2 <span class="hljs-type">float64</span> = <span class="hljs-number">0.001</span><br>fmt.Printf(<span class="hljs-string">&quot;%.2f&quot;</span>, f1)<br></code></pre></td></tr></table></figure><h4 id="字符">2.6 字符</h4><p>Golang使用两种类型描述字符。</p><ul><li><code>byte</code>(<code>uint8</code>)类型，表示<code>ASCII</code>码字符</li><li><code>rune</code>(<code>int32</code>)类型，表示<code>UTF-8</code>字符，由一个或者多个<code>byte</code>构成</li></ul><h4 id="字符数组">2.7 字符数组</h4><p>Golang可以使用<code>[]byte</code>或<code>[]rune</code>的数组表示字符串。</p><h4 id="字符串">2.8 字符串</h4><p>Golang提供<code>string</code>类型保存字符串，字符串的底层为<code>[]byte</code>数组，对字符串的直接索引会返回<code>byte</code>结果，<code>len</code>返回的是<code>byte</code>的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 单行字符串字面量</span><br>str := <span class="hljs-string">&quot;HelloWorld&quot;</span><br><br><span class="hljs-comment">// 多行字符串字面量，不处理转义字符，也可以用在单行</span><br>str := <span class="hljs-string">`</span><br><span class="hljs-string">line0</span><br><span class="hljs-string">line1</span><br><span class="hljs-string">`</span><br>str := <span class="hljs-string">`\n`</span><span class="hljs-comment">//打印输出\n</span><br><br><span class="hljs-comment">// 常见的字符串相关操作</span><br><span class="hljs-comment">// 按byte (ASCII码) 计算长度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-type">string</span> str)</span></span> (<span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// 按rune (UTF-8码) 计算长度</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">utf8</span>.<span class="hljs-title">RuneCountInString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// 分割字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strings</span>.<span class="hljs-title">Split</span><span class="hljs-params">(s, sep <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">string</span>)<br><br><span class="hljs-comment">// 拼接字符串</span><br>str := str1 + str2<br><br><span class="hljs-comment">// 格式化字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fmt</span>.<span class="hljs-title">Sprintf</span><span class="hljs-params">(format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span><br><br><span class="hljs-comment">// 判断包含</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strings</span>.<span class="hljs-title">Contains</span><span class="hljs-params">(s, substr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> <br><br><span class="hljs-comment">// 前缀/后缀判断</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s, prefix <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasSuffix</span><span class="hljs-params">(s, suffix <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// 判断子串出现位置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(s, substr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LastIndex</span><span class="hljs-params">(s, substr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> <br><br><span class="hljs-comment">//字符串join</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strings</span>.<span class="hljs-title">Join</span><span class="hljs-params">(a[]<span class="hljs-type">string</span>, sep <span class="hljs-type">string</span>)</span></span><br></code></pre></td></tr></table></figure><h3 id="数组">3. 数组</h3><p>数组是一种相同数据类型元素的集合，在声明时确定大小，使用时可以访问、修改元素，但不可更改大小。数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variableName [size]Type<br><br><span class="hljs-comment">// 定义长度为5的int数组numArray</span><br><span class="hljs-keyword">var</span> numArray [<span class="hljs-number">5</span>]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 使用指定的元素初始化</span><br><span class="hljs-keyword">var</span> numArray = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-comment">// 省略数组长度由编译器自主推导</span><br><span class="hljs-keyword">var</span> numArray = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-comment">// 指定下标进行初始化</span><br>numArray := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">3</span>: <span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment">// 高维数组，只有第一层的长度允许由编译器推导</span><br><span class="hljs-keyword">var</span> numArray [<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br><br><span class="hljs-comment">// 数组的遍历</span><br><span class="hljs-comment">// 依据下标遍历</span><br><span class="hljs-keyword">for</span>(i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(numArray); i++)&#123;<br>    numArray[i] = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 依据元素遍历</span><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> numArray&#123;<br>    fmt.Println(item)<br>&#125;<br><br><span class="hljs-comment">// 数组间支持等于逻辑判断</span><br>numArray == numArray<br>numArray != numArray<br></code></pre></td></tr></table></figure><h3 id="切片">4. 切片</h3><p>切片是一种可变长度的同类型数据的集合，具有长度与容量，可以自动扩容。</p><p>切片属于引用类型，直接作为参数传入函数时，对切片参数的修改会传出函数，但特别地，若函数内操作导致扩容，则扩容和以后的视作值传递，不传出函数。</p><p>切片从其他数组/切片上切下时，与原数据结构共享内存。</p><p>切片的零值是<code>nil</code>，没有初始化时只支持<code>append</code>，<code>len</code>，<code>cap</code>等操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个切片</span><br><span class="hljs-keyword">var</span> sliceName []Type<br><br><span class="hljs-comment">// 使用make函数</span><br><span class="hljs-keyword">var</span> sliceName []Type = <span class="hljs-built_in">make</span>([]Type, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>)<br><br><span class="hljs-comment">// 从数组切片</span><br><span class="hljs-keyword">var</span> sliceName []Type = someArray[low:high]<br><br><span class="hljs-comment">// 通用切片表达式</span><br><span class="hljs-comment">// low &lt;= high &lt;= max</span><br><span class="hljs-comment">// max为新切片的最大容量，对新切片的操作超过此限制时与原切片共享内存</span><br><span class="hljs-comment">// 超过后重新分配内存</span><br><span class="hljs-keyword">var</span> sliceName []Type = someArray[low:high:max]<br><br><span class="hljs-comment">// 浅拷贝共享内存</span><br><span class="hljs-keyword">var</span> sliceName []Type = oldSlice[:]<br><br><span class="hljs-comment">// 深拷贝分离内存</span><br><span class="hljs-keyword">var</span> dstSlice []Type = <span class="hljs-built_in">make</span>([]Type, <span class="hljs-built_in">len</span>(srcSlice))<br><span class="hljs-built_in">copy</span>(dstSlice, srcSlice)<br><br><span class="hljs-comment">// 增加元素 注意超出容量引起内存重新分配导致值传递</span><br>sliceName = <span class="hljs-built_in">append</span>(sliceName, newElement)<br><br><span class="hljs-comment">// 删除元素</span><br>sliceName = <span class="hljs-built_in">append</span>(sliceName[:i], sliceName[i+<span class="hljs-number">1</span>:]...)<br><br><span class="hljs-comment">// 与数组遍历类似，略</span><br></code></pre></td></tr></table></figure><h3 id="字典">5. 字典</h3><p><code>Map</code>(字典)提供从一种数据类型向另一种数据类型的无序映射关系，其底层使用<code>Hash</code>实现。</p><p><code>Map</code>属于引用类型，函数内修改<code>Map</code>参数会传递出函数。</p><p><code>Map</code>的零值为<code>nil</code>，须初始化才能使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个Map</span><br><span class="hljs-keyword">var</span> mapName <span class="hljs-keyword">map</span>[KeyType]ValueType<br><br><span class="hljs-comment">// 使用make初始化Map，其中容量cap可选</span><br><span class="hljs-keyword">var</span> mapName <span class="hljs-keyword">map</span>[KeyType]ValueType = <span class="hljs-built_in">make</span>([KeyType]ValueType, <span class="hljs-built_in">cap</span>)<br><br><span class="hljs-comment">// 使用字面量初始化</span><br><span class="hljs-keyword">var</span> mapName <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-comment">// 字典取值与判断键是否存在</span><br><span class="hljs-comment">// ok == true 返回值，否则返回值类型的零值</span><br>value, ok := mapName[key]<br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> mapName &#123;<br>fmt.Println(key, value)<br>&#125;<br><br><span class="hljs-comment">// 只需要键的遍历</span><br><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> mapName &#123;<br>fmt.Println(key, value)<br>&#125;<br><br><span class="hljs-comment">// 删除键值对，不返回</span><br><span class="hljs-built_in">delete</span>(mapName, key)<br></code></pre></td></tr></table></figure><h3 id="流程控制">6. 流程控制</h3><p><code>if</code>语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> cond0&#123;<br>    branch0<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> cond1&#123;<br>    branch1<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    branch2<br>&#125;<br><br><span class="hljs-comment">// 特殊地，可先声明变量赋一次值，该变量作用域只限制于该if块</span><br><span class="hljs-keyword">if</span> score := <span class="hljs-number">65</span>; score &gt;= <span class="hljs-number">90</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt; <span class="hljs-number">75</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;C&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for</code>语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 三个语句均可省略，但分号不能省略</span><br><span class="hljs-keyword">for</span> initialisation; endCond; stepAction&#123;<br>    block<br>&#125;<br><br><span class="hljs-comment">// while风格</span><br><span class="hljs-keyword">for</span> endCond&#123;<br>block   <br>&#125;<br><br><span class="hljs-comment">// 死循环</span><br><span class="hljs-keyword">for</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-comment">// 可用break、goto、return、panic强制退出，continue结束本轮循环</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-keyword">if</span> something&#123;<br>        <span class="hljs-keyword">goto</span> getOut<br>    &#125;<br>&#125;<br>getOut:<br>exitCode<br></code></pre></td></tr></table></figure><p><code>switch</code>语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 各个分支默认带break，可用fallthrough进入下一个case</span><br><span class="hljs-keyword">switch</span> value&#123;<br><span class="hljs-keyword">case</span> matchCase0:<br>    branch0<br><span class="hljs-keyword">case</span> matchCase1:<br>    branch1<br>    <span class="hljs-keyword">fallthrough</span><br>    <span class="hljs-keyword">default</span>:<br>    defaultBranch<br>&#125;<br><br><span class="hljs-comment">// value可以省略表示true，在case后跟条件表达式，模拟if-elseif-else</span><br><span class="hljs-comment">// 类似if，可先声明变量赋一次值，该变量作用域只限制于该switch块</span><br></code></pre></td></tr></table></figure><p>其他的有<code>goto</code>，<code>break</code>，<code>continue</code>等，略过。</p><p><code>goto</code>语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// goto 只能在函数内跳转</span><br><span class="hljs-comment">// goto 不能跳过内部变量声明</span><br><span class="hljs-comment">// goto 只能跳到同作用域或上级作用域</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goto_tags</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br><span class="hljs-keyword">goto</span> tag2 <span class="hljs-comment">// tag0 跳入下级作用域，tag1跳过声明，均不可行</span><br><span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>            tag0:<br>fmt.Println(<span class="hljs-string">&quot;tag1&quot;</span>)<br>&#125;<br>    &#125;<br>    tag1:<br>        i := <span class="hljs-number">3</span><br>        fmt.Println(i)<br>    tag2:<br>        fmt.Println(<span class="hljs-string">&quot;tag2&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>break</code>语句, <code>continue</code>语句</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 跳出指定的循环</span><br><span class="hljs-comment">// break金和label必须在一个函数里</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    tag0:<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        tag1:<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++ &#123;<br>            <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">10</span>; k++ &#123;<br>                <span class="hljs-keyword">for</span> l := <span class="hljs-number">0</span>; l &lt; <span class="hljs-number">10</span>; l++ &#123;<br>                    fmt.Println(i, j, k, l)<br>                    <span class="hljs-keyword">break</span> tag1 <span class="hljs-comment">// 余下一层循环</span><br>                    <span class="hljs-keyword">break</span> tag0 <span class="hljs-comment">// 全部跳出</span><br>                    <span class="hljs-keyword">continue</span> tag0 <span class="hljs-comment">// 下一个i循环 与 break tag1 等效</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数">7. 函数</h3><h4 id="函数定义">7.1 函数定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 函数的声明</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">(paraName0 paraType0, paraName1 paraType1)</span></span> returnType&#123;<br>    block<br>&#125;<br><br><span class="hljs-comment">// 相邻变量的类型相同时的省略</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">(paraName0, paraName1 paraType)</span></span> returnType&#123;<br>    block<br>&#125;<br><br><span class="hljs-comment">// 多返回值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">(paraName paraType)</span></span> (returnType0, returnType1)&#123;<br>    block<br>&#125;<br><br><span class="hljs-comment">// 返回值命名</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">(paraName paraType)</span></span> (returnName0 returnType0, returnName1 returnType1)&#123;<br>    returnName0, returnName1 := something<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 可变参数，只作为参数表最后一个</span><br><span class="hljs-comment">// 在函数体内表示为一个len=cap的切片</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">(paraName0 paraType0, paraName1 ...paraType1)</span></span> returnType&#123;<br>    block<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数类型与函数变量">7.2 函数类型与函数变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 函数类型声明</span><br><span class="hljs-keyword">type</span> funcTypeName <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(paraType0, paraType1)</span></span> returnType<br><br><span class="hljs-comment">// 声明一种funcTypeName的函数类型，接受两个int，返回一个int</span><br><span class="hljs-keyword">type</span> funcTypeName <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br><span class="hljs-comment">// 函数变量的声明与赋值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-keyword">var</span> c funcTypeName<br>c = add<br></code></pre></td></tr></table></figure><h4 id="高阶函数">7.3 高阶函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 以函数作为参数</span><br><span class="hljs-comment">// 以函数作为返回值</span><br><span class="hljs-comment">// 可以用声明过的函数类型</span><br><span class="hljs-comment">// 或使用func(paraType0, paraType1) returnType</span><br></code></pre></td></tr></table></figure><h4 id="匿名函数">7.4 匿名函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 为函数变量赋值</span><br>funcName := <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">(paraName0 paraType0, paraName1 paraType1)</span></span> returnType&#123;<br>    block<br>&#125;<br><br><span class="hljs-comment">// 自执行函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">(paraName0 paraType0, paraName1 paraType1)</span></span>&#123;<br>    block<br>&#125;(para0, para1)<br></code></pre></td></tr></table></figure><h4 id="闭包">7.5 闭包</h4><p>闭包=引用环境+函数</p><p>Golang不支持函数的嵌套定义，但支持在函数内部定义匿名函数来调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 例子</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeSuffixFunc</span><span class="hljs-params">(suffix <span class="hljs-type">string</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> !strings.HasSuffix(name, suffix) &#123;<br><span class="hljs-keyword">return</span> name + suffix<br>&#125;<br><span class="hljs-keyword">return</span> name<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>jpgFunc := makeSuffixFunc(<span class="hljs-string">&quot;.jpg&quot;</span>)<br>txtFunc := makeSuffixFunc(<span class="hljs-string">&quot;.txt&quot;</span>)<br>fmt.Println(jpgFunc(<span class="hljs-string">&quot;test&quot;</span>)) <span class="hljs-comment">//test.jpg</span><br>fmt.Println(txtFunc(<span class="hljs-string">&quot;test&quot;</span>)) <span class="hljs-comment">//test.txt</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="defer">7.6 defer</h4><p><code>defer</code>语句的参数会立即计算，但对其的调用将会推迟到本函数结束。若存在多个<code>defer</code>会遵守先进后出的栈规则，常用于文件关闭、异常处理等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用defer+recover进行异常处理</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    err := <span class="hljs-built_in">recover</span>()<br>    <span class="hljs-comment">//如果程序出出现了panic错误,可以通过recover恢复过来</span><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;recover&quot;</span>)<br>    &#125;<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic&quot;</span>)<br><span class="hljs-comment">// 异常抛出后结束本函数的调用，但被defer+recover恢复，在上层函数调用中得以继续执行</span><br></code></pre></td></tr></table></figure><h3 id="指针">8. 指针</h3><p>Golang的指针不能进行偏移和运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个指针</span><br><span class="hljs-keyword">var</span> ptr *TypeName<br><br><span class="hljs-comment">// 取地址</span><br>ptr = &amp;value<br><br><span class="hljs-comment">// 从地址取值</span><br>value = *ptr<br><br><span class="hljs-comment">// 使用new创建一个内存空间</span><br><span class="hljs-keyword">var</span> ptr *TypeName = <span class="hljs-built_in">new</span>(TypeName)<br><br><span class="hljs-comment">// 使用make创建一个内存空间</span><br><span class="hljs-comment">// 只用于slice, map, chan</span><br><span class="hljs-comment">// 由于创建的是引用类型，所以不用返回指针</span><br><br><span class="hljs-comment">// 不同与c/cpp，golang的指针操作也使用.</span><br></code></pre></td></tr></table></figure><h3 id="结构体">9. 结构体</h3><h4 id="类型定义与类型别名">9.1 类型定义与类型别名</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 类型定义</span><br><span class="hljs-keyword">type</span> NewType0 <span class="hljs-type">int</span><br><br><span class="hljs-comment">// 类型别名</span><br><span class="hljs-keyword">type</span> NewType1 = <span class="hljs-type">int</span><br><br><span class="hljs-comment">// 类型定义编译后存在</span><br><span class="hljs-comment">// 类型别名编译被替换，不存在</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a NewType0<br><span class="hljs-keyword">var</span> b NewType1<br><br>fmt.Printf(<span class="hljs-string">&quot;type of a:%T\n&quot;</span>, a) <span class="hljs-comment">//type of a:main.NewInt</span><br>fmt.Printf(<span class="hljs-string">&quot;type of b:%T\n&quot;</span>, b) <span class="hljs-comment">//type of b:int</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结构体的定义与匿名结构体">9.2 结构体的定义与匿名结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> structName <span class="hljs-keyword">struct</span>&#123;<br>    fieldName0 typeName0<br>    fieldName1 typeName1<br>    fieldName2, fieldName3 typeName2<br>&#125;<br><br><span class="hljs-keyword">var</span> variableName <span class="hljs-keyword">struct</span>&#123;fieldName0 typeName0; fieldName1 typeName1&#125;<br><br><span class="hljs-comment">// 匿名字段: 只指明类型的字段，访问时使用类型名访问，同类型只可存在一个匿名字段</span><br><span class="hljs-comment">// 字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）</span><br></code></pre></td></tr></table></figure><h4 id="结构体的实例化">9.4 结构体的实例化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 基本实例化</span><br><span class="hljs-keyword">var</span> variableName structName<br>variableName.field0 = value0<br>variableName.field1 = value1<br><br><span class="hljs-comment">// 使用new为结构体分配内存</span><br><span class="hljs-keyword">var</span> ptr = <span class="hljs-built_in">new</span>(structName)<br>ptr.field0 = value0<br>ptr.field1 = value1<br></code></pre></td></tr></table></figure><h4 id="结构体的初始化">9.5 结构体的初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 未初始化的结构体的各个字段均为对应类型的零值</span><br><span class="hljs-comment">// 使用键值对初始化</span><br><span class="hljs-keyword">var</span> variableName structName = structName&#123;<br>    field0: value0,<br>    field1: value1,<br>&#125;<br><br><span class="hljs-comment">// 按照声明时的顺序初始化</span><br><span class="hljs-keyword">var</span> variableName structName = structName&#123;<br>    value0,<br>    value1,<br>&#125;<br><br><span class="hljs-comment">// 上述两种方法不可混用</span><br></code></pre></td></tr></table></figure><h4 id="结构体的构造函数">9.6 结构体的构造函数</h4><p>Golang不提供构造函数，但可以使用普通函数是实现构造函数的效果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 结构体复杂的时候若使用返回值的方法会涉及内存拷贝</span><br><span class="hljs-comment">// 这里一般采用返回指针的方式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newStructName</span><span class="hljs-params">(fieldName typeName)</span></span> *structName &#123;<br><span class="hljs-keyword">return</span> &amp;structName&#123;<br>        fieldName: fieldName<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法与接收者">9.7 方法与接收者</h4><p>方法是一种特殊的函数，与接收者绑定，可以借助.使用。</p><p>一般地，使用指针类型作为接收者，这样方法的操作可以修改接受者本身，否则使用值类型作为接收者时会将接收者拷贝一份修改，不会直接修改接受者本身。</p><p>非本地类型不能定义方法，也就是说不能给别的包的类型定义方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(reciverName reciverType)</span></span> methodName(paraName0 paraType) (returnType)&#123;<br>    block<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="嵌套结构体与继承">9.8 嵌套结构体与“继承”</h4><p>一个包含另外结构体类型或其指针作为字段的结构体为嵌套结构体。</p><p>Golang可以借助嵌套结构体的方式实现“继承”，该结构体可以适用所包含的结构体的方法，也可进行重写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> structInside <span class="hljs-keyword">struct</span>&#123;<br>    fieldName fieldType<br>&#125;<br><br><span class="hljs-keyword">type</span> structoutside <span class="hljs-keyword">struct</span>&#123;<br>    fieldName0 structInside<br>    fieldName0 *structInside<br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是，在直接初始化时候，需要先初始化一个"父类"。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> structInside <span class="hljs-keyword">struct</span>&#123;<br>    fieldName0 fieldType<br>    fieldName1 fieldType<br>&#125;<br><br><span class="hljs-keyword">type</span> structOutside <span class="hljs-keyword">struct</span>&#123;<br>    structInside<br>    fieldName2 fieldType<br>&#125;<br><br><span class="hljs-comment">// wrong</span><br>v0 := structOutside&#123;<br>    fieldName0: <span class="hljs-number">0</span>,<br>    fieldName1: <span class="hljs-number">0</span>,<br>    fieldName2: <span class="hljs-number">0</span>,<br>&#125;<br><br><span class="hljs-comment">//right</span><br>v0 := structOutside&#123;<br>    structInside&#123;<br>        fieldName0: <span class="hljs-number">0</span>,<br>        fieldName1: <span class="hljs-number">0</span>,<br>    &#125;<br>    fieldName2: <span class="hljs-number">0</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>而当访问子类未直接定义的成员变量或方法的时候，会尝试访问父类的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v0 structOutside<br>v0.fieldName0 = <span class="hljs-number">0</span><br>v0.fieldName1 = <span class="hljs-number">0</span><br>v0.fieldName2 = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="结构体标签-struct-tag">9.9 结构体标签 Struct Tag</h4><p>结构体的每一个字段都可以有一个Tag，可以使用反射获取其中的字段，具体见反射一章。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> structName <span class="hljs-keyword">struct</span>&#123;<br>    fieldName typeName <span class="hljs-string">`key::value`</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口">10. 接口</h3><p>接口是一组方法的集合，是一种类型，一种抽象的类型。</p><h4 id="接口的定义">10.1 接口的定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> interfaceName <span class="hljs-keyword">interface</span>&#123;<br>    methodName(paraName0 paraType) (returnType)<br>    methodName(paraName1 paraType) (returnType)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接口的实现">10.2 接口的实现</h4><p>具有接口所要求的方法的结构体即实现了该接口，不需要显式说明。</p><p>需要注意的是，结构体在实现接口时的方法集合包含接收者为该结构体的方法，但不包含接收者为该结构体指针的方法；但结构体指针两个都包含。这一点可能会导致一些<code>not implemented error</code>。</p><p>接口只有方法，而不能访问实现它的结构体的属性字段。</p><p>一个类型可以实现多个接口，一个接口也可以由多个类型实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 接口的实现</span><br><span class="hljs-comment">// structName 包含 methodName的实现，因为其接收者是值</span><br><span class="hljs-keyword">type</span> interfaceName <span class="hljs-keyword">interface</span>&#123;<br>methodName()<br>&#125;<br><br><span class="hljs-keyword">type</span> structName <span class="hljs-keyword">struct</span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self structName)</span></span> methodName()&#123;<br>&#125;<br><br><span class="hljs-keyword">var</span> variableName interfaceName = structName&#123;&#125;<br><br><span class="hljs-comment">// 错误的接口实现</span><br><span class="hljs-comment">// structName 不包含 methodName的实现，因为其接收者是指针</span><br><span class="hljs-keyword">type</span> interfaceName <span class="hljs-keyword">interface</span>&#123;<br>methodName()<br>&#125;<br><br><span class="hljs-keyword">type</span> structName <span class="hljs-keyword">struct</span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *structName)</span></span> methodName()&#123;<br>&#125;<br><br><span class="hljs-keyword">var</span> variableName interfaceName = structName&#123;&#125;<br><br><span class="hljs-comment">// 指针形式的接口实现</span><br><span class="hljs-comment">// *structName 包含 methodName的实现</span><br><span class="hljs-keyword">type</span> interfaceName <span class="hljs-keyword">interface</span>&#123;<br>methodName()<br>&#125;<br><br><span class="hljs-keyword">type</span> structName <span class="hljs-keyword">struct</span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *structName)</span></span> methodName()&#123;<br>&#125;<br><br><span class="hljs-keyword">var</span> variableName interfaceName = &amp;structName&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="接口嵌套">10.3 接口嵌套</h4><p>Golang支持接口内包含接口，实现所包含的所有接口即实现本接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> interfaceName0 <span class="hljs-keyword">interface</span>&#123;<br>    methodName0()<br>&#125;<br><br><span class="hljs-keyword">type</span> interfaceName1 <span class="hljs-keyword">interface</span>&#123;<br>    methodName1()<br>&#125;<br><br><span class="hljs-keyword">type</span> interfaceName <span class="hljs-keyword">interface</span>&#123;<br>    interfaceName0<br>    interfaceName1<br>&#125;<br><br><span class="hljs-keyword">type</span> structName <span class="hljs-keyword">struct</span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self structName)</span></span> methodName0()&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self structName)</span></span> methodName1()&#123;<br>&#125;<br><br><span class="hljs-keyword">var</span> variableName interfaceName = structName&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="空接口">10.4 空接口</h4><p>空接口是指没有定义任何方法的接口，因此任何类型都实现了空接口。空接口类型的变量可以存储任意类型的变量，使用空接口实现可以接收任意类型的函数参数。</p><h4 id="类型断言">10.5 类型断言</h4><p>用于判断一个接口类型的变量是否属于一个类型。</p><p>一个接口的值是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 直接断言，若失败则触发panic</span><br>value := interfaceVariable.(Type)<br><br><span class="hljs-comment">// 若ok == true value为成功转换为Type的变量</span><br>value, ok := interfaceVariable.(Type)<br><br><span class="hljs-comment">// type switch实现</span><br><span class="hljs-comment">// 注意，x必须为一个接口类型的变量</span><br><span class="hljs-comment">// case后必须均为已经实现该接口的类型</span><br><span class="hljs-comment">// 此处不可使用fallthrough</span><br><span class="hljs-keyword">switch</span> value := x.(<span class="hljs-keyword">type</span>)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>    <span class="hljs-keyword">default</span>:<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射">11. 反射</h3><p><strong><em>这块比较复杂，暂时不是很了解</em></strong></p><p>反射(<code>reflect</code>)支持对一个接口的类型、值等的获取。</p><p>包含变量的内存空间由<code>pair&lt;type:something, value:something&gt;</code>构成，在不断的变量赋值断言等操作中，该<code>pair</code>保持不变。</p><h4 id="反射初步">11.0 反射初步</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>    ReadBook()<br>&#125;<br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>    WriteBook()<br>&#125;<br><span class="hljs-comment">//具体类型</span><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Book)</span></span> ReadBook() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Read a book.&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Book)</span></span> WriteBook() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Write a book.&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    b := &amp;Book&#123;&#125;<br>    <span class="hljs-keyword">var</span> r Reader<br>    r = b<br>    r.ReadBook()<br>    <span class="hljs-keyword">var</span> w Writer<br>    <span class="hljs-comment">// Error Reader does not implement Writer</span><br>    w = Writer(r)<br>    <span class="hljs-comment">// ok</span><br>    w = r.(Writer)<br>    w, ok := r.(Writer)<br>    w.WriteBook()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="type">11.1 Type</h4><p><code>reflect.TypeOf()</code>可以获得<code>reflect.Type</code>描述的类型，其中包含该类型的一些信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go">t := reflect.TypeOf(x)<br><span class="hljs-comment">// 编译后的类型名称</span><br>t.Name()<br><br><span class="hljs-comment">// 底层的类型名称</span><br>t.Kind()<br><br><span class="hljs-comment">// Kind支持</span><br><span class="hljs-keyword">type</span> Kind <span class="hljs-type">uint</span><br><span class="hljs-keyword">const</span> (<br>    Invalid Kind = <span class="hljs-literal">iota</span>  <span class="hljs-comment">// 非法类型</span><br>    Bool                 <span class="hljs-comment">// 布尔型</span><br>    Int                  <span class="hljs-comment">// 有符号整型</span><br>    Int8                 <span class="hljs-comment">// 有符号8位整型</span><br>    Int16                <span class="hljs-comment">// 有符号16位整型</span><br>    Int32                <span class="hljs-comment">// 有符号32位整型</span><br>    Int64                <span class="hljs-comment">// 有符号64位整型</span><br>    Uint                 <span class="hljs-comment">// 无符号整型</span><br>    Uint8                <span class="hljs-comment">// 无符号8位整型</span><br>    Uint16               <span class="hljs-comment">// 无符号16位整型</span><br>    Uint32               <span class="hljs-comment">// 无符号32位整型</span><br>    Uint64               <span class="hljs-comment">// 无符号64位整型</span><br>    Uintptr              <span class="hljs-comment">// 指针</span><br>    Float32              <span class="hljs-comment">// 单精度浮点数</span><br>    Float64              <span class="hljs-comment">// 双精度浮点数</span><br>    Complex64            <span class="hljs-comment">// 64位复数类型</span><br>    Complex128           <span class="hljs-comment">// 128位复数类型</span><br>    Array                <span class="hljs-comment">// 数组</span><br>    Chan                 <span class="hljs-comment">// 通道</span><br>    Func                 <span class="hljs-comment">// 函数</span><br>    Interface            <span class="hljs-comment">// 接口</span><br>    Map                  <span class="hljs-comment">// 映射</span><br>    Ptr                  <span class="hljs-comment">// 指针</span><br>    Slice                <span class="hljs-comment">// 切片</span><br>    String               <span class="hljs-comment">// 字符串</span><br>    Struct               <span class="hljs-comment">// 结构体</span><br>    UnsafePointer        <span class="hljs-comment">// 底层指针</span><br>)<br></code></pre></td></tr></table></figure><h4 id="value">11.2 Value</h4><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">v := reflect.ValueOf(x)<br></code></pre></td></tr></table></figure><h4 id="typeof-和valueof">11.3 <code>TypeOf</code>和<code>ValueOf</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Id   <span class="hljs-type">int</span><br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> SuperUser <span class="hljs-keyword">struct</span> &#123;<br>User<br>Passwd <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u User)</span></span> SelfMethod() &#123;<br>fmt.Println(<span class="hljs-string">&quot;SelfMethod Is Called&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> SelfPtrMethod() &#123;<br>fmt.Println(<span class="hljs-string">&quot;SelfPtrMethod Is Called&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReflectionTest</span><span class="hljs-params">(input <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">var</span> reflected_Type reflect.Type<br><span class="hljs-keyword">var</span> reflected_Value reflect.Value<br>reflected_Type = reflect.TypeOf(input)<br>fmt.Println(<span class="hljs-string">&quot;Reflected Type is :&quot;</span>, reflected_Type.Name())<br>reflected_Value = reflect.ValueOf(input)<br>fmt.Println(<span class="hljs-string">&quot;Reflected Value for all Fields is:&quot;</span>, reflected_Value)<br><br><span class="hljs-comment">// 获取方法字段</span><br><span class="hljs-comment">// 1. 先获取interface的reflect.Type，然后通过NumField进行遍历</span><br><span class="hljs-comment">// 2. 再通过reflect.Type的Field获取其Field</span><br><span class="hljs-comment">// 3. 最后通过Field的Interface()得到对应的value</span><br>num_field := reflected_Type.NumField()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num_field; i++ &#123;<br>field := reflected_Type.Field(i)<br>value := reflected_Value.Field(i).Interface()<br>fmt.Printf(<span class="hljs-string">&quot;%s: %v = %v\n&quot;</span>, field.Name, field.Type, value)<br>&#125;<br><br><span class="hljs-comment">// 通过反射访问结构体绑定的方法</span><br>num_method := reflected_Type.NumMethod()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num_method; i++ &#123;<br>method := reflected_Type.Method(i)<br>fmt.Printf(<span class="hljs-string">&quot;%s: %v\n&quot;</span>, method.Name, method.Type)<br>method.Func.Call([]reflect.Value&#123;reflect.ValueOf(input)&#125;)<br>&#125;<br><br><span class="hljs-comment">// reflect.Value.Elem() 解除一层interface 或 指针</span><br>    <span class="hljs-comment">// 通过reflect修改字段</span><br><br>v := reflect.ValueOf(&amp;input).Elem()<br>tmp := reflect.New(v.Elem().Type()).Elem()<br>tmp.Set(v.Elem())<br>tmp.FieldByName(<span class="hljs-string">&quot;Passwd&quot;</span>).SetString(<span class="hljs-string">&quot;Hello&quot;</span>)<br>v.Set(tmp)<br>fmt.Println(input)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>user := SuperUser&#123;<br>User&#123;<br>Id:   <span class="hljs-number">111</span>,<br>Name: <span class="hljs-string">&quot;Doctor&quot;</span>,<br>Age:  <span class="hljs-number">18</span>,<br>&#125;,<br><span class="hljs-string">&quot;good&quot;</span>,<br>&#125;<br>ReflectionTest(user)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="struct-tag和json解析">11.4 Struct Tag和Json解析</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Event <span class="hljs-keyword">struct</span> &#123;<br>Date  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;date&quot;`</span><br>Title <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;title&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Response <span class="hljs-keyword">struct</span> &#123;<br>Code   <span class="hljs-type">string</span>  <span class="hljs-string">`json:&quot;code&quot;`</span><br>Day    <span class="hljs-type">string</span>  <span class="hljs-string">`json:&quot;day&quot;`</span><br>Result []Event <span class="hljs-string">`json:&quot;result&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>strs := <span class="hljs-string">`</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">&quot;code&quot;: &quot;200&quot;,</span><br><span class="hljs-string">&quot;day&quot;: &quot;09/ 08&quot;,</span><br><span class="hljs-string">&quot;result&quot;: [</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">&quot;date&quot;: &quot;1157年09月08日&quot;,</span><br><span class="hljs-string">&quot;title&quot;: &quot;英国国王理查一世出生&quot;</span><br><span class="hljs-string">&#125;,</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">&quot;date&quot;: &quot;1588年09月08日&quot;,</span><br><span class="hljs-string">&quot;title&quot;: &quot;法国神学家马林·梅森出生&quot;</span><br><span class="hljs-string">&#125;,</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">&quot;date&quot;: &quot;1894年09月08日&quot;,</span><br><span class="hljs-string">&quot;title&quot;: &quot;德国科学家亥姆霍兹逝世&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span><br><br><span class="hljs-keyword">var</span> dict Response<br><br>err = json.Unmarshal([]<span class="hljs-type">byte</span>(strs), &amp;dict)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;Code:&quot;</span>, dict.Code)<br>fmt.Println(<span class="hljs-string">&quot;Day:&quot;</span>, dict.Day)<br>fmt.Println(<span class="hljs-string">&quot;Events:&quot;</span>)<br><span class="hljs-keyword">for</span> _, event := <span class="hljs-keyword">range</span> dict.Result &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Date: %s\n&quot;</span>, event.Date)<br>fmt.Printf(<span class="hljs-string">&quot;Title: %s\n&quot;</span>, event.Title)<br>fmt.Println()<br>&#125;<br><br>    <br><span class="hljs-comment">// 获得结构体的字段</span><br>    field, _ := reflect.TypeOf(dict).FieldByName(<span class="hljs-string">&quot;Code&quot;</span>)<br><span class="hljs-comment">// 查询结构体字段是否存在一个键</span><br>    tag_value, ok := field.Tag.Lookup(<span class="hljs-string">&quot;code&quot;</span>)<br>fmt.Println(tag_value, ok)<br>    <span class="hljs-comment">// 获取结构体字段Tag键的值</span><br>tag_value = field.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>)<br>fmt.Println(tag_value)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="包">12. 包</h3><p>一个包可以简单理解为一个存放<code>.go</code>文件的文件夹。该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。一个文件夹下面直接包含的文件只能归属一个package，同样一个package的文件不能在多个文件夹下。</p><p><code>main</code>包为入口包，不是main包的程序编译后没有可执行文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> packageName<br></code></pre></td></tr></table></figure><h4 id="包的导入">12.1 包的导入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;packageName&quot;</span> <span class="hljs-comment">// packageName从$GOPATH/src/开始</span><br><span class="hljs-keyword">import</span> newPackageName <span class="hljs-string">&quot;packageName&quot;</span><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;packageName0&quot;</span><br>    newPackageName1 <span class="hljs-string">&quot;packageName1&quot;</span><br>)<br></code></pre></td></tr></table></figure><h4 id="包的初始化">12.2 包的初始化</h4><p>包的初始化依照以下顺序:全局声明，init函数，main函数。若存在嵌套调用则按照栈的原则初始化。</p><h3 id="并发">13. 并发</h3><h4 id="goroutine">13.1 goroutine</h4><p>goroutine是一种比线程更加轻量的协程。</p><p>一般地，goroutine会在主线程结束后强制被退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 启动一个协程</span><br><span class="hljs-keyword">go</span> funcName(para0, para1)<br></code></pre></td></tr></table></figure><h4 id="channel">13.2 channel</h4><p>通道(<code>channel</code>)是一种Golang中可用于不同协程间传递数据的数据类型，属于引用类型，需要<code>make</code>初始化</p><p>当发送goroutine遇到缓冲区已满或接收goroutine遇到缓冲区空时，Goroutine被阻塞，这种情况可能引起死锁，需要注意。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明一个用于传递TypeName的通道ch</span><br><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> TypeName<br><br><span class="hljs-comment">// 用make创建无缓冲的channel</span><br><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> TypeName = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> TypeName)<br><br><span class="hljs-comment">// 用make创建有缓冲的channel</span><br><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> TypeName = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> TypeName, cacheLength)<br><br><span class="hljs-comment">// 向channel发送</span><br>ch &lt;- item<br><br><span class="hljs-comment">// 从channel中取出</span><br>item = &lt;- ch<br>item, ok = &lt;- ch<br><br><span class="hljs-comment">// 使用close关闭channel，这样支持退出for-range</span><br><span class="hljs-comment">// 向已关闭的channel发送会导致程序panic</span><br><span class="hljs-comment">// 从已经关闭的channel中取值会先耗尽缓冲后取出对应类型的零值</span><br><span class="hljs-built_in">close</span>(ch)<br><br><span class="hljs-comment">// 对于channel的for-range</span><br><span class="hljs-keyword">for</span> item := <span class="hljs-keyword">range</span> ch&#123;<br>    fmt.Println(item)<br>&#125;<br><br><span class="hljs-comment">// 函数声明时的单向通道</span><br><span class="hljs-comment">// 在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以</span><br><span class="hljs-comment">// 只发送通道</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- TypeName)</span></span>&#123;<br>    <span class="hljs-comment">// out为只发送通道，只能发送或关闭通道</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> TypeName)</span></span>&#123;<br>    <span class="hljs-comment">// in为只发送通道，只能发接收，不可关闭通道</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="select">13.3 select</h4><p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。</p><p>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</p><p>对于没有<code>case</code>的<code>select&#123;&#125;</code>会一直等待，可用于阻塞main函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span>&#123;<br>    <span class="hljs-keyword">case</span> &lt;-ch1:<br>        ...<br>    <span class="hljs-keyword">case</span> data := &lt;-ch2:<br>        ...<br>    <span class="hljs-keyword">case</span> ch3&lt;-data:<br>        ...<br>    <span class="hljs-keyword">default</span>:<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并发任务的同步">13.4 并发任务的同步</h4><p>许多时候一个goroutine需要等待其他的goroutine结束后再进行部分操作，可用<code>sync.WaitGroup</code>实现</p><table><thead><tr class="header"><th style="text-align: left;">方法名</th><th style="text-align: left;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">(wg * WaitGroup) Add(delta int)</td><td style="text-align: left;">计数器+delta</td></tr><tr class="even"><td style="text-align: left;">(wg *WaitGroup) Done()</td><td style="text-align: left;">计数器-1</td></tr><tr class="odd"><td style="text-align: left;">(wg *WaitGroup) Wait()</td><td style="text-align: left;">阻塞直到计数器变为0</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(wg *sync.WaitGroup)</span></span>&#123;<br>    <span class="hljs-comment">// something working </span><br>    wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++&#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> funcName(&amp;wg)<br>    &#125;<br>    wg.Wait()<br>    fmt.Println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="互斥锁">13.5 互斥锁</h4><p>互斥锁确保只有一个goroutine能够进入临界区，其他未能取得锁的goroutine必须阻塞等待。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(wg *sync.WaitGroup, lock *sync.Mutex)</span></span>&#123;<br>    <span class="hljs-comment">// 加锁</span><br>    lock.Lock()<br>    <span class="hljs-comment">// 临界区代码</span><br>    lock.Unlock() <span class="hljs-comment">// 解锁</span><br>    wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">var</span> lock sync.Mutex<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++&#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> funcName(&amp;wg, &amp;lock)<br>    &#125;<br>    wg.Wait()<br>    fmt.Println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读写锁">13.6 读写锁</h4><p>与互斥锁不同，当有goroutine获取读锁时，其他需要读锁的goroutine可以继续获得，需要写锁的阻塞。当有goroutine获得写锁时，其他所有goroutine均阻塞等待。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>x      <span class="hljs-type">int64</span><br>wg     sync.WaitGroup<br>rwlock sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcWrite</span><span class="hljs-params">(wg *sync.WaitGroup, lock *sync.RWMutex)</span></span>&#123;<br>    <span class="hljs-comment">// 加写锁</span><br>    rwlock.Lock()<br>    <span class="hljs-comment">// 临界区: 写</span><br>    <span class="hljs-comment">// 解写锁</span><br>    rwlock.Unlock()<br>    wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcRead</span><span class="hljs-params">(wg *sync.WaitGroup, lock *sync.RWMutex)</span></span>&#123;<br>    <span class="hljs-comment">// 加读锁</span><br>    rwlock.RLock()<br>    <span class="hljs-comment">// 临界区: 读</span><br>    <span class="hljs-comment">// 解读锁</span><br>    rwlock.RUnlock()<br>    wg.Done()<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-keyword">var</span> lock sync.RWMutex<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++&#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> funcRead(&amp;wg, &amp;lock)<br>        <span class="hljs-keyword">go</span> funcWrite(&amp;wg, &amp;lock)<br>    &#125;<br>    wg.Wait()<br>    fmt.Println(<span class="hljs-string">&quot;Done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Language</tag>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Docker的jekyll-TeXt本地环境搭建指南</title>
    <link href="/2021/12/19/2021-12-19-%E5%9F%BA%E4%BA%8EDocker%E7%9A%84jekyll-TeXt%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
    <url>/2021/12/19/2021-12-19-%E5%9F%BA%E4%BA%8EDocker%E7%9A%84jekyll-TeXt%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>@ 2021.12.19 18:06 UTC+0800 v1</p></blockquote><p>本站基于jekyll-TeXt主题开发，支持Github Page，本文介绍一种基于Docker的本地环境搭建方式。</p><h2 id="代码下载">代码下载</h2><p><ahref="https://github.com/kitian616/jekyll-TeXt-theme/releases">Releases· kitian616/jekyll-TeXt-theme</a>下载最近的Release包，并解压</p><p>或者执行如下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -O https://github.com/kitian616/jekyll-TeXt-theme/archive/refs/tags/v2.2.6.zip<br>unzip jekyll-TeXt-theme.zip<br><span class="hljs-built_in">cd</span> jekyll-TeXt-theme<br></code></pre></td></tr></table></figure><h2 id="docker-部署">Docker 部署</h2><p>依照指南中安装Docker &amp; Docker-Compose</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -v <span class="hljs-string">&quot;<span class="hljs-variable">$PWD</span>&quot;</span>:/usr/src/app -w /usr/src/app ruby:2.6 bundle install<br>docker-compose -f ./docker/docker-compose.build-image.yml build<br></code></pre></td></tr></table></figure><h2 id="启动服务">启动服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose -f ./docker/docker-compose.default.yml up<br></code></pre></td></tr></table></figure><p>执行完成后可在本地4000端口访问。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Guide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux迁移指南</title>
    <link href="/2021/12/18/2021-12-18-Linux%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97/"/>
    <url>/2021/12/18/2021-12-18-Linux%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>@ 2021.12.18 19:55 UTC+0800 v1</p><p>@ 2021.12.30 18:59 UTC+0800 v2</p><p>@ 2022.10.13 13:44 UTC+0800 v3</p><p>@ 2023.04.10 11:21 UTC+0800 v4</p></blockquote><p>Linux上有一些常用的工具，在迁移或重装系统后容易忘记如何安装，本指南以Debian/Ubuntu系列为例，指导我在未来安装这些工具，以实现快速的环境还原。</p><h2 id="aptitude">1. aptitude</h2><p>可用于解决依赖冲突的Debian/Ubuntu系列的包管理器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install aptitude<br><br><span class="hljs-comment"># usage</span><br>sudo aptitude install some-package<br></code></pre></td></tr></table></figure><h2 id="zsh-oh-my-zsh">2. zsh &amp; oh-my-zsh</h2><p>一个新的shell和对应的美化工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install zsh<br><br><span class="hljs-comment"># set as default for current user</span><br>chsh -s /bin/zsh<br><br><span class="hljs-comment"># install oh-my-zsh</span><br>sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span><br><br><span class="hljs-comment"># install font if mis-display</span><br>sudo apt-get install fonts-powerline<br></code></pre></td></tr></table></figure><p>插件：</p><ul><li><p>agnoster主题设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置</span><br>vim ~/.zshrc<br><span class="hljs-comment"># 修改</span><br>ZSH_THEME=<span class="hljs-string">&quot;agnoster&quot;</span><br><span class="hljs-comment"># 添加以增加时间戳和换行</span><br><span class="hljs-comment"># Add time stamp to terminal prompt and new line to type into</span><br>NEWLINE=$<span class="hljs-string">&#x27;\n&#x27;</span><br>PROMPT=<span class="hljs-string">&#x27;%&#123;$fg[yellow]%&#125;[%D@%*] &#x27;</span><span class="hljs-variable">$PROMPT</span><span class="hljs-string">&#x27;$&#123;NEWLINE&#125;%&#123;$fg[cyan]%&#125;☁  &#x27;</span><br><br><span class="hljs-comment"># 更改路径提示背景色</span><br>vim ~/.oh-my-zsh/themes/agnoster.zsh-theme<br><br><span class="hljs-comment"># 更改下部的blue -&gt; cyan</span><br><span class="hljs-comment"># Dir: current working directory</span><br><span class="hljs-function"><span class="hljs-title">prompt_dir</span></span>() &#123;<br>  prompt_segment blue <span class="hljs-variable">$CURRENT_FG</span> <span class="hljs-string">&#x27;%~&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>zsh-syntax-highlighting</p><p>bash命令高亮</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git<br><span class="hljs-built_in">mv</span> zsh-syntax-highlighting ~/.oh-my-zsh/plugins/zsh-syntax-highlighting<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;plugins=(zsh-syntax-highlighting)&quot;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure></li><li><p>zsh-autosuggestions</p><p>根据以往命令提示命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions.git<br><span class="hljs-built_in">mv</span> zsh-autosuggestions ~/.oh-my-zsh/plugins/zsh-autosuggestions<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;plugins=(zsh-autosuggestions)&quot;</span> &gt;&gt; ~/.zshrc<br><br><span class="hljs-comment"># BindKey to forward-word</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;bindkey &#x27;^[OC&#x27; forward-word&quot;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure></li><li><p>command-not-found</p><p>提示需要安装的缺失包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install command-not-found<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;plugins=(command-not-found)&quot;</span> &gt;&gt; ~/.zshrc<br><br><span class="hljs-comment"># Add missing package install prompt</span><br><span class="hljs-built_in">source</span> /etc/zsh_command_not_found<br></code></pre></td></tr></table></figure></li><li><p>thefuck</p><p>键入<code>fuck</code>自动修正上一条命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pip3 install thefuck<br></code></pre></td></tr></table></figure></li><li><p>sudo</p><p>双击<kbd>Esc</kbd>以给上一条权限限制的命令加上sudo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;plugins=(sudo)&quot;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure></li><li><p>autojump</p><p><code>j path-like</code>实现地址模糊匹配跳转</p><p>使用zsh的z插件实现不需要安装的类似功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install autojump<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;plugins=(autojump)&quot;</span> &gt;&gt; ~/.zshrc<br>j -v<br></code></pre></td></tr></table></figure></li><li><p>z</p><p><code>z path-like</code>实现地址模糊匹配跳转</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;plugins=(z)&quot;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure></li><li><p>extract</p><p><code>x zip-file</code>各种压缩文件解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;plugins=(extract)&quot;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure></li><li><p>colored-man-pages</p><p>为man页提供高亮</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;plugins=(colored-man-pages)&quot;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure></li><li><p>history-substring-search</p><p>实现根据已经键入的部分命令在执行历史中查找</p><p><kbd>Ctrl</kbd>+<kbd>P</kbd>向上查找</p><p><kbd>Ctrl</kbd>+<kbd>N</kbd>向下查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-history-substring-search.git<br><span class="hljs-built_in">mv</span> zsh-history-substring-search ~/.oh-my-zsh/plugins/zsh-history-substring-search<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;plugins=(zsh-history-substring-search)&quot;</span> &gt;&gt; ~/.zshrc<br><br><span class="hljs-comment"># Add to .zshrc</span><br><span class="hljs-built_in">bindkey</span> <span class="hljs-string">&#x27;^P&#x27;</span> history-substring-search-up<br><span class="hljs-built_in">bindkey</span> <span class="hljs-string">&#x27;^N&#x27;</span> history-substring-search-down<br></code></pre></td></tr></table></figure></li></ul><h2 id="virtualenvwrapper">3. virtualenvwrapper</h2><p>python虚拟环境管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pip3 install virtualenvwrapper<br><br><span class="hljs-comment"># Add to .bashrc</span><br><span class="hljs-comment"># Here for virtualenvwrapper to use workon commands family</span><br><span class="hljs-built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3<br><span class="hljs-built_in">export</span> WORKON_HOME=<span class="hljs-variable">$HOME</span>/.virtualenvs<br><span class="hljs-built_in">source</span> /usr/local/bin/virtualenvwrapper.sh<br><br><span class="hljs-comment"># Config tuna in pip</span><br>pip3 config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><h2 id="tmux">4. tmux</h2><p>终端复用工具，类screen</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># install</span><br>sudo apt-get install tmux<br><br><span class="hljs-comment"># Add to .bashrc</span><br><span class="hljs-comment"># Enable mouse in tmux</span><br>tmux <span class="hljs-built_in">set</span> -g mouse on<br><br><span class="hljs-comment"># Chaneg Prefix key-bind for tmux</span><br>tmux <span class="hljs-built_in">set</span> -g prefix C-x<br>tmux unbind C-b<br>tmux <span class="hljs-built_in">bind</span> C-x send-prefix<br></code></pre></td></tr></table></figure><h3 id="基础用法">4.1 基础用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># New session</span><br>tmux new -s &lt;session-name&gt;<br><br><span class="hljs-comment"># New detached session</span><br>tmux new -s &lt;session-name&gt;<br><br><span class="hljs-comment"># Show all sessions</span><br>tmux list-session<br><br><span class="hljs-comment"># Detach this session</span><br>tmux detach<br><br><span class="hljs-comment"># Attach into a session</span><br>tmux attach -t &lt;session-name&gt;<br><br><span class="hljs-comment"># Kill a session</span><br>tmux kill-session -t &lt;session-name&gt;<br><br><span class="hljs-comment"># Switch to another session</span><br>tmux switch -t &lt;session-name&gt;<br><br><span class="hljs-comment"># Rename a session</span><br>tmux switch -t &lt;session-id&gt; &lt;session-name&gt;<br><br><br><span class="hljs-comment"># 划分上下两个窗格</span><br>tmux split-window<br><br><span class="hljs-comment"># 划分左右两个窗格</span><br>tmux split-window -h<br><br><span class="hljs-comment"># 光标切换到上方窗格</span><br>tmux select-pane -U<br><br><span class="hljs-comment"># 光标切换到下方窗格</span><br>tmux select-pane -D<br><br><span class="hljs-comment"># 光标切换到左边窗格</span><br>tmux select-pane -L<br><br><span class="hljs-comment"># 光标切换到右边窗格</span><br>tmux select-pane -R<br><br><span class="hljs-comment"># 当前窗格上移</span><br>tmux swap-pane -U<br><br><span class="hljs-comment"># 当前窗格下移</span><br>tmux swap-pane -D<br><br><span class="hljs-comment"># 新建窗口</span><br>tmux new-window<br><br><span class="hljs-comment"># 新建一个指定名称的窗口</span><br>tmux new-window -n &lt;window-name&gt;<br><br><span class="hljs-comment"># 切换到指定编号的窗口</span><br>tmux select-window -t &lt;window-number&gt;<br><br><span class="hljs-comment"># 切换到指定名称的窗口</span><br>tmux select-window -t &lt;window-name&gt;<br><br><span class="hljs-comment"># 重命名当前窗口</span><br>tmux rename-window &lt;new-name&gt;<br><br><span class="hljs-comment"># 列出所有快捷键，及其对应的 Tmux 命令</span><br>tmux list-keys<br><br><span class="hljs-comment"># 列出所有快捷键，及其对应的 Tmux 命令</span><br>tmux list-keys<br><br><span class="hljs-comment"># 发出命令</span><br>tmux send -t &lt;session-name&gt;:&lt;window-name&gt;.&lt;pane-name&gt; <span class="hljs-string">&quot;command&quot;</span> ENTER<br></code></pre></td></tr></table></figure><h3 id="常用快捷键">4.2 常用快捷键</h3><p>前缀键: <kbd>Ctrl</kbd>+<kbd>b</kbd></p><p>更改后的前缀键: <kbd>Ctrl</kbd>+<kbd>x</kbd></p><p>分离当前会话: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>d</kbd></p><p>左右划分窗格: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>%</kbd></p><p>上下划分窗格: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>"</kbd></p><p>切换窗格: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>arrow-key</kbd></p><p>变换当前窗格大小: <kbd>Ctrl</kbd>+<kbd>b</kbd><kbd>Ctrl</kbd>+<kbd>arrow-key</kbd></p><p>关闭当前窗格: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>x</kbd></p><p>将当前窗格与全屏间切换: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>z</kbd></p><p>显示窗格编号: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>q</kbd></p><p>创建新窗口: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>c</kbd></p><p>切换上一个窗口: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>p</kbd></p><p>切换下一个窗口: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>n</kbd></p><p>切换到指定编号的窗口: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>number</kbd><code>number</code>是状态栏上的窗口编号。</p><p>交互式切换窗口: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>w</kbd></p><p>交互式切换会话: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>s</kbd></p><p>帮助: <kbd>Ctrl</kbd>+<kbd>b</kbd> <kbd>?</kbd></p><h2 id="ag">5. ag</h2><p>支持递归查找文件内容的搜索工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install silversearcher-ag<br><br><span class="hljs-comment"># usage</span><br>ag <span class="hljs-string">&quot;query&quot;</span><br></code></pre></td></tr></table></figure><h2 id="locate">6. locate</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install locate<br><br><span class="hljs-comment"># usage</span><br>locate &lt;part-of-file-name&gt;<br>updatedb <br></code></pre></td></tr></table></figure><h2 id="tig">7. tig</h2><p>终端交互式git工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install tig<br>tig<br></code></pre></td></tr></table></figure><h2 id="htop">8. htop</h2><p>更美观、更方便的进程监控工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install htop<br>htop<br></code></pre></td></tr></table></figure><h2 id="axel">9. axel</h2><p>多线程的下载工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install axel<br><br><span class="hljs-comment"># usage</span><br>axel -n &lt;thread-number&gt; url<br></code></pre></td></tr></table></figure><h2 id="cloc">10. cloc</h2><p>代码行数统计</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install cloc<br>cloc<br></code></pre></td></tr></table></figure><h2 id="ncdu">11. ncdu</h2><p>交互可视化的空间分析程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install ncdu<br>ncdu<br></code></pre></td></tr></table></figure><h2 id="tldr">12. tldr</h2><p>简洁的帮助页面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install tldr<br><br><span class="hljs-comment"># usage</span><br>tldr --update<br>tldr <span class="hljs-built_in">command</span><br></code></pre></td></tr></table></figure><h2 id="wordgrinder">13. wordgrinder</h2><p>可交互的终端文本轻量化文本编辑器</p><p>进入后双击<kbd>Esc</kbd>打开菜单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install wordgrinder<br>wordgrinder<br></code></pre></td></tr></table></figure><h2 id="docker-docker-compose">14. docker &amp; docker-compose</h2><p>轻量化的虚拟机</p><blockquote><p><ahref="https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/">Docker-CE清华源详细帮助</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://registry.docker-cn.com<span class="hljs-comment"># Ubuntu All in one</span><br>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun<br><br><span class="hljs-comment"># Ubuntu manually install with TUNA</span><br>sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br>sudo add-apt-repository \<br>   <span class="hljs-string">&quot;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \</span><br><span class="hljs-string">   <span class="hljs-subst">$(lsb_release -cs)</span> \</span><br><span class="hljs-string">   stable&quot;</span><br>sudo apt-get install docker-ce docker-ce-cli containerd.io<br><br><span class="hljs-comment"># Raspberry</span><br>sudo apt-get install docker-ce docker-ce-cli containerd.io<br><br><span class="hljs-comment"># Install docker-compose</span><br>sudo curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`<span class="hljs-built_in">uname</span> -s`-`<span class="hljs-built_in">uname</span> -m` -o /usr/local/bin/docker-compose<br>sudo <span class="hljs-built_in">chmod</span> +x /usr/local/bin/docker-compose<br><br><span class="hljs-comment"># 添加到组以避免使用sudo</span><br>sudo usermod -aG docker your-user<br><br><span class="hljs-comment"># Change to dockerhub-china</span><br>sudo vim /etc/docker/daemon.json<br><br><span class="hljs-comment"># in /etc/docker/daemon.json</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]<br>&#125;<br>sudo systemctl daemon-reload<br>sudo service docker restart<br><br><span class="hljs-comment"># portainer.io UI for docker</span><br>docker pull portainer/portainer<br>docker run -d -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /mnt/docker/portainer:/data portainer/portainer<br></code></pre></td></tr></table></figure><h2 id="syncthing">15. syncthing</h2><p>一种P2P去中心化的文件同步工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo install syncthing<br><br><span class="hljs-comment"># Change 127.0.0.1 -&gt; localip/0.0.0.0/127.0.0.1</span><br>vim ~/.config/syncthing/config.xml<br><br>syncthing<br></code></pre></td></tr></table></figure><h2 id="supervisor">16. supervisor</h2><p>支持自动重启的服务管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install supervisor<br></code></pre></td></tr></table></figure><p>配置文件 <code>/etc/supervisor/conf.d/service-name.conf</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[program:service-name]</span><br><span class="hljs-attr">command</span>= bash service.sh <span class="hljs-comment">; command waiting to be executed</span><br><span class="hljs-attr">autostart</span>=<span class="hljs-literal">true</span>      <span class="hljs-comment">; starts as supervisor starts</span><br><span class="hljs-attr">startsecs</span>=<span class="hljs-number">5</span>         <span class="hljs-comment">; exit later than this waiting seconds ends will be seen as start up succeeded</span><br><span class="hljs-attr">autorestart</span>=unexpected    <span class="hljs-comment">; restart on exit [unexpected,true,false]</span><br><span class="hljs-attr">startretries</span>=<span class="hljs-number">5</span>       <span class="hljs-comment">; retry times</span><br><span class="hljs-attr">user</span>=root            <span class="hljs-comment">; user to execute</span><br><span class="hljs-attr">priority</span>=<span class="hljs-number">999</span>         <span class="hljs-comment">; small priority will be executed first</span><br></code></pre></td></tr></table></figure><p>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># restart supervisor</span><br>sudo systemctl restart supervisor<br><span class="hljs-comment"># check supervisor status</span><br>sudo supervisorctl status<br><span class="hljs-comment"># stop a supervisor service</span><br>supervisorctl stop service-name<br><span class="hljs-comment"># start a supervisor service</span><br>supervisorctl start service-name<br><span class="hljs-comment"># restart a supervisor service</span><br>supervisorctl restart service-name<br></code></pre></td></tr></table></figure><h2 id="auto-proxy-setting-for-wsl">17. auto proxy setting for WSL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">host_ip=$(<span class="hljs-built_in">cat</span> /etc/resolv.conf |grep <span class="hljs-string">&quot;nameserver&quot;</span> |<span class="hljs-built_in">cut</span> -f 2 -d <span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">export</span> ALL_PROXY=<span class="hljs-string">&quot;http://<span class="hljs-variable">$host_ip</span>:7890&quot;</span><br></code></pre></td></tr></table></figure><h2 id="lazygit">18. lazygit</h2><p>A Git GUI for CLI.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># for Ubuntu</span><br>LAZYGIT_VERSION=$(curl -s <span class="hljs-string">&quot;https://api.github.com/repos/jesseduffield/lazygit/releases/latest&quot;</span> | grep -Po <span class="hljs-string">&#x27;&quot;tag_name&quot;: &quot;v\K[^&quot;]*&#x27;</span>)<br>curl -Lo lazygit.tar.gz <span class="hljs-string">&quot;https://github.com/jesseduffield/lazygit/releases/latest/download/lazygit_<span class="hljs-variable">$&#123;LAZYGIT_VERSION&#125;</span>_Linux_x86_64.tar.gz&quot;</span><br>tar xf lazygit.tar.gz lazygit<br>sudo install lazygit /usr/local/bin<br><span class="hljs-built_in">rm</span> lazygit  lazygit.tar.gz<br></code></pre></td></tr></table></figure><h2 id="nvitop">19.nvitop</h2><p>A better Nvidia monitor in top style.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pip3 install nvitop<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Guide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC迁移指南</title>
    <link href="/2021/12/15/2021-12-15-PC%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97/"/>
    <url>/2021/12/15/2021-12-15-PC%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>@ 2021.12.15 23:15 UTC+0800 v1</p><p>@ 2021.12.19 18:29 UTC+0800 v2</p><p>@ 2021.12.30 21:19 UTC+0800 v3</p><p>@ 2022.11.18 12:40 UTC+0800 v4</p></blockquote><p>由于在几次PC重装系统中多次遗忘备份文件或程序，特制定如下指南供将来参考。</p><h2 id="software">Software</h2><ol type="1"><li><p>Bandizip</p></li><li><p>CLion</p></li><li><p>Dism++</p></li><li><p>Dell Power Manager</p></li><li><p>Dev-sidecar (For github access et cetera)</p></li><li><p>DNS Benchmark</p></li><li><p>EarTrumpet</p></li><li><p>Epic Games Launcher</p></li><li><p>Everything</p></li><li><p>ExpressConnection</p></li><li><p>FileZilla Client</p></li><li><p>Format Factory</p></li><li><p>Free Download Manager</p></li><li><p>FreeFileSync</p></li><li><p>f.lux</p></li><li><p>GhostScript (For LaTex in Inkscape)</p></li><li><p>Git <strong><em>Config File forMulti-users</em></strong></p></li><li><p>GoLand</p></li><li><p>Google Chrome <strong><em>GreasyFork andExtensions</em></strong></p></li><li><p>ImageGlass</p></li><li><p>Inkscape</p></li><li><p>IntelliJ IDEA Ultimate</p></li><li><p>iTunes</p></li><li><p>JetBrains Toolbox</p></li><li><p>Lyricify</p></li><li><p>Matlab</p></li><li><p>Microsoft Edge <strong><em>Passwords and MSAccount</em></strong></p></li><li><p>MinGW</p></li><li><p>Notion</p></li><li><p>Netron</p></li><li><p>Obsidian</p></li><li><p>OpenConnection Connect</p></li><li><p>Origin</p></li><li><p>pandoc</p></li><li><p>PDFXEdit</p></li><li><p>PotPlayer 64 bit <strong><em>Config File for m3u LiveStream</em></strong></p></li><li><p>PowerToys</p></li><li><p>pstoedit (For LaTex in Inkscape)</p></li><li><p>PyCharm Professional</p></li><li><p>Python</p></li><li><p>QuickLook</p></li><li><p>rbtray</p></li><li><p>SDR-Cleaner</p></li><li><p>Send Anywhere</p></li><li><p>Snipaste</p></li><li><p>SpaceSniffer</p></li><li><p>Spotify</p></li><li><p>Steam</p></li><li><p>Steam++</p></li><li><p>Sublime Text</p></li><li><p>SumatraPDF</p></li><li><p>SyncTrayzor (Syncthing)</p></li><li><p>Teamviewer</p></li><li><p>Tencent Meeting</p></li><li><p>Termius</p></li><li><p>TIM <strong><em>User Folder</em></strong></p></li><li><p>Typora</p><p>Windows设置字体</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># in Typora Themes Folder </span><br>vim base.user.css <br>body &#123; <br>    font-family: <span class="hljs-string">&quot;A-Font&quot;</span>, <span class="hljs-string">&quot;Another-Font&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Ubisoft Connect</p></li><li><p>Veracrypt</p></li><li><p>Vim <strong><em>.vimrc</em></strong></p></li><li><p>Visual Studio Code <strong><em>Extensions</em></strong></p></li><li><p>VMware Workstation Pro <strong><em>VirtualMachines</em></strong></p></li><li><p>VNC Viewer</p></li><li><p>Wallpaper Engine <strong><em>Local Storage</em></strong></p></li><li><p>WeChat <strong><em>User Folder</em></strong></p></li><li><p>Windows Terminal</p></li><li><p>Xbox Accessories</p></li><li><p>Youdao Dictionary</p></li><li><p>Zotero <strong><em>Articles Library Backup</em></strong></p></li><li><p>向日葵</p></li><li><p>小黄条</p></li><li><p>火绒安全软件</p></li><li><p>闪点清单</p></li></ol><h2 id="files">Files</h2><ol type="1"><li>Repos</li><li>Sync for VMware</li><li>VirtualEnv , virtualenvwrapper-powershell and its PowershellScript</li><li>Program Scripts on Desktop</li><li>Wallpaper and Pictures Repo</li><li>Fonts</li><li>Zotero Repo</li><li>Miscellaneous</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Guide</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
