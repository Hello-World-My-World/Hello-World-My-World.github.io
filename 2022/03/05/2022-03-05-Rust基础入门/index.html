

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Doctor">
  <meta name="keywords" content="">
  
    <meta name="description" content="@ 2022.03.05 20:36 UTC+0800 v1  这是一篇面向有一定编程基础者的Rust基础入门指南，涵盖Rust的控制流，所有权，枚举，结构体，Trait，面向对象，并发等知识。  我从2022.02.04日正式开始学习Rust，经过半个寒假的拖拖拉拉的入门，终于在新学期开学后下定决心攻下这个难关。然而还是大大低估了Rust的难度，这一周多整天盯着电脑看教程才将剩下的一">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust基础入门">
<meta property="og:url" content="http://hello-world-my-world.github.io/2022/03/05/2022-03-05-Rust%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Hello-World-My-World">
<meta property="og:description" content="@ 2022.03.05 20:36 UTC+0800 v1  这是一篇面向有一定编程基础者的Rust基础入门指南，涵盖Rust的控制流，所有权，枚举，结构体，Trait，面向对象，并发等知识。  我从2022.02.04日正式开始学习Rust，经过半个寒假的拖拖拉拉的入门，终于在新学期开学后下定决心攻下这个难关。然而还是大大低估了Rust的难度，这一周多整天盯着电脑看教程才将剩下的一">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-03-05T12:36:00.000Z">
<meta property="article:modified_time" content="2023-09-07T05:17:05.134Z">
<meta property="article:author" content="Doctor">
<meta property="article:tag" content="Language">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Rust基础入门 - Hello-World-My-World</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"hello-world-my-world.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Hello World! This is my world.</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Rust基础入门"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-03-05 20:36" pubdate>
          March 5, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          39k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          322 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Rust基础入门</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>@ 2022.03.05 20:36 UTC+0800 v1</p>
</blockquote>
<p>这是一篇面向有一定编程基础者的Rust基础入门指南，涵盖Rust的控制流，所有权，枚举，结构体，<code>Trait</code>，面向对象，并发等知识。</p>
<blockquote>
<p>我从2022.02.04日正式开始学习Rust，经过半个寒假的拖拖拉拉的入门，终于在新学期开学后下定决心攻下这个难关。然而还是大大低估了Rust的难度，这一周多整天盯着电脑看教程才将剩下的一大半入门教学视频大致看完。希望以后的我还能依靠本文快速重新入门。</p>
</blockquote>
<!--TODO：动态大小与Sized Trait, ?Sized Trait约束-->
<!--TODO：宏-->
<!--TODO：Cargo和Crates.io-->
<h2 id="cargo">0. Cargo</h2>
<p>Cargo是Rust的构建系统与包管理系统。</p>
<h3 id="创建项目">0.1 创建项目</h3>
<p>cargo默认使用git管理版本，使用<code>--vcs</code>开关进行设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new project_name<br></code></pre></td></tr></table></figure>
<p>建立目录如下，其中源代码存储于<code>src</code>文件夹中，<code>.git/</code>和<code>.gitignore</code>为版本控制的配置文件，<code>Cargo.toml</code>为项目配置文件。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">project_name<br>├── Cargo<span class="hljs-selector-class">.toml</span><br>├── <span class="hljs-selector-class">.git</span><br>├── <span class="hljs-selector-class">.gitignore</span><br>└── <span class="hljs-attribute">src</span><br>    └── <span class="hljs-selector-tag">main</span>.rs<br></code></pre></td></tr></table></figure>
<h3 id="构建项目">0.2 构建项目</h3>
<p>根据rust源代码生成可执行文件，默认以debug模式。生成的可执行文件位于<code>target/debug/</code>。</p>
<p>也可以使用<code>--release</code>开关，以release模式构建，编译速度变慢但运行速度提升，生成的可执行文件位于<code>target/release/</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo build<br></code></pre></td></tr></table></figure>
<h3 id="运行项目">0.3 运行项目</h3>
<p>编译源代码并运行，若代码没有修改则直接运行已经存在的可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo run<br></code></pre></td></tr></table></figure>
<h3 id="项目编译检查">0.4 项目编译检查</h3>
<p>检查源代码是否能够通过编译，不生成可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo check<br></code></pre></td></tr></table></figure>
<h3 id="cargo.toml">0.5 Cargo.toml</h3>
<p>用于配置项目，在第一次项目编译的时候会生成<code>Cargo.lock</code>。</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;project_name&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br></code></pre></td></tr></table></figure>
<h2 id="常量变量可变性和原生类型">1. 常量、变量、可变性和原生类型</h2>
<h3 id="常量">1.1 常量</h3>
<p>Rust的常量声明使用<code>const</code>关键字，需要显式声明常量的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> CONST_NUM: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<h3 id="不可变变量">1.2 不可变变量</h3>
<p>定义一个不可变变量的过程称为绑定。不可变变量一经绑定不能重新赋值修改，但可以重新绑定，绑定前后的类型不需要一致。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">variable</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>一般编译器会推断出所绑定的变量类型，而不需要显式声明，若给定的信息不足以推断出变量类型，则需要手动声明变量类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">variable</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">variable</span>: <span class="hljs-type">i32</span> = <span class="hljs-string">&quot;42&quot;</span>.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Not a Num&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="可变变量">1.3 可变变量</h3>
<p>可变变量是可以被赋值、被修改的变量，但被修改前后的类型必须一致。定义一个可变变量的方法如下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">variable</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">variable</span>: <span class="hljs-type">i32</span> = <span class="hljs-string">&quot;42&quot;</span>.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Not a Num&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="let解构">1.4 <code>let</code>解构</h3>
<p>可以在一个<code>let</code>语句中绑定多个变量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (a, <span class="hljs-keyword">mut</span> b): (<span class="hljs-type">bool</span>,<span class="hljs-type">bool</span>) = (<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>
<h3 id="原生类型">1.5 原生类型</h3>
<p>原生类型不支持自动的类型转换，需要强制转换时使用<code>variable as type</code></p>
<ul>
<li>整数类型
<ul>
<li>有符号：<code>i8</code>、<code>i16</code>、<code>i32</code>（默认）<code>i64</code>、<code>i128</code>、<code>isize</code></li>
<li>无符号：<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code>、<code>usize</code></li>
<li>字面值：支持下划线分割（<code>12_34</code>）、支持<code>0x</code>、<code>0o</code>、<code>0b</code>头、支持以类型名作为后缀指定类型(<code>42u8</code>)、字符(只有<code>u8</code>:
<code>b'A'</code>)</li>
</ul></li>
<li>浮点数类型
<ul>
<li>单精度： <code>f32</code></li>
<li>双精度：<code>f64</code>（默认）</li>
</ul></li>
<li>布尔类型
<ul>
<li><code>bool</code>：<code>true</code> / <code>false</code></li>
</ul></li>
<li>字符类型（4字节Unicode）
<ul>
<li><code>char</code></li>
</ul></li>
</ul>
<h2 id="元组-tuple">2. 元组 Tuple</h2>
<h3 id="元组的声明">2.1 元组的声明</h3>
<p>元组是一种将多个不同类型的值组合在一起的类型，元组的长度与各位置的类型一经确定不能更改，但可变元组变量的成员元素能够修改。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tuple</span> :(<span class="hljs-type">i32</span>, <span class="hljs-type">u32</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tuple</span> = (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span>);<br></code></pre></td></tr></table></figure>
<h3 id="元组的访问">2.2 元组的访问</h3>
<p>使用<code>tuple.index</code>对元组的各个成员进行访问。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">tuple.<span class="hljs-number">0</span> = <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure>
<h3 id="元组的解构">2.3 元组的解构</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (x, y, z) = tuple;<br></code></pre></td></tr></table></figure>
<h2 id="数组-array">3. 数组 Array</h2>
<h3 id="数组的声明">3.1 数组的声明</h3>
<p>数组是一种将多个同样类型的值组合在一起的类型，数组的长度与成员类型一经确定不能更改，但可变数组变量的成员元素能够修改。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">array</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">array</span> = [value; CONST_LENGTH];<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">array</span> = [<span class="hljs-number">0</span>; <span class="hljs-number">5</span>]; <span class="hljs-comment">// 长度为5填充0</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">array</span>: [<span class="hljs-type">i32</span>: <span class="hljs-number">3</span>] = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure>
<h3 id="数组的访问">3.2 数组的访问</h3>
<p>使用<code>array[index]</code>对数组的各个成员进行访问。下标越界时可能能够通过编译但运行时<code>panic</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">array[<span class="hljs-number">0</span>] = <span class="hljs-number">9</span>;<br></code></pre></td></tr></table></figure>
<h2 id="函数">4. 函数</h2>
<h3 id="函数的声明">4.1 函数的声明</h3>
<p>函数体以一系列语句组成，可以选择使用<code>return</code>语句返回值，或在函数体最后以一行表达式结尾作为返回。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function_name</span>(parameter: para_type)<span class="hljs-punctuation">-&gt;</span>return_type&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="语句与表达式">4.2 语句与表达式</h3>
<ul>
<li>语句: 执行一系列操作并返回空的元组，以<code>;</code>结尾</li>
<li>表达式: 计算并返回值，没有<code>;</code>结尾</li>
</ul>
<h3 id="函数的传参">4.3 函数的传参</h3>
<p>函数的传参涉及到所有权的转移，在没有使用借用的情况下，形参重新绑定变量获得所有权。默认的形参不可变，需要加<code>mut</code>可变。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>(<span class="hljs-keyword">mut</span> parameter: para_type)&#123;<br>    <span class="hljs-comment">// change or re-assign parameter here</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="if-else表达式">5. if-else表达式</h2>
<p><code>if-else</code>中的条件部分只支持布尔条件表达式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> condition_expression&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition_expression&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>if-else</code>是一种表达式，可以有返回值，并且所有分支都必须返回相同的类型。可以利用该特点构造赋值时的<code>if-else</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">if</span> condition &#123;variable0&#125; <span class="hljs-keyword">else</span> &#123;variable1&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="loop循环">6. loop循环</h2>
<p><code>loop</code>循环是一种无限循环，可以使用<code>break</code>退出本层循环，也可以使用<code>continue</code>跳过本轮循环的余下部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">loop</span>&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>存在多层循环时，可以使用<code>break</code>+<code>'label</code>跳出多层循环。该特性也可以用于其他循环语句。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-symbol">&#x27;outer</span>:<br><span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-symbol">&#x27;inner</span>:<br>    <span class="hljs-keyword">loop</span>&#123;<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 跳出一层</span><br>        <span class="hljs-keyword">break</span> <span class="hljs-symbol">&#x27;outer</span>; <span class="hljs-comment">//跳出两层</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><code>break</code>后可以接一个表达式，这样该表达式就会作为<code>loop</code>循环表达式的返回值返回。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">loop</span> &#123;<br>    counter += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="while循环">7. while循环</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> condition_expression&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="for循环">8. for循环</h2>
<p><code>for</code>循环用于对迭代器进行遍历。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">Iterator</span>&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>一些常见的迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust">start..end <span class="hljs-comment">// 左闭右开</span><br>start..=end <span class="hljs-comment">// 闭区间</span><br>(start..end).<span class="hljs-title function_ invoke__">rev</span>() <span class="hljs-comment">// 反向</span><br>(start..end).<span class="hljs-title function_ invoke__">step_by</span>(step) <span class="hljs-comment">// 设置步长</span><br>[].<span class="hljs-title function_ invoke__">iter</span>() <span class="hljs-comment">// 借用转为迭代器</span><br>[].<span class="hljs-title function_ invoke__">into_iter</span>() <span class="hljs-comment">// 移动转为迭代器</span><br>[].<span class="hljs-title function_ invoke__">iter_mut</span>() <span class="hljs-comment">// 可变借用转为迭代器</span><br></code></pre></td></tr></table></figure>
<h2 id="所有权">9. 所有权</h2>
<h3 id="栈内存stack与堆内存heap">9.1 栈内存（Stack）与堆内存（Heap)</h3>
<ul>
<li><p>栈内存：</p>
<p>在栈内存上的数据必须拥有已知固定大小，快。</p></li>
<li><p>堆内存：</p>
<p>在栈内存上的数据不必拥有已知固定大小，需要通过指针访问，慢。</p></li>
</ul>
<h3 id="所有权规则">9.2 所有权规则</h3>
<ul>
<li>每一个值都有一个变量，该变量称为值的所有者</li>
<li>每一个值同时只能有一个所有者</li>
<li>当值的所有者超出作用域（scope）<code>&#123;&#125;</code> 时，这个值被删除</li>
</ul>
<h3 id="移动move">9.3 移动（Move）</h3>
<p>对于没有实现<code>Copy</code>
trait的类型，在进行赋值（<code>let x = y</code>）或通过值来传递函数参数（<code>func(x)</code>）的时候，资源的所有权（ownership）会发生转移，也就是移动。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var0</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>); <span class="hljs-comment">// String is on Heap</span><br>    <span class="hljs-comment">// var0 -&gt; HeapMem(&quot;String(&quot;Hello, World&quot;)&quot;)</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var1</span>: <span class="hljs-type">String</span>;<br>    <span class="hljs-comment">// var0 -&gt; HeapMem(&quot;String(&quot;Hello, World&quot;)&quot;)</span><br>    <span class="hljs-comment">// var1 -&gt; </span><br>    var1 = var0;<br>    <span class="hljs-comment">// var0 -&gt; </span><br>    <span class="hljs-comment">// var1 -&gt; HeapMem(&quot;String(&quot;Hello, World&quot;)&quot;)</span><br>    <span class="hljs-comment">// invalid visit to var0</span><br>&#125;<br><span class="hljs-comment">// Out of the scope, HeapMem free by owner: var1</span><br></code></pre></td></tr></table></figure>
<p>如果需要保持原变量的所有权，可以实现并使用<code>Clone</code>
trait，创建副本。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var0</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>); <span class="hljs-comment">// String is on Heap</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var1</span> = var0.<span class="hljs-title function_ invoke__">clone</span>();<br>&#125;<br><span class="hljs-comment">// Out of the scope, HeapMem free by owner: var1</span><br></code></pre></td></tr></table></figure>
<p>对于实现了<code>Copy</code>
trait的类型，Rust在赋值的时候会自动拷贝内存，生成副本，此时两个副本的所有权相互独立互不影响。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var0</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">42</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var1</span>: <span class="hljs-type">i32</span> = var0;<br>    <span class="hljs-comment">// both var0 and var1 are valid</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>常见的实现了<code>Copy</code> trait的基本类型：</p>
<ul>
<li>整数，浮点数，布尔类型，字符类型，所有元素类型均实现了<code>Copy</code>
trait的元组</li>
<li>任何简单标量的组合类型都可以是</li>
<li>任何需要分配内存或某种资源的均不是</li>
</ul>
<h3 id="引用与借用">9.4 引用与借用</h3>
<p>允许使用某些值但不获取其所有权的方法称为引用。引用<code>&amp;</code>默认是不可变的，对于引用一个可变变量时，可以使用<code>mut</code>标记为可变的。引用不具有值的所有权，所以不负责释放值。</p>
<p>引用的作用域是声明开始到最后一次使用为止。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">var0</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">var1</span> = &amp;var0;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">var2</span> = &amp;<span class="hljs-keyword">mut</span> var0;<br></code></pre></td></tr></table></figure>
<p>也可以使用<code>ref</code>关键字创建引用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">ref</span> var1 = var0;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">ref</span> <span class="hljs-keyword">mut</span> var2 = var0;<br></code></pre></td></tr></table></figure>
<p>在函数传参时发生的引用称为借用。借用默认是不可变的，对于借用一个可变变量时，可以使用<code>mut</code>标记为可变的。同样地，借用也不负责释放值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">addSuffix</span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>)&#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">var0</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>    <span class="hljs-title function_ invoke__">addSuffix</span>(&amp;<span class="hljs-keyword">mut</span> var0);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, var0);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong><em>在特定的作用域内，对于同一块数据存在以下的限制</em></strong>：</p>
<ul>
<li>不能存在多个可变引用</li>
<li>存在可变引用时，不能存在不可变引用</li>
</ul>
<p>或者说，<strong><em>对于同一块数据的引用，在特定的作用域内只能同时满足以下中的一个</em></strong>：</p>
<ul>
<li>存在一个可变引用</li>
<li>存在多个不可变引用</li>
</ul>
<p>另外地，Rust不支持悬空引用(Dangle
Refernece)，即当引用的变量因离开作用域等原因被销毁后还存在引用时，Rust报错。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">addSuffix</span>(<span class="hljs-keyword">mut</span> s: <span class="hljs-type">String</span>)&#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;!&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">var0</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>    <span class="hljs-title function_ invoke__">addSuffix</span>(var0);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;var0); <span class="hljs-comment">// moved out of scope</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-keyword">return</span> &amp;s;<br>&#125; <span class="hljs-comment">// moved out</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="切片">10. 切片</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;s1[..];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">array</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = &amp;array[<span class="hljs-number">1</span>..<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure>
<h2 id="结构体">11. 结构体</h2>
<h3 id="结构体的定义">11.1 结构体的定义</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    field_name0: field_type0,<br>    field_name1: field_type1,<br>    field_name2: field_type2,<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="结构体的实例化">11.2 结构体的实例化</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">struct_name&#123;<br>    field_name0: field_value0,<br>    field_name1: field_value1,<br>    field_name2: field_value2,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当字段名和字段所赋值的变量同名时，可以省去一个</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">struct_name&#123;<br>    name0,<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="结构体字段的访问">11.3 结构体字段的访问</h3>
<p>若结构体实例是可变的则其各个字段均可变，不能对字段单独设置可变性。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">struct_variable.field_name<br></code></pre></td></tr></table></figure>
<h3 id="结构体的更新">11.4 结构体的更新</h3>
<p>根据一个已经存在的结构体实例生成新的实例。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">struct_name&#123;<br>    field_name0: field_value0,<br>    ..old_one <span class="hljs-comment">// 余下字段与old相同</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="元组结构体">11.5 元组结构体</h3>
<p>不给定字段名称的结构体。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>(field_type0, field_type1);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">struct_name</span>(value0, value1);<br></code></pre></td></tr></table></figure>
<p>需要注意的是，完全具有相同字段类型的两个<code>Tuple Struct</code>不算同类型的结构体。对<code>Tuple Struct</code>的访问与解构均与<code>Tuple</code>类似。</p>
<h3 id="结构体方法">11.6 结构体方法</h3>
<p>结构体的方法定义在一个<code>impl</code>块中，一个结构体可以有多个<code>impl</code>块。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    field_name0: field_type0,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name0</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-comment">// pass</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name1</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-comment">// pass</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name2</span>(<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-comment">// pass</span><br>    &#125;<br>&#125;<br>struct_var.<span class="hljs-title function_ invoke__">method_name0</span>();<br></code></pre></td></tr></table></figure>
<h3 id="结构体关联函数">11.7 结构体关联函数</h3>
<p>定义在<code>impl</code>块内，但不把<code>self</code>作为第一个参数的函数。常用于构造器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    field_name0: field_type0,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name0</span>()&#123;<br>        <span class="hljs-comment">// pass</span><br>    &#125;<br>&#125;<br>struct_name::<span class="hljs-title function_ invoke__">method_name0</span>();<br></code></pre></td></tr></table></figure>
<h2 id="枚举">12. 枚举</h2>
<p>通过列举所有可能的取值来定义一个类型。</p>
<h3 id="枚举的定义">12.1 枚举的定义</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">enum_name</span>&#123;<br>    possible_option0,<br>    possible_option1,<br>    <span class="hljs-title function_ invoke__">possible_option2</span>(type0), <span class="hljs-comment">// 关联附加数据</span><br>    <span class="hljs-title function_ invoke__">possible_option3</span>(type1, type2, type3),<br>    possible_option4 &#123;x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>&#125;, <span class="hljs-comment">//匿名结构体</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="枚举的实例化">12.2 枚举的实例化</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = enum_name::possible_option0;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = enum_name::<span class="hljs-title function_ invoke__">possible_option3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = enum_name::possible_option4&#123;x: <span class="hljs-number">4</span>, y: <span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="枚举方法">12.3 枚举方法</h3>
<p>与结构体一样，枚举的方法定义在一个<code>impl</code>块中，一个枚举可以有多个<code>impl</code>块。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">enum_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-comment">// pass</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="枚举关联函数">12.4 枚举关联函数</h3>
<p>与结构体一样，枚举也有关联函数。</p>
<h3 id="option枚举">12.5 <code>Option</code>枚举</h3>
<p>位于预导入模块中的描述一个值可能存在，可能不存在的情况。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// definition of enum Option</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt;&#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中的<code>None</code>用于表示某种类型的空值，需要使用<code>Option::Some(T)</code>中的时，可以使用<code>unwrap()</code>枚举方法取出。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Option</span>::<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">d</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Option</span>::&lt;<span class="hljs-type">i32</span>&gt;::<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">e</span> = <span class="hljs-type">Option</span>::&lt;<span class="hljs-type">i32</span>&gt;::<span class="hljs-literal">None</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br></code></pre></td></tr></table></figure>
<h2 id="match表达式与if-let">13. match表达式与if-let</h2>
<p><code>match</code>需要穷尽所有可能。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> variable&#123;<br>    pattern0 =&gt; arm0,<br>    pattern1 =&gt; &#123;<br>        arm1,<br>    &#125;,<br>    pattern2 | pattern3 =&gt; arm,<br>    <span class="hljs-title function_ invoke__">pattern4</span>(x, y) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, x, y), <span class="hljs-comment">//解构</span><br>    _ =&gt; (), <span class="hljs-comment">// default arm</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>if-let</code>放弃了穷举，只关心一种匹配。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> variable&#123;<br>    pattern =&gt; arm0,<br>    _ =&gt; (),<br>&#125;<br><br><span class="hljs-comment">// if-let等效</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">pattern</span> = variable&#123;<br>    arm0;<br>&#125;<br><br><span class="hljs-keyword">match</span> variable&#123;<br>    pattern =&gt; arm0,<br>    _ =&gt; arm1,<br>&#125;<br><br><span class="hljs-comment">// if-let等效</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">pattern</span> = variable&#123;<br>    arm0;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    arm1;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="package-crate-module">14. <code>Package</code>,
<code>crate</code>, <code>module</code></h2>
<h3 id="package">14.1 Package</h3>
<p>Cargo 的一个功能，它允许你构建、测试和分享 crate。</p>
<p>包含一个<code>Cargo.toml</code>文件，描述了如何构建<code>package</code>中的<code>crate</code></p>
<p>只能包含0-1个<code>library crate</code>，可以包含任意多数量的<code>binary crate</code>，但至少包含一个人以种类的<code>crate</code>。</p>
<h3 id="crate">14.2 Crate</h3>
<p>一个模块树，可以产生一个<code>library</code>或可执行文件。</p>
<ul>
<li><code>binary crate</code></li>
<li><code>library crate</code></li>
</ul>
<p><code>crate root</code>是一个源代码文件，指示Rust编译器从此开始组成<code>crate</code>的根<code>module</code>。</p>
<ul>
<li><code>src/main.rs</code>默认是<code>binary crate</code>的<code>crate root</code>，其<code>crate</code>名与<code>package</code>名相同</li>
<li><code>src/lib.rs</code>默认是<code>library crate</code>的<code>crate root</code>，其<code>crate</code>名与<code>package</code>名相同</li>
<li><code>src/bin/</code>下的文件均为单独的<code>binary crate</code></li>
</ul>
<h3 id="module">14.3 Module</h3>
<p>控制代码的组织、作用于与私有路径。</p>
<p><code>module</code>可以嵌套，可以包含其他项的定义。</p>
<p><code>module</code>与其内部所定义的项均默认为私有的：</p>
<ul>
<li>父模块无法访问子模块内的私有项</li>
<li>子模块中可以访问父模块中的项</li>
</ul>
<p>可以使用<code>pub</code>关键字声明为公有的项。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> module_name&#123;<br>    <span class="hljs-keyword">mod</span> inner_module_name&#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function_name</span>()&#123;<br>        &#125;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">structure_name</span>&#123;<br>        &#125;<br>        <span class="hljs-keyword">enum</span> <span class="hljs-title class_">enum_name</span>&#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">crate<br>└── <span class="hljs-keyword">module</span><span class="hljs-number">_n</span>ame<br>   └── inner<span class="hljs-number">_m</span>odule<span class="hljs-number">_n</span>ame<br>       ├── enum<span class="hljs-number">_n</span>ame<br>       ├── <span class="hljs-keyword">function</span><span class="hljs-number">_n</span>ame<br>       └── structure<span class="hljs-number">_n</span>ame<br></code></pre></td></tr></table></figure>
<h3 id="路径">14.4 路径</h3>
<p>Rust为了在模块中找到特定的项，需要使用路径。路径由一个或者多个标识符构成，不同标识符之间使用<code>::</code>分割。</p>
<ul>
<li>绝对路径</li>
</ul>
<p>从<code>crate root</code>开始描述路径，使用<code>crate</code>关键字表示当前<code>crate</code>的<code>crate root</code>或者使用<code>crate</code>名指定其他<code>crate</code>的<code>crate root</code>。</p>
<ul>
<li>相对路径</li>
</ul>
<p>从当前<code>module</code>开始，依靠<code>self</code>，<code>super</code>等关键字指定路径</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// package_name: package</span><br><span class="hljs-comment">// file: src/lib.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> outer_scope0&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">say_hello</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> outer_scope1&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> inner_scope&#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_again</span>()&#123;<br>            self::super::super::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>            crate::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_triple</span>()&#123;<br>        super::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>        self::inner_scope::<span class="hljs-title function_ invoke__">hello_again</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// file: src/main.rs</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    package::outer_scope1::<span class="hljs-title function_ invoke__">hello_triple</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="use关键字">14.5 <code>use</code>关键字</h3>
<p>将路径或者项导入到作用域中，遵守私有性规则，导入后默认为私有，不能被外部代码访问，可用<code>pub</code>关键字转为公有，可以使用<code>as</code>关键字指定本地别名。</p>
<p>若需要导入的项有重名的，可以分别导入它们的父模块，使用时从父模块指明项避免冲突。</p>
<p>一般地，导入函数时导入其父模块，导入其他类型的项时导入其本身。</p>
<p>导入时可以使用嵌套路径<code>相同::&#123;不同&#125;</code>省略重复部分。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// file: src/main.rs</span><br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, Write&#125;;<br><span class="hljs-keyword">use</span> std::collections::*;<br><span class="hljs-keyword">use</span> package::outer_scope1;<br><span class="hljs-keyword">use</span> package::outer_scope1::hello_triple <span class="hljs-keyword">as</span> three_times_of_hello;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>	outer_scope1::<span class="hljs-title function_ invoke__">hello_triple</span>();<br>    <span class="hljs-title function_ invoke__">three_times_of_hello</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="模块签名">7.6 模块签名</h3>
<p>模块体内可以不直接给出而以<code>;</code>结束，此时为模块签名。Rust会根据<code>crate</code>路径搜索与<code>crate</code>路径同名路径下的与模块同名的<code>.rs</code>文件寻找具体定义，或者与<code>crate</code>路径同名路径下的与模块同名文件夹内的<code>mod.rs</code>文件寻找具体定义。以上代码分离不会导致<code>crate</code>树改变。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">── <span class="hljs-attribute">src</span><br>   ├── lib<span class="hljs-selector-class">.rs</span><br>   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.rs</span><br>   ├── outer_scope0<span class="hljs-selector-class">.rs</span><br>   └── outer_scope1<br>       ├── inner_scope<span class="hljs-selector-class">.rs</span><br>       └── mod.rs<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// file: src/lib.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> outer_scope0;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> outer_scope1;<br><br><span class="hljs-comment">// file: src/outer_scope0.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">say_hello</span>()&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// file: src/outer_scope1/mod.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> inner_scope;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_triple</span>()&#123;<br>    super::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>    self::inner_scope::<span class="hljs-title function_ invoke__">hello_again</span>();<br>&#125;<br><br><span class="hljs-comment">// file: src/outer_scope1/inner_scope.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_again</span>()&#123;<br>    self::super::super::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>    crate::outer_scope0::<span class="hljs-title function_ invoke__">say_hello</span>();<br>&#125;<br><br><span class="hljs-comment">// file: src/main.rs</span><br><span class="hljs-keyword">use</span> package::outer_scope1;<br><span class="hljs-keyword">use</span> package::outer_scope1::hello_triple <span class="hljs-keyword">as</span> three_times_of_hello;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>	outer_scope1::<span class="hljs-title function_ invoke__">hello_triple</span>();<br>    <span class="hljs-title function_ invoke__">three_times_of_hello</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="错误处理">15. 错误处理</h2>
<p>错误分为：</p>
<ul>
<li>可恢复错误：依靠<code>Result&lt;T, E&gt;</code>枚举实现</li>
<li>不可恢复错误：<code>panic!()</code></li>
</ul>
<h3 id="不可恢复错误与panic">15.1不可恢复错误与<code>panic!</code></h3>
<p>执行<code>panic!()</code>宏时，Rust：</p>
<ul>
<li>打印提供的错误信息</li>
<li>默认展开并清理调用栈，工作量大，使得发布程序大，或设置<code>Cargo.toml</code>立即中止调用栈交操作系统清理</li>
<li>退出程序</li>
</ul>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[profile.release]</span><br><span class="hljs-attr">panic</span> = <span class="hljs-string">&quot;abort&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="可恢复错误与resultt-e">15.2
可恢复错误与<code>Result&lt;T, E&gt;</code></h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="使用match处理可恢复错误">15.2.1
使用<code>match</code>处理可恢复错误</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error)<br>        &#125;,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="错误类型匹配与嵌套错误处理">15.2.2
错误类型匹配与嵌套错误处理</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::ErrorKind;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">match</span> error.<span class="hljs-title function_ invoke__">kind</span>() &#123;<br>            ErrorKind::NotFound =&gt; <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>) &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(fc) =&gt; fc,<br>                <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),<br>            &#125;,<br>            other_error =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),<br>        &#125;,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="闭包的错误处理方法">15.2.3 闭包的错误处理方法</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::ErrorKind;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|error| &#123;<br>        <span class="hljs-keyword">if</span> error.<span class="hljs-title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;<br>            File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|error| &#123;<br>                <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, error);<br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="unwrap方法">15.2.4 <code>unwrap</code>方法</h4>
<p><code>unwrap</code>方法支持直接将<code>Ok</code>内的值提取出来，如果是<code>Err</code>则直接触发<code>panic!</code>，但不能设置<code>panic</code>信息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="expect方法">15.2.5 <code>expect</code>方法</h4>
<p><code>expect</code>方法支持直接将<code>Ok</code>内的值提取出来，如果是<code>Err</code>则直接触发<code>panic!</code>，返回的设置<code>panic</code>信息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to open hello.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="传播错误">15.2.6 传播错误</h4>
<p>在一个<strong><em>函数内部</em></strong>发生可恢复错误时，可以选择不加处理而将错误返回给调用者，让调用者决定处理方式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(e),<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br>    <span class="hljs-keyword">match</span> f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(s),<br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-title function_ invoke__">Err</span>(e),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="运算符">15.2.7 <code>?</code>运算符</h4>
<p>简化错误传播，有值时直接提取，是错误时直接返回错误。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file_</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br>    File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>main</code>函数中使用<code>?</code>运算符需要修改<code>main</code>函数的返回类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt;&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="常用collections">16. 常用<code>collections</code></h2>
<h3 id="vec">16.1 <code>Vec</code></h3>
<p><code>Vec</code>是由<code>std</code>标准库提供的。<code>Vec</code>中的值为同类型的元素，在内存中连续存放。</p>
<h4 id="vec的创建">16.1.1 <code>Vec</code>的创建</h4>
<ul>
<li>创建空的<code>Vec</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;type_name&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>使用<code>vec!</code>创建带初始值的<code>Vec</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure>
<h4 id="vec添加元素">16.1.2 <code>Vec</code>添加元素</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure>
<h4 id="vec访问元素">16.1.3 <code>Vec</code>访问元素</h4>
<ul>
<li>索引访问，越界时直接<code>panic</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 直接索引，需要实现`copy` trait</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = v[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// 引用索引</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = &amp;v[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>
<ul>
<li><code>get</code>方法访问，返回<code>Option&lt;&amp;type_name&gt;</code>枚举，其中有效部分为引用</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: &amp;<span class="hljs-type">i32</span> = v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure>
<h4 id="vec遍历元素">16.1.4<code>Vec</code>遍历元素</h4>
<ul>
<li>移动遍历</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> v&#123;<br>    <span class="hljs-comment">// v.into_iter()</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>不可变引用遍历</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;v&#123;<br>    <span class="hljs-comment">// v.iter()</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>可变引用遍历</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v&#123;<br>    <span class="hljs-comment">// v.iter_mut()</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="借助enum枚举实现不同类型vec元素">16.1.5
借助<code>enum</code>枚举实现不同类型<code>Vec</code>元素</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Item</span>&#123;<br>    <span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-type">i32</span>),<br>    <span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<br>        Item::<span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-number">1</span>),<br>        Item::<span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-number">2.0</span>),<br>        Item::<span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;3&quot;</span>)),<br>    ];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="string">16.2 <code>String</code></h3>
<p>使用<code>UTF-8</code>编码，对<code>Vec&lt;u8&gt;</code>的包装。</p>
<h4 id="string创建">16.2.1 <code>String</code>创建</h4>
<ul>
<li>创建空<code>String</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>创建带初始值的<code>String</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;World&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br></code></pre></td></tr></table></figure>
<h4 id="string更新">16.2.2 <code>String</code>更新</h4>
<ul>
<li>添加字符串切片</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;!&quot;</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>添加字符</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&#x27;!&#x27;</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>连接字符串</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s0</span> = <span class="hljs-string">&quot;Hello &quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-string">&quot;World!&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-comment">// String + &amp;str</span><br><span class="hljs-comment">// 解引用强制转换&amp;String -&gt; &amp;str</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s0 + &amp;s1;<br><span class="hljs-comment">// s0 moved out</span><br><span class="hljs-comment">// s1 valid</span><br></code></pre></td></tr></table></figure>
<h4 id="format">16.2.3 <code>format!</code></h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;-&#123;&#125;&quot;</span>, s0, s1);<br></code></pre></td></tr></table></figure>
<h4 id="string的索引切割与遍历">16.2.4
<code>String</code>的索引、切割与遍历</h4>
<p><code>String</code>不允许索引，只允许沿<code>u8</code>表示<code>unicode</code>的边界切割。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 按u8遍历</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>&#125;<br><br><span class="hljs-comment">// 按unicode编码遍历</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">chars</span>()&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="hashmapk-v">16.3 <code>HashMap&lt;K, V&gt;</code></h3>
<h4 id="hashmap创建">16.3.1 <code>HashMap</code>创建</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">dict</span>:HashMap&lt;<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li>由<code>Vec&lt;(K, V)&gt;</code>创建</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">dict</span>: HashMap&lt;_, _&gt; = <span class="hljs-built_in">vec!</span>[(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">50</span>, <span class="hljs-number">100</span>)].<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-comment">// HashMap&lt;_, &gt;不可省略</span><br></code></pre></td></tr></table></figure>
<ul>
<li>由两个<code>Vec</code>创建</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">keys</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">values</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">dict</span>: HashMap&lt;_, _&gt; = keys.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>(values.<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure>
<h4 id="hashmap的插入">16.3.2 <code>HashMap</code>的插入</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">dict.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>
<h4 id="hashmap的遍历">16.3.3 <code>HashMap</code>的遍历</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-title function_ invoke__">for</span> (i, j) <span class="hljs-keyword">in</span> dict&#123;<br>    <span class="hljs-comment">// </span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="hashmap的访问">16.3.4 <code>HashMap</code>的访问</h4>
<ul>
<li>索引访问，接受<code>&amp;key</code>，不存在时直接<code>panic</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">dict[&amp;<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure>
<ul>
<li><code>get</code>方法，接受<code>&amp;key</code>，返回<code>Option</code>枚举</li>
</ul>
<h4 id="hashmap的更新">16.3.5 <code>HashMap</code>的更新</h4>
<ul>
<li><code>entry</code>方法与<code>Entry</code>枚举</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">dict.<span class="hljs-title function_ invoke__">entry</span>(key_type);<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// std::collections::hash_map::Entry</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Entry</span>&lt;<span class="hljs-symbol">&#x27;a</span>, K: <span class="hljs-symbol">&#x27;a</span>, V: <span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Occupied</span>(OccupiedEntry&lt;<span class="hljs-symbol">&#x27;a</span>, K, V&gt;),<br>    <span class="hljs-title function_ invoke__">Vacant</span>(VacantEntry&lt;<span class="hljs-symbol">&#x27;a</span>, K, V&gt;),<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>覆盖更新</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">dict.<span class="hljs-title function_ invoke__">insert</span>(key, value);<br></code></pre></td></tr></table></figure>
<ul>
<li>不存在时添加</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">dict.<span class="hljs-title function_ invoke__">entry</span>(key).<span class="hljs-title function_ invoke__">or_insert</span>(value);<br><span class="hljs-comment">// 若存在则返回可变引用</span><br><span class="hljs-comment">// 若不存在则插入新值并返回其可变引用</span><br></code></pre></td></tr></table></figure>
<ul>
<li>存在时更新</li>
</ul>
<p>即对可变引用的修改</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">count</span> = dict.<span class="hljs-title function_ invoke__">entry</span>(key).<span class="hljs-title function_ invoke__">or_insert</span>(value);<br>*count += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<h2 id="泛型">17. 泛型</h2>
<p>放在函数名、结构体名、枚举名或<code>Trait</code>名后的尖括号内的类型或其他属性的抽象占位符的形式。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function_name</span>&lt;T&gt; <span class="hljs-punctuation">-&gt;</span> T&#123;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">structure_name</span>&lt;T, U&gt;&#123;<br>    field0:T, <br>    field1:U,<br>&#125;<br><br><span class="hljs-comment">// 对任意类型的泛形方法定义在impl后要加&lt;&gt;</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; structure_name&lt;T&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 对指定类型的方法定义在impl后不要加&lt;&gt;</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">structure_name</span>&lt;<span class="hljs-type">i32</span>&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="trait">18. <code>Trait</code></h2>
<p>某个特定类型拥有可能与其他类型共享的功能。实现了该<code>Trait</code>的类型必须提供其中所有的方法。</p>
<h3 id="trait的定义">18.1 <code>Trait</code>的定义</h3>
<p>将方法前面放在一起，以定义实现某种目的的一系列行为。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name0</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> type_name;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name1</span>(&amp;<span class="hljs-keyword">self</span>);<br>    <span class="hljs-comment">// 给出函数签名</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="trait的实现">18.2 <code>Trait</code>的实现</h3>
<p>孤儿规则：<code>Trait</code>或类型中的一个必须在本<code>crate</code>中定义，不能为一个外部类型实现一个外部<code>Trait</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">item_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name0</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> type_name&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">item_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name1</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="trait方法的默认实现">18.3 <code>Trait</code>方法的默认实现</h3>
<p>可以在<code>Trait</code>定义时给出方法的方法体作为默认实现，定义时可以使用<code>Trait</code>中签名的其他方法。</p>
<h3 id="trait作为参数">18.4 <code>Trait</code>作为参数</h3>
<ul>
<li><code>impl trait</code>语法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>(parameter: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span>)&#123;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>(parameter: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name0</span> + trait_name1)&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>Trait bound</code>语法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>&lt;T: trait_name&gt;(parameter: T)&#123;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>&lt;T: trait_name0 + trait_name1&gt;(parameter: T)&#123;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>&lt;T, U&gt;(parameter0: T, parameter1: U)<br><span class="hljs-keyword">where</span> <br>T: trait_name0 + trait_name1, <br>U: trait_name3 + trait_name4 &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="trait作为返回">18.5 <code>Trait</code>作为返回</h3>
<p>返回的具体类型必须在任何情况下均一致。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">funciton_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="trait有条件地实现泛型方法">18.6
<code>Trait</code>有条件地实现泛型方法</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; struct_name&lt;T&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method0</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: trait_name&gt; struct_name&lt;T&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method1</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 任何类型struct_name实例均有method0方法</span><br><span class="hljs-comment">// 只有实现了trait_name的struct_name实例有method1方法</span><br></code></pre></td></tr></table></figure>
<h3 id="覆盖实现">18.7 覆盖实现</h3>
<p>对于任意已经实现了指定<code>Trait</code>的类型，定义实现某另个<code>Trait</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: trait_name0&gt; trait_name1 <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span>&#123;<br>    <span class="hljs-comment">// 对于任意实现了trait_name0的类型 定义实现trait_name1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="泛型trait">18.8 泛型<code>Trait</code></h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name0</span>&#123;<br>    field: type_name,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name1</span>&lt;T&gt;&#123;<br>    field: T,<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span>&lt;<span class="hljs-type">i32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">struct_name0</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;type_name &#123;<br>        &amp;(<span class="hljs-keyword">self</span>.field)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; trait_name&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">struct_name1</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;(<span class="hljs-keyword">self</span>.field)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="生命周期">19. 生命周期</h2>
<p>Rust
中的每一个引用都有其生命周期，也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，但当编译器无法自动推断出引用的生命周期时，需要手动标注生命周期。</p>
<h3 id="生命周期标注语法">19.1 生命周期标注语法</h3>
<p>Rust使用泛型生命周期的语法进行标注。其中用<code>&lt;'a&gt;</code>泛型声明生存周期，在引用号<code>&amp;</code>后紧跟生存周期进行标注，如<code>&amp;'a i32</code>、
<code>&amp;'a mut i32</code>。生命周期的标注仅描述多个引用的生命周期之间的关系，但不影响具体的生命周期。</p>
<ul>
<li>函数的生命周期</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longer</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>&#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 声明存在一个生命周期 &#x27;a</span><br><span class="hljs-comment">// 参数x y 与返回值 return_value 的生命周期均不短于&#x27;a</span><br><span class="hljs-comment">// 这里在调用函数的时候，&#x27;a获得的是 x y生命周期重叠的部分</span><br></code></pre></td></tr></table></figure>
<ul>
<li>结构体的生命周期</li>
</ul>
<p>结构体以引用作为字段类型时，必须标注生命周期，因为需要保证当结构体实例有效时，其引用也应当有效。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;&#123;<br>    field: &amp;<span class="hljs-symbol">&#x27;a</span> type_name,<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="生命周期的省略">19.2 生命周期的省略</h3>
<p>Rust编译器使用以下三个规则依次检查<code>fn</code>定义或<code>impl</code>块，若不能判断生命周期，则编译报错需要手动标注生命周期。</p>
<ul>
<li>输入参数的每个引用类型参数都有自己的生命周期</li>
<li>如果只有一个输入生命周期参数，则将该生命周期赋给所有输出生命周期参数</li>
<li>如果有多个输入生命周期参数，但其中有<code>&amp;self</code>或<code>&amp;mut self</code>是方法，则将该生命周期赋给所有输出生命周期参数</li>
</ul>
<h3 id="方法的生命周期标注">19.3 方法的生命周期标注</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;&#123;<br>    field: &amp;<span class="hljs-symbol">&#x27;a</span> type_name,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; struct_name&lt;<span class="hljs-symbol">&#x27;a</span>&gt;&#123;<br>    <span class="hljs-comment">// impl块的&lt;&#x27;a&gt;不能省略</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>, s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>        <span class="hljs-keyword">self</span>.field<br>    &#125;<br>    <span class="hljs-comment">// 根据规则省略生命周期标注</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="静态生命周期">19.4 静态生命周期</h3>
<p><code>'static</code>生命周期指整个程序的持续时间，保证不被移除作用域。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_hello_str</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>&#123;<br>    <span class="hljs-string">&quot;Hello&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="闭包">20. 闭包</h2>
<p>闭包是可以保存进变量或作为参数传递给其他函数的匿名函数。不同于函数，闭包允许捕获调用者作用域中的值。</p>
<h3 id="闭包的定义">20.1 闭包的定义</h3>
<p>匿名函数一般不需要指定函数参数与返回值类型。且可以访问上文中声明的变量，也就是从所在环境中捕获值。编译器自动判断以何种方式捕获，（获得所有权、可变或不可变引用），或以<code>move</code>关键字强制获得所有权移动。该技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = |x, y|&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = |x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = x + y;<br>    a * <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-comment">// 没有返回类型标注并且只有一行代码时可以省略花括号</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = |x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>| x + y;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = |x, y| x + y;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = || s;<br><span class="hljs-title function_ invoke__">lambda</span>(); <span class="hljs-comment">// ok, return s with ownership</span><br><span class="hljs-title function_ invoke__">lambda</span>(); <span class="hljs-comment">// failed, moved out</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">lambda</span> = |ss: S| s;<br><span class="hljs-title function_ invoke__">lambda</span>(); <span class="hljs-comment">// ok, return s with ownership</span><br><span class="hljs-title function_ invoke__">lambda</span>(); <span class="hljs-comment">// failed, moved out</span><br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">equal_to_x</span> = <span class="hljs-keyword">move</span> |z| z == x; <span class="hljs-comment">// ownership moved into closure</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, x); <span class="hljs-comment">// invalid visit to x</span><br><span class="hljs-built_in">assert!</span>(<span class="hljs-title function_ invoke__">equal_to_x</span>(y)); <span class="hljs-comment">// ok</span><br><span class="hljs-built_in">assert!</span>(<span class="hljs-title function_ invoke__">equal_to_x</span>(y)); <span class="hljs-comment">// invalid because x in closure has been dropped after previous call</span><br></code></pre></td></tr></table></figure>
<h3 id="fn-trait与结构体">20.2 <code>Fn Trait</code>与结构体</h3>
<p>即使两个闭包有完全相同的签名也属于不同的类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lambda</span> = |x, y| x + y;<br>lambda = |x, y| x + y; <span class="hljs-comment">// failed</span><br></code></pre></td></tr></table></figure>
<p>由于闭包能从所在环境中捕获值，而获得值的方法存在获得所有权、可变借用、不可变借用的区别，所以闭包之间存在区别。</p>
<p>所有的闭包都实现了以下<code>Trait</code>中的一个：</p>
<ul>
<li>取得捕获值的所有权：所有闭包都能实现<code>FnOnce</code></li>
<li>可变借用：没有移动捕获值的实现了<code>FnMut</code></li>
<li>不可变借用：无需可变访问捕获值的实现了<code>Fn</code></li>
</ul>
<p>结构体持有闭包时因为不能指定类型所以需要使用<code>Trait bound</code>实现。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cacher</span>&lt;T&gt;<br><span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span><br>&#123;<br>    calc: T,<br>    key: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;,<br>    value: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculation</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Calculating...&quot;</span>);<br>    x.<span class="hljs-title function_ invoke__">pow</span>(<span class="hljs-number">2</span>)<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt; <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(func: T) <span class="hljs-punctuation">-&gt;</span> Cacher&lt;T&gt;&#123;<br>        <span class="hljs-keyword">return</span> Cacher&#123;<br>            calc: func,<br>            key: <span class="hljs-type">Option</span>::<span class="hljs-literal">None</span>,<br>            value: <span class="hljs-type">Option</span>::<span class="hljs-literal">None</span><br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">visit</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.key &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(key) =&gt; &#123;<br>                <span class="hljs-keyword">if</span> key == x&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.value.<span class="hljs-title function_ invoke__">unwrap</span>();<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = (<span class="hljs-keyword">self</span>.calc)(x);<br>                    <span class="hljs-keyword">self</span>.key = <span class="hljs-title function_ invoke__">Some</span>(x);<br>                    <span class="hljs-keyword">self</span>.value = <span class="hljs-title function_ invoke__">Some</span>(c);<br>                    <span class="hljs-keyword">return</span> c;<br>                &#125;<br>            &#125;,<br>            <span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = (<span class="hljs-keyword">self</span>.calc)(x);<br>                <span class="hljs-keyword">self</span>.key = <span class="hljs-title function_ invoke__">Some</span>(x);<br>                <span class="hljs-keyword">self</span>.value = <span class="hljs-title function_ invoke__">Some</span>(c);<br>                <span class="hljs-keyword">return</span> c;<br>            &#125;,<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cacher</span> = Cacher::<span class="hljs-title function_ invoke__">new</span>(calculation);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Returns: &#123;&#125;&quot;</span>, cacher.<span class="hljs-title function_ invoke__">visit</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// calculating... 4</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Returns: &#123;&#125;&quot;</span>, cacher.<span class="hljs-title function_ invoke__">visit</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 4</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Returns: &#123;&#125;&quot;</span>, cacher.<span class="hljs-title function_ invoke__">visit</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// calculating... 16</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Returns: &#123;&#125;&quot;</span>, cacher.<span class="hljs-title function_ invoke__">visit</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// calculating... 25</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="迭代器">21. 迭代器</h2>
<h3 id="iterator-trait">21.1 <code>Iterator Trait</code></h3>
<p><code>Iterator Trait</code>要求实现<code>next</code>方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>    <span class="hljs-comment">// 此处省略了方法的默认实现</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="迭代器的创建">21.2 迭代器的创建</h3>
<p>Rust迭代器属于惰性迭代器，在创建但不访问时不会有任何效果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">iter</span> = v.<span class="hljs-title function_ invoke__">iter</span>(); <span class="hljs-comment">// 引用</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">iter_mut</span> = v.<span class="hljs-title function_ invoke__">iter_mut</span>(); <span class="hljs-comment">// 可变引用</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">into_iter</span> = v.<span class="hljs-title function_ invoke__">into_iter</span>(); <span class="hljs-comment">// 获得所有权</span><br></code></pre></td></tr></table></figure>
<h3 id="迭代器的使用">21.3 迭代器的使用</h3>
<h4 id="next方法">21.3.1 <code>next</code>方法</h4>
<p><code>next</code>方法实现的是对迭代器获得下一个项目，需要迭代器本身是可变的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">iter</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_ invoke__">iter</span>();<br><span class="hljs-built_in">assert_eq!</span>(iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-number">1</span>);<br><span class="hljs-built_in">assert_eq!</span>(iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-number">2</span>);<br><span class="hljs-built_in">assert_eq!</span>(iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-number">3</span>);<br><span class="hljs-built_in">assert_eq!</span>(iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>
<p><code>next</code>返回包裹元素类型的<code>Option&lt;type_name&gt;</code>枚举，在返回所有元素后返回<code>None</code>。</p>
<h4 id="for语句">21.3.2 <code>for</code>语句</h4>
<p><code>for</code>语句可以自动将可迭代对象转换为可变的迭代器对象，并对返回的<code>Option</code>解包。</p>
<h3 id="迭代器的转换">21.4 迭代器的转换</h3>
<ul>
<li><code>map</code>方法接收一个闭包将一个迭代器转化为另一个，可以使用<code>collect</code>转化为其他的类型。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x|&#123;x + <span class="hljs-number">1</span>&#125;);<br><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x + <span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li><code>filter</code>方法接收一个返回值为<code>bool</code>的闭包，将为<code>true</code>的元素组成一个新的迭代器。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = (<span class="hljs-number">0</span>..<span class="hljs-number">100</span>).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">clone</span>().<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|x|&#123;x % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>&#125;).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure>
<ul>
<li><code>zip</code>方法接收另一个同等长度的迭代器，将两个迭代器的元素组成一对对<code>Tuple</code>作为元素返回迭代器。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">iter</span> = v1.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">zip</span>(v2.<span class="hljs-title function_ invoke__">into_iter</span>());<br></code></pre></td></tr></table></figure>
<h3 id="实现-iterator-trait-来创建自定义迭代器">21.5 实现
<code>Iterator trait</code> 来创建自定义迭代器</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span>&lt;T&gt; &#123;<br>    storage: <span class="hljs-type">Vec</span>&lt;T&gt;,<br>    counter: <span class="hljs-type">usize</span>,<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; Counter&lt;T&gt;&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(v: <span class="hljs-type">Vec</span>&lt;T&gt;) <span class="hljs-punctuation">-&gt;</span> Counter&lt;T&gt; &#123;<br>        Counter &#123; storage: v, counter: <span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>&#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&lt;T&gt; <br><span class="hljs-keyword">where</span> T: <span class="hljs-built_in">Clone</span><br>&#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = T;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;&#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.counter &gt;= <span class="hljs-keyword">self</span>.storage.<span class="hljs-title function_ invoke__">len</span>()&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Option</span>::&lt;<span class="hljs-keyword">Self</span>::Item&gt;::<span class="hljs-literal">None</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">self</span>.counter += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Option</span>::&lt;<span class="hljs-keyword">Self</span>::Item&gt;::<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>.storage[<span class="hljs-keyword">self</span>.counter-<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">clone</span>())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="智能指针">22. 智能指针</h2>
<p>智能指针是一类数据结构，它们的表现类似指针，但是也拥有额外的元数据和功能。普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；相反，在大部分情况下，智能指针拥有它们指向的数据。</p>
<p>智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了
<code>Deref trait</code> 和 <code>Drop trait</code>。</p>
<p><code>Deref trait</code>允许智能指针结构体实例表现的像引用一样。</p>
<p><code>Drop trait</code>允许我们自定义当智能指针离开作用域时运行的代码。</p>
<h3 id="boxt">22.1 <code>Box&lt;T&gt;</code></h3>
<p>在stack上存有一个指向一块heap内存的指针。大多应用于：</p>
<ul>
<li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li>
<li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定 trait
而不是其具体类型的时候</li>
</ul>
<h4 id="boxt的创建">22.1.1<code>Box&lt;T&gt;</code>的创建</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_box</span>&lt;T&gt;(b: <span class="hljs-type">Box</span>&lt;T&gt;) <span class="hljs-keyword">where</span> T: Display&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b);<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br><span class="hljs-title function_ invoke__">print_box</span>(x); <span class="hljs-comment">// ok</span><br><span class="hljs-title function_ invoke__">print_box</span>(x); <span class="hljs-comment">// failed moved out</span><br></code></pre></td></tr></table></figure>
<h3 id="递归类型">22.2 递归类型</h3>
<p>当一个结构体或枚举的一个字段的类型涉及到它本身，称为递归类型。因为不能在编译的时候确定递归何时会结束，不能确定具体的内存大小，所以Rust不能编译通过这样的代码。可以使用<code>Box&lt;T&gt;</code>解决。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">enum_name</span>&#123;<br>    <span class="hljs-title function_ invoke__">Node</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">Box</span>&lt;enum_name&gt;),<br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = enum_name::<span class="hljs-title function_ invoke__">Node</span>(<br>        <span class="hljs-number">1</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<br>            enum_name::<span class="hljs-title function_ invoke__">Node</span>(<br>                <span class="hljs-number">2</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<br>                    enum_name::Nil<br>                )<br>            )<br>        )<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="deref-trait">22.3 <code>Deref Trait</code></h3>
<p>自定义解引用运算符，返回一个引用，使得能够使用<code>*</code>运算符。<code>*x -&gt; *x.deref())</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt;(T);<br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>        <span class="hljs-title function_ invoke__">MyBox</span>(x)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(x);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(x);<br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x); <span class="hljs-comment">// ok</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y); <span class="hljs-comment">// ok</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *z); <span class="hljs-comment">// ok since MyBox impl Deref: *z -&gt; (*(z.deref()))</span><br></code></pre></td></tr></table></figure>
<h3 id="derefmut-trait">22.4 <code>DerefMut Trait</code></h3>
<p>Rust 提供了 <code>DerefMut Trait</code> 用于重载可变引用的
<code>*</code> 运算符。</p>
<h3 id="解引用强制转换">22.5 解引用强制转换</h3>
<p>解引用强制转换<code>Defer Coercion</code>发生在实现了<code>Defer Trait</code>的类型需要解引用的时候。解引用强制转换可以将一个类型的表达式<code>*T</code>通过隐式调用<code>deref</code>方式转换成<code>*(T.deref())</code>，但Rust编译器只会如此操作一次，不会无限递归转换。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(x);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(MyBox::<span class="hljs-title function_ invoke__">new</span>(x));<br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x); <span class="hljs-comment">// ok</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, y); <span class="hljs-comment">// failed due to inconsistent type</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y); <span class="hljs-comment">// ok: *y -&gt; *(y.deref()) -&gt; *(&amp;int)</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *z); <span class="hljs-comment">// failed since deref coercion happens only once</span><br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *(*z.<span class="hljs-title function_ invoke__">deref</span>())); <span class="hljs-comment">// ok: *(*z.deref()) -&gt; *(*&amp;MyBox) -&gt; *MyBox -&gt; deref coercion</span><br></code></pre></td></tr></table></figure>
<p>在这种以下这些情况，Rust执行<code>Deref Coercion</code>：</p>
<ul>
<li>实现了<code>T: Deref&lt;Target=U&gt;</code>的，允许<code>&amp;T</code>转换为<code>&amp;U</code></li>
<li>实现了<code>T: DerefMut&lt;Target=U&gt;</code>的，允许<code>&amp;mut T</code>转换为<code>&amp;mut U</code></li>
<li>实现了<code>T: Deref&lt;Target=U&gt;</code>的，允许<code>&amp;mut T</code>转换为<code>&amp;U</code></li>
</ul>
<h3 id="自动解引用">22.6 自动解引用</h3>
<p>自动解引用也是与<code>Deref Trait</code>有关。Rust编译器会不断给<code>&amp;type</code>（<code>type</code>也可以是引用）添加<code>*</code>成为<code>&amp;*type</code>、<code>&amp;**type</code>、<code>&amp;***type</code>等，使得得到一个符合函数签名所需要的引用类型。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_equal</span>(a: &amp;<span class="hljs-type">i32</span>, b: &amp;<span class="hljs-type">i32</span>)&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a==b);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(MyBox::<span class="hljs-title function_ invoke__">new</span>(x));<br>    <span class="hljs-title function_ invoke__">is_equal</span>(&amp;<span class="hljs-number">5</span>, &amp;y); <span class="hljs-comment">// ok</span><br>    <span class="hljs-title function_ invoke__">is_equal</span>(&amp;&amp;<span class="hljs-number">5</span>, &amp;&amp;&amp;&amp;y); <span class="hljs-comment">// ok</span><br>    <span class="hljs-title function_ invoke__">is_equal</span>(&amp;<span class="hljs-number">5</span>, &amp;(*y)); <span class="hljs-comment">// ok</span><br>    <span class="hljs-title function_ invoke__">is_equal</span>(&amp;<span class="hljs-number">5</span>, &amp;(**y)); <span class="hljs-comment">// ok</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="drop-trait">22.7 <code>Drop Trait</code></h3>
<p>实现<code>Drop Trait</code>可以定义值将要离开作用域时发生的作用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Rust不允许手动调用<code>drop</code>方法，但可以使用<code>drop()</code>函数提前释放值。</p>
<h3 id="rct">22.8 <code>Rc&lt;T&gt;</code></h3>
<p><code>Rc&lt;T&gt;</code>结构体指引用计数，可以实现一块值的多重所有权。通过不可变引用，
<code>Rc&lt;T&gt;</code>
允许在程序的多个部分之间只读地共享数据。<code>Rc&lt;T&gt;</code>实例不可变引用这个块的值，并记录不可变引用的次数。<code>Rc&lt;T&gt;</code>只能用于单线程。</p>
<h4 id="rct的创建">22.8.1 <code>Rc&lt;T&gt;</code>的创建</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)); <span class="hljs-comment">// new value here</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a); <span class="hljs-comment">// reference here counter++</span><br></code></pre></td></tr></table></figure>
<h4 id="rct的销毁">22.8.2 <code>Rc&lt;T&gt;</code>的销毁</h4>
<p>每个<code>Rc&lt;T&gt;</code>实例离开作用域时，对引用次数减一。当没有引用时，值也离开作用域。</p>
<h3 id="refcellt">22.8 <code>RefCell&lt;T&gt;</code></h3>
<p>实现不可变对象但能够修改内部值的效果，可以在“违背”借用规则的情况下通过编译。但注意，仍需要保证对内存的借用规则，否则会在运行时<code>panic</code>。</p>
<p><code>RefCell&lt;T&gt;</code>记录存在多少个活跃的<code>Ref&lt;T&gt;</code>与<code>RefMut&lt;T&gt;</code>智能指针：</p>
<ul>
<li>调用<code>borrow</code>方法不可变借用计数加1，返回<code>Ref&lt;T&gt;</code></li>
<li>调用<code>borrow_mut</code>方法可变借用计数加1，返回<code>RefMut&lt;T&gt;</code></li>
<li><code>Ref&lt;T&gt;</code>离开作用域，不可变借用计数减1</li>
<li><code>RefMut&lt;T&gt;</code>离开作用域，可变借用计数减1</li>
</ul>
<p>需要根据可变借用与不可变借用计数器保证，在运行时对同块内存符合借用规则，否则会报错。</p>
<h4 id="refcellt的创建">22.8.1 <code>RefCell&lt;T&gt;</code>的创建</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure>
<h4 id="refcellt的使用">22.8.2 <code>RefCell&lt;T&gt;</code>的使用</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v_borrow</span> = v.<span class="hljs-title function_ invoke__">borrow</span>(); <span class="hljs-comment">// Ref&lt;type_name&gt;</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v_borrow_mut</span> = v.<span class="hljs-title function_ invoke__">borrow_mut</span>(); <span class="hljs-comment">// RefMut&lt;type_name&gt;</span><br><span class="hljs-title function_ invoke__">drop</span>(v_borrow); <span class="hljs-comment">// move out immutable borrow, otherwise violate borrow rule and panic during runtime</span><br>*v_borrow_mut += <span class="hljs-number">1</span>; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>
<h4 id="结合rc和refcell来拥有多个可变数据所有者">22.8.3
结合<code>Rc</code>和<code>RefCell</code>来拥有多个可变数据所有者</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="hljs-type">i32</span>&gt;&gt;, Rc&lt;List&gt;),<br>    Nil,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;value), Rc::<span class="hljs-title function_ invoke__">new</span>(Nil)));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-title function_ invoke__">Cons</span>(Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>)), Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-title function_ invoke__">Cons</span>(Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">4</span>)), Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br><br>    *value.<span class="hljs-title function_ invoke__">borrow_mut</span>() += <span class="hljs-number">10</span>;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a after = &#123;:?&#125;&quot;</span>, a);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;b after = &#123;:?&#125;&quot;</span>, b);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;c after = &#123;:?&#125;&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="boxrcrefcell比较">22.9 <code>Box/Rc/RefCell</code>比较</h3>
<table>

<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><code>Box&lt;T&gt;</code></th>
<th style="text-align: center;"><code>Rc&lt;T&gt;</code></th>
<th style="text-align: center;"><code>RefCell&lt;T&gt;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">同一块数据的所有者</td>
<td style="text-align: center;">一个</td>
<td style="text-align: center;">多个</td>
<td style="text-align: center;">一个</td>
</tr>
<tr class="even">
<td style="text-align: center;">可变性</td>
<td style="text-align: center;">可变、不可变借用</td>
<td style="text-align: center;">不可变借用</td>
<td style="text-align: center;">可变、不可变借用</td>
</tr>
<tr class="odd">
<td style="text-align: center;">借用检查</td>
<td style="text-align: center;">编译时</td>
<td style="text-align: center;">编译时</td>
<td style="text-align: center;">运行时</td>
</tr>
</tbody>
</table>
<h3 id="引用循环">22.10 引用循环</h3>
<p><code>Rc&lt;T&gt;</code>的<code>clone</code>方法增加强引用计数器<code>Rc::strong_count</code>的方法保存分享所有权的个数，当强引用为0的时候可以将它安全释放。但如果<code>Rc&lt;T&gt;</code>的强引用涉及循环，则不能安全地将强引用减到0，则这部分空间不能释放。</p>
<p>使用<code>Weak&lt;T&gt;</code>避免这个问题。<code>Rc::downgrade(&amp;Rc&lt;T&gt;)</code>方法获得一个<code>Weak&lt;T&gt;</code>，并增加<code>Rc::weak_count</code>，它不为0不会阻止释放空间。使用<code>Weak&lt;T&gt;</code>前需要调用<code>upgrade()</code>方法返回<code>Option&lt;Rc&lt;T&gt;&gt;</code>以确保存在。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;42&quot;</span>));<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Rc::<span class="hljs-title function_ invoke__">downgrade</span>(&amp;a);<br><span class="hljs-title function_ invoke__">drop</span>(a);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = b.<span class="hljs-title function_ invoke__">upgrade</span>().<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// failed due to moved-out a</span><br></code></pre></td></tr></table></figure>
<h2 id="高级rust特性">23. 高级Rust特性</h2>
<h3 id="unsafe-rust">23.1 Unsafe Rust</h3>
<p>不安全的Rust不提供强制的内存安全保障。但没有停用借用检查，或其他的安全检查。在<code>unsafe</code>环境中可以：</p>
<ul>
<li><p>解引用原始指针</p>
<p>允许多个可变不可变指针同时指向同一内存，忽略借用规则，无法保证指向合理内存，可能为<code>null</code>并且不能自动清理内存。</p>
<ul>
<li>可变的：<code>*mut T</code></li>
<li>不可变的：<code>*const T</code>解引用后不能直接赋值</li>
</ul></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">ptr0</span> = &amp;num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">ptr1</span> = &amp;<span class="hljs-keyword">mut</span> num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">address</span> = <span class="hljs-number">0x12345usize</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">ptr2</span> = address <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>;<br><span class="hljs-keyword">unsafe</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, *ptr0); <span class="hljs-comment">// ok</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, *ptr1); <span class="hljs-comment">// ok</span><br>    *ptr1 += <span class="hljs-number">1</span>; <span class="hljs-comment">// ok but not allowed by borrow rule in safe code</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, *ptr2); <span class="hljs-comment">// pass compilation but maybe runtime error</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>调用<code>unsafe</code>函数或方法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function_name0</span>()&#123;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function_name1</span>()&#123;<br>    <span class="hljs-keyword">unsafe</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">unsafe</span>&#123;<br>        <span class="hljs-title function_ invoke__">function_name0</span>();<br>    &#125;<br>    <span class="hljs-title function_ invoke__">function_name1</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>访问或修改可变的静态变量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNTER: <span class="hljs-type">u32</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_count</span>(inc: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        COUNTER += inc;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">add_to_count</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>实现<code>unsafe trait</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name</span>&#123;<br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>();<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">struct_name</span>(<span class="hljs-type">i32</span>);<br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">struct_name</span>&#123;<br>    <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method_name</span>() &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有些时候我们能够确认一些代码是内存安全的，但Rust编译器不能分析出其中的内存借用关系而直接拒绝通过编译，这时候可以使用<code>unsafe</code>绕过，但我们必须手动保证内存的安全性。</p>
<p>例子：将一个切片的可变引用在某处切开返回</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">split_at_mut</span>(slice: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], mid: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> (&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>]) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = slice.<span class="hljs-title function_ invoke__">len</span>();<br>    <span class="hljs-built_in">assert!</span>(mid &lt;= len);<br>    (&amp;<span class="hljs-keyword">mut</span> slice[..mid], &amp;<span class="hljs-keyword">mut</span> slice[mid..]) <span class="hljs-comment">// failed: slice mutable borrow twice</span><br>&#125;<br><br><br><span class="hljs-comment">// ok</span><br><span class="hljs-keyword">use</span> std::slice;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">split_at_mut</span>(slice: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], mid: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> (&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>]) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = slice.<span class="hljs-title function_ invoke__">len</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ptr</span> = slice.<span class="hljs-title function_ invoke__">as_mut_ptr</span>();<br>    <span class="hljs-built_in">assert!</span>(mid &lt;= len);<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        (slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(ptr, mid),<br>         slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="hljs-title function_ invoke__">add</span>(mid), len - mid))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="高级trait">23.2 高级<code>Trait</code></h3>
<h4 id="关联类型">23.2.1 关联类型</h4>
<p>关联类型是<code>Trait</code>中的类型占位符，可以用于<code>Trait</code>方法的签名中。</p>
<p>与泛型的区别：</p>
<ul>
<li>泛型在实现<code>Trait</code>时需要标注类型，关联类型不需要</li>
<li>泛型可以为一个类型指定不同的泛型参数来多次实现某个<code>Trait</code>，关联参数不能</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span>&#123;&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator0</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>; <span class="hljs-comment">// Item: 类型占位符</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator1</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt;;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator0</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = type_name;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// failed</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator0</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = another_type_name;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator1</span>&lt;type_name&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;type_name&gt;&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator1</span>&lt;another_type_name&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;another_type_name&gt;&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="运算符重载与默认泛型参数">23.2.2 运算符重载与默认泛型参数</h4>
<p>Rust不允许自定义运算符，但可以通过实现<code>std::ops</code>中的<code>Trait</code>来定义一部分运算符的行为。</p>
<p>这里涉及到默认泛型参数<code>&lt;PlaceholderType=ConcreteType&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Add</span>&lt;RHS=<span class="hljs-keyword">Self</span>&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, rhs: RHS) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>::Output;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Point;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Point) <span class="hljs-punctuation">-&gt;</span> Point &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x + other.x,<br>            y: <span class="hljs-keyword">self</span>.y + other.y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">0</span> &#125; + Point &#123; x: <span class="hljs-number">2</span>, y: <span class="hljs-number">3</span> &#125;,<br>               Point &#123; x: <span class="hljs-number">3</span>, y: <span class="hljs-number">3</span> &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Add;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Millimeters</span>(<span class="hljs-type">u32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Meters</span>(<span class="hljs-type">u32</span>);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span>&lt;Meters&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Millimeters</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Millimeters;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Meters) <span class="hljs-punctuation">-&gt;</span> Millimeters &#123;<br>        <span class="hljs-title function_ invoke__">Millimeters</span>(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> + (other.<span class="hljs-number">0</span> * <span class="hljs-number">1000</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="完全限定语法与同名函数与方法">23.2.3
完全限定语法与同名函数与方法</h4>
<p>完全限定语法（Fully Qualified
Syntax）：<code>&lt;type_name as trait_name&gt;::function(receiver_if_method, arg)</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name0</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>();<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name1</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>();<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">strcut_name</span>&#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name0</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">strcut_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;trait_name0::method&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;trait_name0::function&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">trait_name1</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">strcut_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;trait_name1::method&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;trait_name1::function&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">strcut_name</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;strcut_name::method&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;strcut_name::function&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = strcut_name&#123;&#125;;<br>    v.<span class="hljs-title function_ invoke__">method</span>(); <span class="hljs-comment">// strcut_name::method</span><br>    trait_name0::<span class="hljs-title function_ invoke__">method</span>(&amp;v); <span class="hljs-comment">// trait_name0::method</span><br>    trait_name1::<span class="hljs-title function_ invoke__">method</span>(&amp;v); <span class="hljs-comment">// trait_name1::method</span><br>    <br>    strcut_name::<span class="hljs-title function_ invoke__">function</span>(); <span class="hljs-comment">// strcut_name::function</span><br>    &lt;strcut_name <span class="hljs-keyword">as</span> trait_name0&gt;::<span class="hljs-title function_ invoke__">function</span>(); <span class="hljs-comment">// trait_name0::method 完全限定语法</span><br>    &lt;strcut_name <span class="hljs-keyword">as</span> trait_name1&gt;::<span class="hljs-title function_ invoke__">function</span>(); <span class="hljs-comment">// trait_name1::method 完全限定语法</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="supertrait">23.2.4 Supertrait</h4>
<p>有时我们可能会需要某个<code>Trait</code>使用另一个<code>Trait</code>的功能。在这种情况下，需要能够依赖相关的<code>Trait</code>也被实现。该<code>Trait</code>为当前<code>Trait</code>的<code>Super Trait</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">trait_name</span>: supertrait_name&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">method</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-comment">// visit method of self as supertrait</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="使用newtype绕过孤儿规则">23.2.5 使用newtype绕过孤儿规则</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> outer_trait;<br><span class="hljs-keyword">use</span> outer_struct;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span>(outer_struct); <span class="hljs-comment">// newtype</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">outer_trait</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">outer_struct</span>&#123;<br>    <span class="hljs-comment">// pass </span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="高级类型">23.3 高级类型</h3>
<h4 id="类型别名">23.3.1 类型别名</h4>
<p>为一个已经存在的类型生成一个别名同义词，而不是定义一个新的类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">my_type</span> = something;<br></code></pre></td></tr></table></figure>
<h4 id="never类型">23.3.2 Never类型</h4>
<p>Never类型（<code>!</code>类型）没有任何值，是空类型，在不返回值的函数中充当返回类型，注意与<code>()</code>返回类型区别。</p>
<p>不返回值的函数，也就是返回<code>!</code>的函数称为发散函数。返回的<code>!</code>可以强制转换为其他类型以通过编译。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// ok</span><br><span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-comment">// return type of each arm shall be same</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>: <span class="hljs-type">u32</span> = <span class="hljs-keyword">match</span> guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>() &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>        <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">continue</span>, <span class="hljs-comment">// return ! and coerced into needed type to pass compilation</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// ok</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">match</span> <span class="hljs-number">1</span> &#123;<br>    <span class="hljs-number">1</span>|<span class="hljs-number">2</span>|<span class="hljs-number">3</span>|<span class="hljs-number">4</span> =&gt; <span class="hljs-number">42</span>,<br>    _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Error&quot;</span>), <span class="hljs-comment">// return !</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<!--TODO：动态大小与Sized Trait, ?Sized Trait约束-->
<h4 id="高级函数与闭包">23.3.3 高级函数与闭包</h4>
<p>函数可以作为函数指针传入接收<code>fn</code>类型参数的函数。函数在传递过程中会被强制转换成<code>fn</code>类型。</p>
<p>函数指针实现了所有三个闭包的<code>Trait</code>
（<code>Fn</code>、<code>FnMut</code>和<code>FnOnce</code>），可以向需要闭包的函数参数传递函数指针。</p>
<p>闭包在没有捕获环境变量的情况下可以传给需要函数指针参数的函数，但若闭包捕获了环境变量则不能这么做。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_one</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    x + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">wrapper</span>(func: <span class="hljs-title function_ invoke__">fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>, arg: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    <span class="hljs-title function_ invoke__">func</span>(arg)<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-title function_ invoke__">wrapper</span>(add_one, <span class="hljs-number">41</span>);<br></code></pre></td></tr></table></figure>
<p>闭包由于不具有具体的编译时大小所以不能在不使用泛型或<code>Trait</code>的前提下作为参数传入或返回。可以使用<code>Box&lt;T&gt;</code>解决。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">returns_closure</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&gt; &#123;<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(|x| x + <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="宏">23.4 宏</h4>
<p>宏编程与一般的Rust编程有较大差别，本文暂不涉及。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://danielkeep.github.io/tlborm/book/index.html"><em>The
Little Book of Rust Macros</em></a></p>
</blockquote>
<h2 id="自动化测试">24. 自动化测试</h2>
<h3 id="编写与运行测试">24.1 编写与运行测试</h3>
<p>Rust的测试通过函数来实现，测试函数体通常执行三个操作：</p>
<ul>
<li>准备测试数据或测试状态</li>
<li>运行被测试的代码</li>
<li>断言结果</li>
</ul>
<p>通过对函数添加<code>#[test]</code>属性将一个函数标记为测试函数。执行<code>cargo test</code>命令构建一个<code>Test Runner</code>创建线程调用标注了<code>#[test]</code>的函数并报告是否通过了测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_one</span>(x: <span class="hljs-type">i32</span>)<span class="hljs-punctuation">-&gt;</span><span class="hljs-type">i32</span>&#123;<br>    x + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span> <span class="hljs-comment">// 标记该模块只在测试时编译</span><br><span class="hljs-keyword">mod</span> test&#123;<br>    <span class="hljs-meta">#[test]</span> <span class="hljs-comment">// 标记为测试函数</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_add_one</span>()&#123;<br>        <span class="hljs-built_in">assert_eq!</span>(super::<span class="hljs-title function_ invoke__">add_one</span>(<span class="hljs-number">41</span>), <span class="hljs-number">42</span>); <span class="hljs-comment">// panic即为测试失败</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="断言">24.2 断言</h3>
<ul>
<li><p><code>assert!()</code></p>
<p>接受一个<code>bool</code>值，为<code>true</code>时通过，为<code>false</code>时调用<code>panic!</code>，测试失败。</p></li>
<li><p><code>assert_eq!()</code></p>
<p>接受两个值，断言相等，自动打印两个值，需要实现<code>PartialEq Trait</code>与<code>Debug Trait</code></p></li>
<li><p><code>asser_ne!()</code></p>
<p>接受两个值，断言不相等，自动打印两个值，需要实现<code>PartialEq Trait</code>与<code>Debug Trait</code></p></li>
</ul>
<h3 id="自定义信息">24.3 自定义信息</h3>
<p>可以对上述三个断言宏再添加一个自定义信息作为错误信息打印。自定义信息会被传给<code>format!</code>宏，所以可以使用占位符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ###rust">#[test]<br>fn test_add_one()&#123;<br>    let num = super::add_one(40);<br>    assert!(num==41, &quot;Oh no!!!&quot;);<br>    assert!(num==42, &quot;Oh no, it is &#123;&#125;&quot;, num);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="测试需要panic的情况">24.4 测试需要<code>panic</code>的情况</h3>
<p>一般地，测试代码一旦<code>panic</code>即被判定测试失败，但有时需要测试代码应当在非法的情况下<code>panic</code>，可以对测试函数添加<code>#[should_panic]</code>属性，此时测试代码未<code>panic</code>则未能通过，触发<code>panic</code>才能通过测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">visit</span>(v: &amp;[<span class="hljs-type">i32</span>], i:<span class="hljs-type">i32</span>)<span class="hljs-punctuation">-&gt;</span><span class="hljs-type">i32</span>&#123;<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Index UnderFlow&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i &gt;= v.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Index Overflow&quot;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        v[i <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">mod</span> test&#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test</span>()&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = &amp;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>        super::<span class="hljs-title function_ invoke__">visit</span>(v, -<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果需要区别<code>panic</code>的类型，可在<code>#[should_panic]</code>属性后添加<code>expected</code>字段：<code>#[should_panic(expected="panic_message")]</code>，若<code>panic</code>消息中包含<code>panic_message</code>才能通过测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[should_panic(expected=<span class="hljs-string">&quot;Overflow&quot;</span>)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test</span>()&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="使用resultt-e枚举测试">24.5
使用<code>Result&lt;T, E&gt;</code>枚举测试</h3>
<p>当测试函数用<code>Result&lt;T,E&gt;</code>枚举进行测试时，可以不出发<code>panic</code>完成测试目的，当返回<code>Result::Ok</code>时测试通过，返回<code>Result::Err</code>测试失败。此时<code>#[should_panic]</code>标签不能使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span> == <span class="hljs-number">4</span> &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;two plus two does not equal four&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="控制测试运行">24.6 控制测试运行</h3>
<p>默认地，<code>cargo test</code>：</p>
<ul>
<li>多线程并行运行各个测试</li>
<li>测试所有测试函数</li>
<li>在测试通过时，不显示标准输出<code>println!</code>等</li>
</ul>
<p>运行<code>cargo test --help</code>获取可以直接跟在<code>cargo test</code>后的开关，一般针对<code>cargo test</code>。</p>
<p>运行<code>cargo test -- --help</code>获取可以跟在<code>cargo test --</code>
后的开关，一般针对测试用二进制文件。</p>
<p>以下为几个常见的开关：</p>
<ul>
<li><p><code>--test-threads</code></p>
<p>控制测试进程个数：<code>cargo test -- --test-threads=1</code></p></li>
<li><p><code>--show-output</code></p>
<p>在测试通过时也显示标准输出：
<code>cargo test -- --show-output</code></p></li>
</ul>
<h3 id="按名称运行测试">24.7 按名称运行测试</h3>
<p>可以通过指定需要运行的测试函数名（或其一部分）或需要运行的测试模块名（或其一部分）或需要运行的集成测试<code>crate</code>名（或其一部分）运行部分测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo <span class="hljs-built_in">test</span> test_mod_name<br>cargo <span class="hljs-built_in">test</span> test_func_name<br>cargo <span class="hljs-built_in">test</span> half_test_mod_name<br>cargo <span class="hljs-built_in">test</span> half_test_func_name<br></code></pre></td></tr></table></figure>
<h3 id="忽略测试">24.8 忽略测试</h3>
<p>可为某些测试函数添加<code>#[ignore]</code>属性忽略该测试，而完成余下的测试。</p>
<p>执行<code>cargo test -- --ignored</code>运行被忽略的测试，过滤未忽略的测试。</p>
<h3 id="单元测试与集成测试">24.9 单元测试与集成测试</h3>
<p>单元测试的目的是在与其他部分隔离的环境中测试每一个单元的代码，通常测试代码放在<code>./src/</code>文件夹下，并为专门用于测试的模块添加属性<code>#[test]</code>。</p>
<p>集成测试的目的是将各个模块组合起来测试，完全独立于被测试库之外，需要手动导入。集成测试代码文件均存放于<code>./tests/</code>下，每个测试文件都是一个单独的测试用<code>crate</code>，不需要标记<code>#[cfg(test)]</code>。</p>
<p>如果项目是没有<code>./src/lib.rs</code>，只有<code>./src/main.rs</code>的<code>binary crate</code>，则不能使用<code>./tests/</code>创建集成测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// file: ./tests/common.rs</span><br><span class="hljs-comment">// would be run in test, not recommanded</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">setup</span>&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br><br><span class="hljs-comment">// file: ./tests/common/mod.rs</span><br><span class="hljs-comment">// better one</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">setup</span>&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br><br><span class="hljs-comment">// file: ./tests/test_crate0.rs</span><br><span class="hljs-keyword">use</span> package_name::*;<br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_function0</span>&#123;<br>    common::<span class="hljs-title function_ invoke__">setup</span>()<br>    <span class="hljs-comment">// pass</span><br>&#125;<br><br><span class="hljs-comment">// file: ./tests/test_crate1.rs</span><br><span class="hljs-keyword">use</span> package_name::*;<br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_function1</span>&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="并发与并行">25. 并发与并行</h2>
<ul>
<li>并发（<em>Concurrent</em>）：程序的不同部分独立执行</li>
<li>并行（<em>Parallel</em>）：程序的不同部分同时执行</li>
</ul>
<p>Rust可以在没有细微bug的情况下无畏并发，Rust的并发泛指并发与并行。Rust的标准库支持的是一个Rust语言进程对于一个操作系统进程。</p>
<h3 id="线程的创建与阻塞">25.1 线程的创建与阻塞</h3>
<p><code>thread::spawn()</code>接受一个需要执行的闭包。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust">thread::<span class="hljs-title function_ invoke__">spawn</span>(||&#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello World: No.&#123;&#125;&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>上述代码单独运行可能不会输出任何结果，因为主线程先于子线程结束，此时需要阻塞主线程至子线程结束。</p>
<p><code>thread::spawn()</code>返回的是<code>JoinHandle&lt;&gt;</code>类型，调用其<code>join().unwrap()</code>方法，可以阻塞本线程至调用的线程运行结束。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(||&#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello World: No.&#123;&#125;&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;);<br>handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure>
<p>当子线程需要借用用其他线程的值时，值可能先于子线程使用时被移出作用域。所以需要在闭包中使用<code>move</code>关键字强制将所有权转移给子线程的闭包。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">4</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;This is a vec &#123;:?&#125;&quot;</span>, v);<br>&#125;)<br><span class="hljs-title function_ invoke__">drop</span>(v); <span class="hljs-comment">// failed bacause ownership has been moved into closure of thread</span><br>handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure>
<h3 id="使用消息实现进程间通信">25.2 使用消息实现进程间通信</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (sender, receiver) = mpsc::channel::&lt;type_name&gt;(); <span class="hljs-comment">// 默认有缓冲</span><br>sender.<span class="hljs-title function_ invoke__">send</span>(value); <span class="hljs-comment">// 返回 Result</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">sender_clone</span> = sender.<span class="hljs-title function_ invoke__">clone</span>(); <span class="hljs-comment">// 实现多个发送者</span><br>receiver.<span class="hljs-title function_ invoke__">recv</span>() <span class="hljs-comment">// 返回 Result, 阻塞至有消息</span><br>receiver.<span class="hljs-title function_ invoke__">try_recv</span>() <span class="hljs-comment">// 返回 Result, 不阻塞</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">received_msg</span> <span class="hljs-keyword">in</span> receiver&#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="使用共享实现进程间通信">25.3 使用共享实现进程间通信</h3>
<p>Rust可以使用互斥锁（与<code>RefCell</code>类似，提供内部可变性）与多线程安全的<code>Arc&lt;T&gt;</code>实现对共享数据的并发同步。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">lock</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 互斥锁 但不能实现多个进程间的共享所有权</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">lock</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(lock); <span class="hljs-comment">// Arc是多线程安全的Rc API一样</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">lock</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;lock);<br>    handles.<span class="hljs-title function_ invoke__">push</span>(<br>        thread::<span class="hljs-title function_ invoke__">spawn</span>(||&#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            *num += <span class="hljs-number">1</span>;<br>        &#125;)<br>    );<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles&#123;<br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, lock.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br></code></pre></td></tr></table></figure>
<h3 id="send-trait和sync-trait">25.4
<code>Send Trait</code>和<code>Sync Trait</code></h3>
<p><code>Send Trait</code>允许在线程之间转移所有权，如<code>Rc&lt;T&gt;</code>和原始指针没有实现就不能转移给子线程，其他类型几乎都可以。</p>
<p><code>Sync Trait</code>允许安全地被多个线程引用，<code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code>、<code>Cell&lt;T&gt;</code>家族不是<code>Sync</code>的。</p>
<p>手动实现<code>Send Trait</code>和<code>Sync Trait</code>是极其有可能不安全的。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Language/">#Language</a>
      
        <a href="/tags/Rust/">#Rust</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Rust基础入门</div>
      <div>http://hello-world-my-world.github.io/2022/03/05/2022-03-05-Rust基础入门/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Doctor</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>March 5, 2022</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - Non-commercial">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
                  <span class="hint--top hint--rounded" aria-label="ND - No derivative works">
                    <i class="iconfont icon-nd"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/22/2022-09-22-Hexo%E5%88%9D%E6%AD%A5%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/" title="Hexo初步部署指南">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hexo初步部署指南</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/24/2022-01-24-Golang%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Golang快速入门">
                        <span class="hidden-mobile">Golang快速入门</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
